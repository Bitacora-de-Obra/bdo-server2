
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model KeyPersonnel
 * 
 */
export type KeyPersonnel = $Result.DefaultSelection<Prisma.$KeyPersonnelPayload>
/**
 * Model Communication
 * 
 */
export type Communication = $Result.DefaultSelection<Prisma.$CommunicationPayload>
/**
 * Model CommunicationStatusHistory
 * 
 */
export type CommunicationStatusHistory = $Result.DefaultSelection<Prisma.$CommunicationStatusHistoryPayload>
/**
 * Model ContractModification
 * 
 */
export type ContractModification = $Result.DefaultSelection<Prisma.$ContractModificationPayload>
/**
 * Model WeeklyReport
 * 
 */
export type WeeklyReport = $Result.DefaultSelection<Prisma.$WeeklyReportPayload>
/**
 * Model LogEntry
 * 
 */
export type LogEntry = $Result.DefaultSelection<Prisma.$LogEntryPayload>
/**
 * Model LogEntryHistory
 * 
 */
export type LogEntryHistory = $Result.DefaultSelection<Prisma.$LogEntryHistoryPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Signature
 * 
 */
export type Signature = $Result.DefaultSelection<Prisma.$SignaturePayload>
/**
 * Model Attachment
 * 
 */
export type Attachment = $Result.DefaultSelection<Prisma.$AttachmentPayload>
/**
 * Model Acta
 * 
 */
export type Acta = $Result.DefaultSelection<Prisma.$ActaPayload>
/**
 * Model Commitment
 * 
 */
export type Commitment = $Result.DefaultSelection<Prisma.$CommitmentPayload>
/**
 * Model CostActa
 * 
 */
export type CostActa = $Result.DefaultSelection<Prisma.$CostActaPayload>
/**
 * Model Observation
 * 
 */
export type Observation = $Result.DefaultSelection<Prisma.$ObservationPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model Drawing
 * 
 */
export type Drawing = $Result.DefaultSelection<Prisma.$DrawingPayload>
/**
 * Model DrawingVersion
 * 
 */
export type DrawingVersion = $Result.DefaultSelection<Prisma.$DrawingVersionPayload>
/**
 * Model PhotoEntry
 * 
 */
export type PhotoEntry = $Result.DefaultSelection<Prisma.$PhotoEntryPayload>
/**
 * Model ControlPoint
 * 
 */
export type ControlPoint = $Result.DefaultSelection<Prisma.$ControlPointPayload>
/**
 * Model ProjectTask
 * 
 */
export type ProjectTask = $Result.DefaultSelection<Prisma.$ProjectTaskPayload>
/**
 * Model ContractItem
 * 
 */
export type ContractItem = $Result.DefaultSelection<Prisma.$ContractItemPayload>
/**
 * Model WorkActa
 * 
 */
export type WorkActa = $Result.DefaultSelection<Prisma.$WorkActaPayload>
/**
 * Model WorkActaItem
 * 
 */
export type WorkActaItem = $Result.DefaultSelection<Prisma.$WorkActaItemPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  RESIDENT: 'RESIDENT',
  SUPERVISOR: 'SUPERVISOR',
  CONTRACTOR_REP: 'CONTRACTOR_REP'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const AppRole: {
  admin: 'admin',
  editor: 'editor',
  viewer: 'viewer'
};

export type AppRole = (typeof AppRole)[keyof typeof AppRole]


export const DeliveryMethod: {
  SYSTEM: 'SYSTEM',
  MAIL: 'MAIL',
  PHYSICAL: 'PHYSICAL'
};

export type DeliveryMethod = (typeof DeliveryMethod)[keyof typeof DeliveryMethod]


export const CommunicationStatus: {
  PENDIENTE: 'PENDIENTE',
  EN_TRAMITE: 'EN_TRAMITE',
  RESUELTO: 'RESUELTO',
  ARCHIVADO: 'ARCHIVADO'
};

export type CommunicationStatus = (typeof CommunicationStatus)[keyof typeof CommunicationStatus]


export const ModificationType: {
  ADDITION: 'ADDITION',
  TIME_EXTENSION: 'TIME_EXTENSION',
  SCOPE_CHANGE: 'SCOPE_CHANGE',
  SUSPENSION: 'SUSPENSION',
  REINSTATEMENT: 'REINSTATEMENT',
  OTHER: 'OTHER'
};

export type ModificationType = (typeof ModificationType)[keyof typeof ModificationType]


export const EntryType: {
  GENERAL: 'GENERAL',
  QUALITY: 'QUALITY',
  SAFETY: 'SAFETY',
  ADMINISTRATIVE: 'ADMINISTRATIVE',
  TECHNICAL: 'TECHNICAL'
};

export type EntryType = (typeof EntryType)[keyof typeof EntryType]


export const EntryStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED',
  NEEDS_REVIEW: 'NEEDS_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type EntryStatus = (typeof EntryStatus)[keyof typeof EntryStatus]


export const ActaArea: {
  COMITE_OBRA: 'COMITE_OBRA',
  COMITE_TECNICO: 'COMITE_TECNICO',
  HSE: 'HSE',
  CALIDAD: 'CALIDAD',
  SOCIAL: 'SOCIAL',
  AMBIENTAL: 'AMBIENTAL',
  OTHER: 'OTHER'
};

export type ActaArea = (typeof ActaArea)[keyof typeof ActaArea]


export const ActaStatus: {
  DRAFT: 'DRAFT',
  FOR_SIGNATURES: 'FOR_SIGNATURES',
  SIGNED: 'SIGNED',
  CANCELLED: 'CANCELLED'
};

export type ActaStatus = (typeof ActaStatus)[keyof typeof ActaStatus]


export const CommitmentStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  DELAYED: 'DELAYED'
};

export type CommitmentStatus = (typeof CommitmentStatus)[keyof typeof CommitmentStatus]


export const CostActaStatus: {
  SUBMITTED: 'SUBMITTED',
  IN_REVIEW: 'IN_REVIEW',
  OBSERVED: 'OBSERVED',
  APPROVED: 'APPROVED',
  IN_PAYMENT: 'IN_PAYMENT',
  PAID: 'PAID',
  REJECTED: 'REJECTED'
};

export type CostActaStatus = (typeof CostActaStatus)[keyof typeof CostActaStatus]


export const ReportScope: {
  OBRA: 'OBRA',
  INTERVENTORIA: 'INTERVENTORIA'
};

export type ReportScope = (typeof ReportScope)[keyof typeof ReportScope]


export const ReportStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED',
  OBSERVED: 'OBSERVED',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus]


export const DrawingDiscipline: {
  ARQUITECTONICO: 'ARQUITECTONICO',
  ESTRUCTURAL: 'ESTRUCTURAL',
  HIDROSANITARIO: 'HIDROSANITARIO',
  ELECTRICO: 'ELECTRICO',
  MECANICO: 'MECANICO',
  SENALIZACION: 'SENALIZACION',
  OTHER: 'OTHER'
};

export type DrawingDiscipline = (typeof DrawingDiscipline)[keyof typeof DrawingDiscipline]


export const DrawingStatus: {
  VIGENTE: 'VIGENTE',
  OBSOLETO: 'OBSOLETO',
  ANULADO: 'ANULADO'
};

export type DrawingStatus = (typeof DrawingStatus)[keyof typeof DrawingStatus]


export const WorkActaStatus: {
  DRAFT: 'DRAFT',
  IN_REVIEW: 'IN_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type WorkActaStatus = (typeof WorkActaStatus)[keyof typeof WorkActaStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type AppRole = $Enums.AppRole

export const AppRole: typeof $Enums.AppRole

export type DeliveryMethod = $Enums.DeliveryMethod

export const DeliveryMethod: typeof $Enums.DeliveryMethod

export type CommunicationStatus = $Enums.CommunicationStatus

export const CommunicationStatus: typeof $Enums.CommunicationStatus

export type ModificationType = $Enums.ModificationType

export const ModificationType: typeof $Enums.ModificationType

export type EntryType = $Enums.EntryType

export const EntryType: typeof $Enums.EntryType

export type EntryStatus = $Enums.EntryStatus

export const EntryStatus: typeof $Enums.EntryStatus

export type ActaArea = $Enums.ActaArea

export const ActaArea: typeof $Enums.ActaArea

export type ActaStatus = $Enums.ActaStatus

export const ActaStatus: typeof $Enums.ActaStatus

export type CommitmentStatus = $Enums.CommitmentStatus

export const CommitmentStatus: typeof $Enums.CommitmentStatus

export type CostActaStatus = $Enums.CostActaStatus

export const CostActaStatus: typeof $Enums.CostActaStatus

export type ReportScope = $Enums.ReportScope

export const ReportScope: typeof $Enums.ReportScope

export type ReportStatus = $Enums.ReportStatus

export const ReportStatus: typeof $Enums.ReportStatus

export type DrawingDiscipline = $Enums.DrawingDiscipline

export const DrawingDiscipline: typeof $Enums.DrawingDiscipline

export type DrawingStatus = $Enums.DrawingStatus

export const DrawingStatus: typeof $Enums.DrawingStatus

export type WorkActaStatus = $Enums.WorkActaStatus

export const WorkActaStatus: typeof $Enums.WorkActaStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs>;

  /**
   * `prisma.keyPersonnel`: Exposes CRUD operations for the **KeyPersonnel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KeyPersonnels
    * const keyPersonnels = await prisma.keyPersonnel.findMany()
    * ```
    */
  get keyPersonnel(): Prisma.KeyPersonnelDelegate<ExtArgs>;

  /**
   * `prisma.communication`: Exposes CRUD operations for the **Communication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Communications
    * const communications = await prisma.communication.findMany()
    * ```
    */
  get communication(): Prisma.CommunicationDelegate<ExtArgs>;

  /**
   * `prisma.communicationStatusHistory`: Exposes CRUD operations for the **CommunicationStatusHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunicationStatusHistories
    * const communicationStatusHistories = await prisma.communicationStatusHistory.findMany()
    * ```
    */
  get communicationStatusHistory(): Prisma.CommunicationStatusHistoryDelegate<ExtArgs>;

  /**
   * `prisma.contractModification`: Exposes CRUD operations for the **ContractModification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContractModifications
    * const contractModifications = await prisma.contractModification.findMany()
    * ```
    */
  get contractModification(): Prisma.ContractModificationDelegate<ExtArgs>;

  /**
   * `prisma.weeklyReport`: Exposes CRUD operations for the **WeeklyReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WeeklyReports
    * const weeklyReports = await prisma.weeklyReport.findMany()
    * ```
    */
  get weeklyReport(): Prisma.WeeklyReportDelegate<ExtArgs>;

  /**
   * `prisma.logEntry`: Exposes CRUD operations for the **LogEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogEntries
    * const logEntries = await prisma.logEntry.findMany()
    * ```
    */
  get logEntry(): Prisma.LogEntryDelegate<ExtArgs>;

  /**
   * `prisma.logEntryHistory`: Exposes CRUD operations for the **LogEntryHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogEntryHistories
    * const logEntryHistories = await prisma.logEntryHistory.findMany()
    * ```
    */
  get logEntryHistory(): Prisma.LogEntryHistoryDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.signature`: Exposes CRUD operations for the **Signature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Signatures
    * const signatures = await prisma.signature.findMany()
    * ```
    */
  get signature(): Prisma.SignatureDelegate<ExtArgs>;

  /**
   * `prisma.attachment`: Exposes CRUD operations for the **Attachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attachments
    * const attachments = await prisma.attachment.findMany()
    * ```
    */
  get attachment(): Prisma.AttachmentDelegate<ExtArgs>;

  /**
   * `prisma.acta`: Exposes CRUD operations for the **Acta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actas
    * const actas = await prisma.acta.findMany()
    * ```
    */
  get acta(): Prisma.ActaDelegate<ExtArgs>;

  /**
   * `prisma.commitment`: Exposes CRUD operations for the **Commitment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commitments
    * const commitments = await prisma.commitment.findMany()
    * ```
    */
  get commitment(): Prisma.CommitmentDelegate<ExtArgs>;

  /**
   * `prisma.costActa`: Exposes CRUD operations for the **CostActa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CostActas
    * const costActas = await prisma.costActa.findMany()
    * ```
    */
  get costActa(): Prisma.CostActaDelegate<ExtArgs>;

  /**
   * `prisma.observation`: Exposes CRUD operations for the **Observation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Observations
    * const observations = await prisma.observation.findMany()
    * ```
    */
  get observation(): Prisma.ObservationDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.drawing`: Exposes CRUD operations for the **Drawing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drawings
    * const drawings = await prisma.drawing.findMany()
    * ```
    */
  get drawing(): Prisma.DrawingDelegate<ExtArgs>;

  /**
   * `prisma.drawingVersion`: Exposes CRUD operations for the **DrawingVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DrawingVersions
    * const drawingVersions = await prisma.drawingVersion.findMany()
    * ```
    */
  get drawingVersion(): Prisma.DrawingVersionDelegate<ExtArgs>;

  /**
   * `prisma.photoEntry`: Exposes CRUD operations for the **PhotoEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhotoEntries
    * const photoEntries = await prisma.photoEntry.findMany()
    * ```
    */
  get photoEntry(): Prisma.PhotoEntryDelegate<ExtArgs>;

  /**
   * `prisma.controlPoint`: Exposes CRUD operations for the **ControlPoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ControlPoints
    * const controlPoints = await prisma.controlPoint.findMany()
    * ```
    */
  get controlPoint(): Prisma.ControlPointDelegate<ExtArgs>;

  /**
   * `prisma.projectTask`: Exposes CRUD operations for the **ProjectTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectTasks
    * const projectTasks = await prisma.projectTask.findMany()
    * ```
    */
  get projectTask(): Prisma.ProjectTaskDelegate<ExtArgs>;

  /**
   * `prisma.contractItem`: Exposes CRUD operations for the **ContractItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContractItems
    * const contractItems = await prisma.contractItem.findMany()
    * ```
    */
  get contractItem(): Prisma.ContractItemDelegate<ExtArgs>;

  /**
   * `prisma.workActa`: Exposes CRUD operations for the **WorkActa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkActas
    * const workActas = await prisma.workActa.findMany()
    * ```
    */
  get workActa(): Prisma.WorkActaDelegate<ExtArgs>;

  /**
   * `prisma.workActaItem`: Exposes CRUD operations for the **WorkActaItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkActaItems
    * const workActaItems = await prisma.workActaItem.findMany()
    * ```
    */
  get workActaItem(): Prisma.WorkActaItemDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Project: 'Project',
    KeyPersonnel: 'KeyPersonnel',
    Communication: 'Communication',
    CommunicationStatusHistory: 'CommunicationStatusHistory',
    ContractModification: 'ContractModification',
    WeeklyReport: 'WeeklyReport',
    LogEntry: 'LogEntry',
    LogEntryHistory: 'LogEntryHistory',
    Comment: 'Comment',
    Signature: 'Signature',
    Attachment: 'Attachment',
    Acta: 'Acta',
    Commitment: 'Commitment',
    CostActa: 'CostActa',
    Observation: 'Observation',
    Report: 'Report',
    Drawing: 'Drawing',
    DrawingVersion: 'DrawingVersion',
    PhotoEntry: 'PhotoEntry',
    ControlPoint: 'ControlPoint',
    ProjectTask: 'ProjectTask',
    ContractItem: 'ContractItem',
    WorkActa: 'WorkActa',
    WorkActaItem: 'WorkActaItem'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "project" | "keyPersonnel" | "communication" | "communicationStatusHistory" | "contractModification" | "weeklyReport" | "logEntry" | "logEntryHistory" | "comment" | "signature" | "attachment" | "acta" | "commitment" | "costActa" | "observation" | "report" | "drawing" | "drawingVersion" | "photoEntry" | "controlPoint" | "projectTask" | "contractItem" | "workActa" | "workActaItem"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      KeyPersonnel: {
        payload: Prisma.$KeyPersonnelPayload<ExtArgs>
        fields: Prisma.KeyPersonnelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KeyPersonnelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyPersonnelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KeyPersonnelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyPersonnelPayload>
          }
          findFirst: {
            args: Prisma.KeyPersonnelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyPersonnelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KeyPersonnelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyPersonnelPayload>
          }
          findMany: {
            args: Prisma.KeyPersonnelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyPersonnelPayload>[]
          }
          create: {
            args: Prisma.KeyPersonnelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyPersonnelPayload>
          }
          createMany: {
            args: Prisma.KeyPersonnelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.KeyPersonnelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyPersonnelPayload>
          }
          update: {
            args: Prisma.KeyPersonnelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyPersonnelPayload>
          }
          deleteMany: {
            args: Prisma.KeyPersonnelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KeyPersonnelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KeyPersonnelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeyPersonnelPayload>
          }
          aggregate: {
            args: Prisma.KeyPersonnelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKeyPersonnel>
          }
          groupBy: {
            args: Prisma.KeyPersonnelGroupByArgs<ExtArgs>
            result: $Utils.Optional<KeyPersonnelGroupByOutputType>[]
          }
          count: {
            args: Prisma.KeyPersonnelCountArgs<ExtArgs>
            result: $Utils.Optional<KeyPersonnelCountAggregateOutputType> | number
          }
        }
      }
      Communication: {
        payload: Prisma.$CommunicationPayload<ExtArgs>
        fields: Prisma.CommunicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          findFirst: {
            args: Prisma.CommunicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          findMany: {
            args: Prisma.CommunicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>[]
          }
          create: {
            args: Prisma.CommunicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          createMany: {
            args: Prisma.CommunicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommunicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          update: {
            args: Prisma.CommunicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          deleteMany: {
            args: Prisma.CommunicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommunicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationPayload>
          }
          aggregate: {
            args: Prisma.CommunicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunication>
          }
          groupBy: {
            args: Prisma.CommunicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunicationCountArgs<ExtArgs>
            result: $Utils.Optional<CommunicationCountAggregateOutputType> | number
          }
        }
      }
      CommunicationStatusHistory: {
        payload: Prisma.$CommunicationStatusHistoryPayload<ExtArgs>
        fields: Prisma.CommunicationStatusHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunicationStatusHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationStatusHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunicationStatusHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationStatusHistoryPayload>
          }
          findFirst: {
            args: Prisma.CommunicationStatusHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationStatusHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunicationStatusHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationStatusHistoryPayload>
          }
          findMany: {
            args: Prisma.CommunicationStatusHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationStatusHistoryPayload>[]
          }
          create: {
            args: Prisma.CommunicationStatusHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationStatusHistoryPayload>
          }
          createMany: {
            args: Prisma.CommunicationStatusHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommunicationStatusHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationStatusHistoryPayload>
          }
          update: {
            args: Prisma.CommunicationStatusHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationStatusHistoryPayload>
          }
          deleteMany: {
            args: Prisma.CommunicationStatusHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunicationStatusHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommunicationStatusHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunicationStatusHistoryPayload>
          }
          aggregate: {
            args: Prisma.CommunicationStatusHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunicationStatusHistory>
          }
          groupBy: {
            args: Prisma.CommunicationStatusHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunicationStatusHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunicationStatusHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<CommunicationStatusHistoryCountAggregateOutputType> | number
          }
        }
      }
      ContractModification: {
        payload: Prisma.$ContractModificationPayload<ExtArgs>
        fields: Prisma.ContractModificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractModificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractModificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractModificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractModificationPayload>
          }
          findFirst: {
            args: Prisma.ContractModificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractModificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractModificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractModificationPayload>
          }
          findMany: {
            args: Prisma.ContractModificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractModificationPayload>[]
          }
          create: {
            args: Prisma.ContractModificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractModificationPayload>
          }
          createMany: {
            args: Prisma.ContractModificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContractModificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractModificationPayload>
          }
          update: {
            args: Prisma.ContractModificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractModificationPayload>
          }
          deleteMany: {
            args: Prisma.ContractModificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractModificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContractModificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractModificationPayload>
          }
          aggregate: {
            args: Prisma.ContractModificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContractModification>
          }
          groupBy: {
            args: Prisma.ContractModificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractModificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractModificationCountArgs<ExtArgs>
            result: $Utils.Optional<ContractModificationCountAggregateOutputType> | number
          }
        }
      }
      WeeklyReport: {
        payload: Prisma.$WeeklyReportPayload<ExtArgs>
        fields: Prisma.WeeklyReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WeeklyReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WeeklyReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyReportPayload>
          }
          findFirst: {
            args: Prisma.WeeklyReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WeeklyReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyReportPayload>
          }
          findMany: {
            args: Prisma.WeeklyReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyReportPayload>[]
          }
          create: {
            args: Prisma.WeeklyReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyReportPayload>
          }
          createMany: {
            args: Prisma.WeeklyReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WeeklyReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyReportPayload>
          }
          update: {
            args: Prisma.WeeklyReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyReportPayload>
          }
          deleteMany: {
            args: Prisma.WeeklyReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WeeklyReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WeeklyReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WeeklyReportPayload>
          }
          aggregate: {
            args: Prisma.WeeklyReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWeeklyReport>
          }
          groupBy: {
            args: Prisma.WeeklyReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<WeeklyReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.WeeklyReportCountArgs<ExtArgs>
            result: $Utils.Optional<WeeklyReportCountAggregateOutputType> | number
          }
        }
      }
      LogEntry: {
        payload: Prisma.$LogEntryPayload<ExtArgs>
        fields: Prisma.LogEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>
          }
          findFirst: {
            args: Prisma.LogEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>
          }
          findMany: {
            args: Prisma.LogEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>[]
          }
          create: {
            args: Prisma.LogEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>
          }
          createMany: {
            args: Prisma.LogEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LogEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>
          }
          update: {
            args: Prisma.LogEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>
          }
          deleteMany: {
            args: Prisma.LogEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryPayload>
          }
          aggregate: {
            args: Prisma.LogEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogEntry>
          }
          groupBy: {
            args: Prisma.LogEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogEntryCountArgs<ExtArgs>
            result: $Utils.Optional<LogEntryCountAggregateOutputType> | number
          }
        }
      }
      LogEntryHistory: {
        payload: Prisma.$LogEntryHistoryPayload<ExtArgs>
        fields: Prisma.LogEntryHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogEntryHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogEntryHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryHistoryPayload>
          }
          findFirst: {
            args: Prisma.LogEntryHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogEntryHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryHistoryPayload>
          }
          findMany: {
            args: Prisma.LogEntryHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryHistoryPayload>[]
          }
          create: {
            args: Prisma.LogEntryHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryHistoryPayload>
          }
          createMany: {
            args: Prisma.LogEntryHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LogEntryHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryHistoryPayload>
          }
          update: {
            args: Prisma.LogEntryHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryHistoryPayload>
          }
          deleteMany: {
            args: Prisma.LogEntryHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogEntryHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogEntryHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogEntryHistoryPayload>
          }
          aggregate: {
            args: Prisma.LogEntryHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogEntryHistory>
          }
          groupBy: {
            args: Prisma.LogEntryHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogEntryHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogEntryHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<LogEntryHistoryCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Signature: {
        payload: Prisma.$SignaturePayload<ExtArgs>
        fields: Prisma.SignatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SignatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SignatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          findFirst: {
            args: Prisma.SignatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SignatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          findMany: {
            args: Prisma.SignatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>[]
          }
          create: {
            args: Prisma.SignatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          createMany: {
            args: Prisma.SignatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SignatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          update: {
            args: Prisma.SignatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          deleteMany: {
            args: Prisma.SignatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SignatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SignatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SignaturePayload>
          }
          aggregate: {
            args: Prisma.SignatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSignature>
          }
          groupBy: {
            args: Prisma.SignatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<SignatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.SignatureCountArgs<ExtArgs>
            result: $Utils.Optional<SignatureCountAggregateOutputType> | number
          }
        }
      }
      Attachment: {
        payload: Prisma.$AttachmentPayload<ExtArgs>
        fields: Prisma.AttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findFirst: {
            args: Prisma.AttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          findMany: {
            args: Prisma.AttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>[]
          }
          create: {
            args: Prisma.AttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          createMany: {
            args: Prisma.AttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          update: {
            args: Prisma.AttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          deleteMany: {
            args: Prisma.AttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttachmentPayload>
          }
          aggregate: {
            args: Prisma.AttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttachment>
          }
          groupBy: {
            args: Prisma.AttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<AttachmentCountAggregateOutputType> | number
          }
        }
      }
      Acta: {
        payload: Prisma.$ActaPayload<ExtArgs>
        fields: Prisma.ActaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActaPayload>
          }
          findFirst: {
            args: Prisma.ActaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActaPayload>
          }
          findMany: {
            args: Prisma.ActaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActaPayload>[]
          }
          create: {
            args: Prisma.ActaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActaPayload>
          }
          createMany: {
            args: Prisma.ActaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ActaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActaPayload>
          }
          update: {
            args: Prisma.ActaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActaPayload>
          }
          deleteMany: {
            args: Prisma.ActaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActaPayload>
          }
          aggregate: {
            args: Prisma.ActaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActa>
          }
          groupBy: {
            args: Prisma.ActaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActaCountArgs<ExtArgs>
            result: $Utils.Optional<ActaCountAggregateOutputType> | number
          }
        }
      }
      Commitment: {
        payload: Prisma.$CommitmentPayload<ExtArgs>
        fields: Prisma.CommitmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommitmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommitmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommitmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommitmentPayload>
          }
          findFirst: {
            args: Prisma.CommitmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommitmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommitmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommitmentPayload>
          }
          findMany: {
            args: Prisma.CommitmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommitmentPayload>[]
          }
          create: {
            args: Prisma.CommitmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommitmentPayload>
          }
          createMany: {
            args: Prisma.CommitmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CommitmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommitmentPayload>
          }
          update: {
            args: Prisma.CommitmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommitmentPayload>
          }
          deleteMany: {
            args: Prisma.CommitmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommitmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommitmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommitmentPayload>
          }
          aggregate: {
            args: Prisma.CommitmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommitment>
          }
          groupBy: {
            args: Prisma.CommitmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommitmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommitmentCountArgs<ExtArgs>
            result: $Utils.Optional<CommitmentCountAggregateOutputType> | number
          }
        }
      }
      CostActa: {
        payload: Prisma.$CostActaPayload<ExtArgs>
        fields: Prisma.CostActaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CostActaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostActaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CostActaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostActaPayload>
          }
          findFirst: {
            args: Prisma.CostActaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostActaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CostActaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostActaPayload>
          }
          findMany: {
            args: Prisma.CostActaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostActaPayload>[]
          }
          create: {
            args: Prisma.CostActaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostActaPayload>
          }
          createMany: {
            args: Prisma.CostActaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CostActaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostActaPayload>
          }
          update: {
            args: Prisma.CostActaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostActaPayload>
          }
          deleteMany: {
            args: Prisma.CostActaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CostActaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CostActaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostActaPayload>
          }
          aggregate: {
            args: Prisma.CostActaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCostActa>
          }
          groupBy: {
            args: Prisma.CostActaGroupByArgs<ExtArgs>
            result: $Utils.Optional<CostActaGroupByOutputType>[]
          }
          count: {
            args: Prisma.CostActaCountArgs<ExtArgs>
            result: $Utils.Optional<CostActaCountAggregateOutputType> | number
          }
        }
      }
      Observation: {
        payload: Prisma.$ObservationPayload<ExtArgs>
        fields: Prisma.ObservationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObservationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObservationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          findFirst: {
            args: Prisma.ObservationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObservationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          findMany: {
            args: Prisma.ObservationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>[]
          }
          create: {
            args: Prisma.ObservationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          createMany: {
            args: Prisma.ObservationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ObservationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          update: {
            args: Prisma.ObservationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          deleteMany: {
            args: Prisma.ObservationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ObservationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ObservationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObservationPayload>
          }
          aggregate: {
            args: Prisma.ObservationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateObservation>
          }
          groupBy: {
            args: Prisma.ObservationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ObservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObservationCountArgs<ExtArgs>
            result: $Utils.Optional<ObservationCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      Drawing: {
        payload: Prisma.$DrawingPayload<ExtArgs>
        fields: Prisma.DrawingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DrawingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrawingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DrawingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrawingPayload>
          }
          findFirst: {
            args: Prisma.DrawingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrawingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DrawingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrawingPayload>
          }
          findMany: {
            args: Prisma.DrawingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrawingPayload>[]
          }
          create: {
            args: Prisma.DrawingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrawingPayload>
          }
          createMany: {
            args: Prisma.DrawingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DrawingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrawingPayload>
          }
          update: {
            args: Prisma.DrawingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrawingPayload>
          }
          deleteMany: {
            args: Prisma.DrawingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DrawingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DrawingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrawingPayload>
          }
          aggregate: {
            args: Prisma.DrawingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDrawing>
          }
          groupBy: {
            args: Prisma.DrawingGroupByArgs<ExtArgs>
            result: $Utils.Optional<DrawingGroupByOutputType>[]
          }
          count: {
            args: Prisma.DrawingCountArgs<ExtArgs>
            result: $Utils.Optional<DrawingCountAggregateOutputType> | number
          }
        }
      }
      DrawingVersion: {
        payload: Prisma.$DrawingVersionPayload<ExtArgs>
        fields: Prisma.DrawingVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DrawingVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrawingVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DrawingVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrawingVersionPayload>
          }
          findFirst: {
            args: Prisma.DrawingVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrawingVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DrawingVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrawingVersionPayload>
          }
          findMany: {
            args: Prisma.DrawingVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrawingVersionPayload>[]
          }
          create: {
            args: Prisma.DrawingVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrawingVersionPayload>
          }
          createMany: {
            args: Prisma.DrawingVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DrawingVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrawingVersionPayload>
          }
          update: {
            args: Prisma.DrawingVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrawingVersionPayload>
          }
          deleteMany: {
            args: Prisma.DrawingVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DrawingVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DrawingVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DrawingVersionPayload>
          }
          aggregate: {
            args: Prisma.DrawingVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDrawingVersion>
          }
          groupBy: {
            args: Prisma.DrawingVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DrawingVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DrawingVersionCountArgs<ExtArgs>
            result: $Utils.Optional<DrawingVersionCountAggregateOutputType> | number
          }
        }
      }
      PhotoEntry: {
        payload: Prisma.$PhotoEntryPayload<ExtArgs>
        fields: Prisma.PhotoEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhotoEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhotoEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoEntryPayload>
          }
          findFirst: {
            args: Prisma.PhotoEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhotoEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoEntryPayload>
          }
          findMany: {
            args: Prisma.PhotoEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoEntryPayload>[]
          }
          create: {
            args: Prisma.PhotoEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoEntryPayload>
          }
          createMany: {
            args: Prisma.PhotoEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PhotoEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoEntryPayload>
          }
          update: {
            args: Prisma.PhotoEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoEntryPayload>
          }
          deleteMany: {
            args: Prisma.PhotoEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhotoEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PhotoEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhotoEntryPayload>
          }
          aggregate: {
            args: Prisma.PhotoEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhotoEntry>
          }
          groupBy: {
            args: Prisma.PhotoEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhotoEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhotoEntryCountArgs<ExtArgs>
            result: $Utils.Optional<PhotoEntryCountAggregateOutputType> | number
          }
        }
      }
      ControlPoint: {
        payload: Prisma.$ControlPointPayload<ExtArgs>
        fields: Prisma.ControlPointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ControlPointFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlPointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ControlPointFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlPointPayload>
          }
          findFirst: {
            args: Prisma.ControlPointFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlPointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ControlPointFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlPointPayload>
          }
          findMany: {
            args: Prisma.ControlPointFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlPointPayload>[]
          }
          create: {
            args: Prisma.ControlPointCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlPointPayload>
          }
          createMany: {
            args: Prisma.ControlPointCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ControlPointDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlPointPayload>
          }
          update: {
            args: Prisma.ControlPointUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlPointPayload>
          }
          deleteMany: {
            args: Prisma.ControlPointDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ControlPointUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ControlPointUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlPointPayload>
          }
          aggregate: {
            args: Prisma.ControlPointAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateControlPoint>
          }
          groupBy: {
            args: Prisma.ControlPointGroupByArgs<ExtArgs>
            result: $Utils.Optional<ControlPointGroupByOutputType>[]
          }
          count: {
            args: Prisma.ControlPointCountArgs<ExtArgs>
            result: $Utils.Optional<ControlPointCountAggregateOutputType> | number
          }
        }
      }
      ProjectTask: {
        payload: Prisma.$ProjectTaskPayload<ExtArgs>
        fields: Prisma.ProjectTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTaskPayload>
          }
          findFirst: {
            args: Prisma.ProjectTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTaskPayload>
          }
          findMany: {
            args: Prisma.ProjectTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTaskPayload>[]
          }
          create: {
            args: Prisma.ProjectTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTaskPayload>
          }
          createMany: {
            args: Prisma.ProjectTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProjectTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTaskPayload>
          }
          update: {
            args: Prisma.ProjectTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTaskPayload>
          }
          deleteMany: {
            args: Prisma.ProjectTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProjectTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTaskPayload>
          }
          aggregate: {
            args: Prisma.ProjectTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectTask>
          }
          groupBy: {
            args: Prisma.ProjectTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectTaskCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectTaskCountAggregateOutputType> | number
          }
        }
      }
      ContractItem: {
        payload: Prisma.$ContractItemPayload<ExtArgs>
        fields: Prisma.ContractItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractItemPayload>
          }
          findFirst: {
            args: Prisma.ContractItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractItemPayload>
          }
          findMany: {
            args: Prisma.ContractItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractItemPayload>[]
          }
          create: {
            args: Prisma.ContractItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractItemPayload>
          }
          createMany: {
            args: Prisma.ContractItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ContractItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractItemPayload>
          }
          update: {
            args: Prisma.ContractItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractItemPayload>
          }
          deleteMany: {
            args: Prisma.ContractItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContractItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractItemPayload>
          }
          aggregate: {
            args: Prisma.ContractItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContractItem>
          }
          groupBy: {
            args: Prisma.ContractItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractItemCountArgs<ExtArgs>
            result: $Utils.Optional<ContractItemCountAggregateOutputType> | number
          }
        }
      }
      WorkActa: {
        payload: Prisma.$WorkActaPayload<ExtArgs>
        fields: Prisma.WorkActaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkActaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkActaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkActaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkActaPayload>
          }
          findFirst: {
            args: Prisma.WorkActaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkActaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkActaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkActaPayload>
          }
          findMany: {
            args: Prisma.WorkActaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkActaPayload>[]
          }
          create: {
            args: Prisma.WorkActaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkActaPayload>
          }
          createMany: {
            args: Prisma.WorkActaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WorkActaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkActaPayload>
          }
          update: {
            args: Prisma.WorkActaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkActaPayload>
          }
          deleteMany: {
            args: Prisma.WorkActaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkActaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkActaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkActaPayload>
          }
          aggregate: {
            args: Prisma.WorkActaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkActa>
          }
          groupBy: {
            args: Prisma.WorkActaGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkActaGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkActaCountArgs<ExtArgs>
            result: $Utils.Optional<WorkActaCountAggregateOutputType> | number
          }
        }
      }
      WorkActaItem: {
        payload: Prisma.$WorkActaItemPayload<ExtArgs>
        fields: Prisma.WorkActaItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkActaItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkActaItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkActaItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkActaItemPayload>
          }
          findFirst: {
            args: Prisma.WorkActaItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkActaItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkActaItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkActaItemPayload>
          }
          findMany: {
            args: Prisma.WorkActaItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkActaItemPayload>[]
          }
          create: {
            args: Prisma.WorkActaItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkActaItemPayload>
          }
          createMany: {
            args: Prisma.WorkActaItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WorkActaItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkActaItemPayload>
          }
          update: {
            args: Prisma.WorkActaItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkActaItemPayload>
          }
          deleteMany: {
            args: Prisma.WorkActaItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkActaItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkActaItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkActaItemPayload>
          }
          aggregate: {
            args: Prisma.WorkActaItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkActaItem>
          }
          groupBy: {
            args: Prisma.WorkActaItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkActaItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkActaItemCountArgs<ExtArgs>
            result: $Utils.Optional<WorkActaItemCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    logEntries: number
    assignedTo: number
    comments: number
    signatures: number
    communications: number
    statusChanges: number
    photoEntries: number
    responsibleFor: number
    observations: number
    reports: number
    drawingVersions: number
    logEntryHistory: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logEntries?: boolean | UserCountOutputTypeCountLogEntriesArgs
    assignedTo?: boolean | UserCountOutputTypeCountAssignedToArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    signatures?: boolean | UserCountOutputTypeCountSignaturesArgs
    communications?: boolean | UserCountOutputTypeCountCommunicationsArgs
    statusChanges?: boolean | UserCountOutputTypeCountStatusChangesArgs
    photoEntries?: boolean | UserCountOutputTypeCountPhotoEntriesArgs
    responsibleFor?: boolean | UserCountOutputTypeCountResponsibleForArgs
    observations?: boolean | UserCountOutputTypeCountObservationsArgs
    reports?: boolean | UserCountOutputTypeCountReportsArgs
    drawingVersions?: boolean | UserCountOutputTypeCountDrawingVersionsArgs
    logEntryHistory?: boolean | UserCountOutputTypeCountLogEntryHistoryArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSignaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignatureWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommunicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunicationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStatusChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunicationStatusHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPhotoEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhotoEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResponsibleForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommitmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountObservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObservationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDrawingVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DrawingVersionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogEntryHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogEntryHistoryWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    keyPersonnel: number
    logEntries: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keyPersonnel?: boolean | ProjectCountOutputTypeCountKeyPersonnelArgs
    logEntries?: boolean | ProjectCountOutputTypeCountLogEntriesArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountKeyPersonnelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeyPersonnelWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountLogEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogEntryWhereInput
  }


  /**
   * Count Type CommunicationCountOutputType
   */

  export type CommunicationCountOutputType = {
    replies: number
    statusHistory: number
    attachments: number
  }

  export type CommunicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommunicationCountOutputTypeCountRepliesArgs
    statusHistory?: boolean | CommunicationCountOutputTypeCountStatusHistoryArgs
    attachments?: boolean | CommunicationCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * CommunicationCountOutputType without action
   */
  export type CommunicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationCountOutputType
     */
    select?: CommunicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommunicationCountOutputType without action
   */
  export type CommunicationCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunicationWhereInput
  }

  /**
   * CommunicationCountOutputType without action
   */
  export type CommunicationCountOutputTypeCountStatusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunicationStatusHistoryWhereInput
  }

  /**
   * CommunicationCountOutputType without action
   */
  export type CommunicationCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }


  /**
   * Count Type WeeklyReportCountOutputType
   */

  export type WeeklyReportCountOutputType = {
    attachments: number
  }

  export type WeeklyReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | WeeklyReportCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * WeeklyReportCountOutputType without action
   */
  export type WeeklyReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyReportCountOutputType
     */
    select?: WeeklyReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WeeklyReportCountOutputType without action
   */
  export type WeeklyReportCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }


  /**
   * Count Type LogEntryCountOutputType
   */

  export type LogEntryCountOutputType = {
    assignees: number
    comments: number
    attachments: number
    signatures: number
    history: number
  }

  export type LogEntryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignees?: boolean | LogEntryCountOutputTypeCountAssigneesArgs
    comments?: boolean | LogEntryCountOutputTypeCountCommentsArgs
    attachments?: boolean | LogEntryCountOutputTypeCountAttachmentsArgs
    signatures?: boolean | LogEntryCountOutputTypeCountSignaturesArgs
    history?: boolean | LogEntryCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes
  /**
   * LogEntryCountOutputType without action
   */
  export type LogEntryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntryCountOutputType
     */
    select?: LogEntryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LogEntryCountOutputType without action
   */
  export type LogEntryCountOutputTypeCountAssigneesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * LogEntryCountOutputType without action
   */
  export type LogEntryCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * LogEntryCountOutputType without action
   */
  export type LogEntryCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }

  /**
   * LogEntryCountOutputType without action
   */
  export type LogEntryCountOutputTypeCountSignaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignatureWhereInput
  }

  /**
   * LogEntryCountOutputType without action
   */
  export type LogEntryCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogEntryHistoryWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    attachments: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | CommentCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }


  /**
   * Count Type ActaCountOutputType
   */

  export type ActaCountOutputType = {
    attachments: number
    signatures: number
    commitments: number
  }

  export type ActaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | ActaCountOutputTypeCountAttachmentsArgs
    signatures?: boolean | ActaCountOutputTypeCountSignaturesArgs
    commitments?: boolean | ActaCountOutputTypeCountCommitmentsArgs
  }

  // Custom InputTypes
  /**
   * ActaCountOutputType without action
   */
  export type ActaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActaCountOutputType
     */
    select?: ActaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ActaCountOutputType without action
   */
  export type ActaCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }

  /**
   * ActaCountOutputType without action
   */
  export type ActaCountOutputTypeCountSignaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignatureWhereInput
  }

  /**
   * ActaCountOutputType without action
   */
  export type ActaCountOutputTypeCountCommitmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommitmentWhereInput
  }


  /**
   * Count Type CostActaCountOutputType
   */

  export type CostActaCountOutputType = {
    observations: number
    attachments: number
  }

  export type CostActaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    observations?: boolean | CostActaCountOutputTypeCountObservationsArgs
    attachments?: boolean | CostActaCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * CostActaCountOutputType without action
   */
  export type CostActaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostActaCountOutputType
     */
    select?: CostActaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CostActaCountOutputType without action
   */
  export type CostActaCountOutputTypeCountObservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObservationWhereInput
  }

  /**
   * CostActaCountOutputType without action
   */
  export type CostActaCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }


  /**
   * Count Type ReportCountOutputType
   */

  export type ReportCountOutputType = {
    attachments: number
    signatures: number
  }

  export type ReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | ReportCountOutputTypeCountAttachmentsArgs
    signatures?: boolean | ReportCountOutputTypeCountSignaturesArgs
  }

  // Custom InputTypes
  /**
   * ReportCountOutputType without action
   */
  export type ReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCountOutputType
     */
    select?: ReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReportCountOutputType without action
   */
  export type ReportCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }

  /**
   * ReportCountOutputType without action
   */
  export type ReportCountOutputTypeCountSignaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignatureWhereInput
  }


  /**
   * Count Type DrawingCountOutputType
   */

  export type DrawingCountOutputType = {
    versions: number
    comments: number
  }

  export type DrawingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | DrawingCountOutputTypeCountVersionsArgs
    comments?: boolean | DrawingCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * DrawingCountOutputType without action
   */
  export type DrawingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrawingCountOutputType
     */
    select?: DrawingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DrawingCountOutputType without action
   */
  export type DrawingCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DrawingVersionWhereInput
  }

  /**
   * DrawingCountOutputType without action
   */
  export type DrawingCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type ControlPointCountOutputType
   */

  export type ControlPointCountOutputType = {
    photos: number
  }

  export type ControlPointCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | ControlPointCountOutputTypeCountPhotosArgs
  }

  // Custom InputTypes
  /**
   * ControlPointCountOutputType without action
   */
  export type ControlPointCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlPointCountOutputType
     */
    select?: ControlPointCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ControlPointCountOutputType without action
   */
  export type ControlPointCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhotoEntryWhereInput
  }


  /**
   * Count Type ContractItemCountOutputType
   */

  export type ContractItemCountOutputType = {
    workActaItems: number
  }

  export type ContractItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workActaItems?: boolean | ContractItemCountOutputTypeCountWorkActaItemsArgs
  }

  // Custom InputTypes
  /**
   * ContractItemCountOutputType without action
   */
  export type ContractItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItemCountOutputType
     */
    select?: ContractItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContractItemCountOutputType without action
   */
  export type ContractItemCountOutputTypeCountWorkActaItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkActaItemWhereInput
  }


  /**
   * Count Type WorkActaCountOutputType
   */

  export type WorkActaCountOutputType = {
    items: number
    attachments: number
  }

  export type WorkActaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | WorkActaCountOutputTypeCountItemsArgs
    attachments?: boolean | WorkActaCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * WorkActaCountOutputType without action
   */
  export type WorkActaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActaCountOutputType
     */
    select?: WorkActaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkActaCountOutputType without action
   */
  export type WorkActaCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkActaItemWhereInput
  }

  /**
   * WorkActaCountOutputType without action
   */
  export type WorkActaCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    tokenVersion: number | null
  }

  export type UserSumAggregateOutputType = {
    tokenVersion: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    fullName: string | null
    projectRole: $Enums.UserRole | null
    appRole: $Enums.AppRole | null
    avatarUrl: string | null
    status: string | null
    lastLoginAt: Date | null
    tokenVersion: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    fullName: string | null
    projectRole: $Enums.UserRole | null
    appRole: $Enums.AppRole | null
    avatarUrl: string | null
    status: string | null
    lastLoginAt: Date | null
    tokenVersion: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    fullName: number
    projectRole: number
    appRole: number
    avatarUrl: number
    status: number
    lastLoginAt: number
    tokenVersion: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    tokenVersion?: true
  }

  export type UserSumAggregateInputType = {
    tokenVersion?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    fullName?: true
    projectRole?: true
    appRole?: true
    avatarUrl?: true
    status?: true
    lastLoginAt?: true
    tokenVersion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    fullName?: true
    projectRole?: true
    appRole?: true
    avatarUrl?: true
    status?: true
    lastLoginAt?: true
    tokenVersion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    fullName?: true
    projectRole?: true
    appRole?: true
    avatarUrl?: true
    status?: true
    lastLoginAt?: true
    tokenVersion?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl: string | null
    status: string
    lastLoginAt: Date | null
    tokenVersion: number
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    projectRole?: boolean
    appRole?: boolean
    avatarUrl?: boolean
    status?: boolean
    lastLoginAt?: boolean
    tokenVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    logEntries?: boolean | User$logEntriesArgs<ExtArgs>
    assignedTo?: boolean | User$assignedToArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    signatures?: boolean | User$signaturesArgs<ExtArgs>
    communications?: boolean | User$communicationsArgs<ExtArgs>
    statusChanges?: boolean | User$statusChangesArgs<ExtArgs>
    photoEntries?: boolean | User$photoEntriesArgs<ExtArgs>
    responsibleFor?: boolean | User$responsibleForArgs<ExtArgs>
    observations?: boolean | User$observationsArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    drawingVersions?: boolean | User$drawingVersionsArgs<ExtArgs>
    logEntryHistory?: boolean | User$logEntryHistoryArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    fullName?: boolean
    projectRole?: boolean
    appRole?: boolean
    avatarUrl?: boolean
    status?: boolean
    lastLoginAt?: boolean
    tokenVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logEntries?: boolean | User$logEntriesArgs<ExtArgs>
    assignedTo?: boolean | User$assignedToArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    signatures?: boolean | User$signaturesArgs<ExtArgs>
    communications?: boolean | User$communicationsArgs<ExtArgs>
    statusChanges?: boolean | User$statusChangesArgs<ExtArgs>
    photoEntries?: boolean | User$photoEntriesArgs<ExtArgs>
    responsibleFor?: boolean | User$responsibleForArgs<ExtArgs>
    observations?: boolean | User$observationsArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    drawingVersions?: boolean | User$drawingVersionsArgs<ExtArgs>
    logEntryHistory?: boolean | User$logEntryHistoryArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      logEntries: Prisma.$LogEntryPayload<ExtArgs>[]
      assignedTo: Prisma.$LogEntryPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      signatures: Prisma.$SignaturePayload<ExtArgs>[]
      communications: Prisma.$CommunicationPayload<ExtArgs>[]
      statusChanges: Prisma.$CommunicationStatusHistoryPayload<ExtArgs>[]
      photoEntries: Prisma.$PhotoEntryPayload<ExtArgs>[]
      responsibleFor: Prisma.$CommitmentPayload<ExtArgs>[]
      observations: Prisma.$ObservationPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      drawingVersions: Prisma.$DrawingVersionPayload<ExtArgs>[]
      logEntryHistory: Prisma.$LogEntryHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      fullName: string
      projectRole: $Enums.UserRole
      appRole: $Enums.AppRole
      avatarUrl: string | null
      status: string
      lastLoginAt: Date | null
      tokenVersion: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    logEntries<T extends User$logEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$logEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findMany"> | Null>
    assignedTo<T extends User$assignedToArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    signatures<T extends User$signaturesArgs<ExtArgs> = {}>(args?: Subset<T, User$signaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findMany"> | Null>
    communications<T extends User$communicationsArgs<ExtArgs> = {}>(args?: Subset<T, User$communicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findMany"> | Null>
    statusChanges<T extends User$statusChangesArgs<ExtArgs> = {}>(args?: Subset<T, User$statusChangesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationStatusHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    photoEntries<T extends User$photoEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$photoEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotoEntryPayload<ExtArgs>, T, "findMany"> | Null>
    responsibleFor<T extends User$responsibleForArgs<ExtArgs> = {}>(args?: Subset<T, User$responsibleForArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommitmentPayload<ExtArgs>, T, "findMany"> | Null>
    observations<T extends User$observationsArgs<ExtArgs> = {}>(args?: Subset<T, User$observationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findMany"> | Null>
    reports<T extends User$reportsArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    drawingVersions<T extends User$drawingVersionsArgs<ExtArgs> = {}>(args?: Subset<T, User$drawingVersionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DrawingVersionPayload<ExtArgs>, T, "findMany"> | Null>
    logEntryHistory<T extends User$logEntryHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$logEntryHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogEntryHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly projectRole: FieldRef<"User", 'UserRole'>
    readonly appRole: FieldRef<"User", 'AppRole'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'String'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly tokenVersion: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.logEntries
   */
  export type User$logEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    where?: LogEntryWhereInput
    orderBy?: LogEntryOrderByWithRelationInput | LogEntryOrderByWithRelationInput[]
    cursor?: LogEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogEntryScalarFieldEnum | LogEntryScalarFieldEnum[]
  }

  /**
   * User.assignedTo
   */
  export type User$assignedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    where?: LogEntryWhereInput
    orderBy?: LogEntryOrderByWithRelationInput | LogEntryOrderByWithRelationInput[]
    cursor?: LogEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogEntryScalarFieldEnum | LogEntryScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.signatures
   */
  export type User$signaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    where?: SignatureWhereInput
    orderBy?: SignatureOrderByWithRelationInput | SignatureOrderByWithRelationInput[]
    cursor?: SignatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SignatureScalarFieldEnum | SignatureScalarFieldEnum[]
  }

  /**
   * User.communications
   */
  export type User$communicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    where?: CommunicationWhereInput
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    cursor?: CommunicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * User.statusChanges
   */
  export type User$statusChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationStatusHistory
     */
    select?: CommunicationStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationStatusHistoryInclude<ExtArgs> | null
    where?: CommunicationStatusHistoryWhereInput
    orderBy?: CommunicationStatusHistoryOrderByWithRelationInput | CommunicationStatusHistoryOrderByWithRelationInput[]
    cursor?: CommunicationStatusHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunicationStatusHistoryScalarFieldEnum | CommunicationStatusHistoryScalarFieldEnum[]
  }

  /**
   * User.photoEntries
   */
  export type User$photoEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoEntry
     */
    select?: PhotoEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoEntryInclude<ExtArgs> | null
    where?: PhotoEntryWhereInput
    orderBy?: PhotoEntryOrderByWithRelationInput | PhotoEntryOrderByWithRelationInput[]
    cursor?: PhotoEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhotoEntryScalarFieldEnum | PhotoEntryScalarFieldEnum[]
  }

  /**
   * User.responsibleFor
   */
  export type User$responsibleForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commitment
     */
    select?: CommitmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitmentInclude<ExtArgs> | null
    where?: CommitmentWhereInput
    orderBy?: CommitmentOrderByWithRelationInput | CommitmentOrderByWithRelationInput[]
    cursor?: CommitmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommitmentScalarFieldEnum | CommitmentScalarFieldEnum[]
  }

  /**
   * User.observations
   */
  export type User$observationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    where?: ObservationWhereInput
    orderBy?: ObservationOrderByWithRelationInput | ObservationOrderByWithRelationInput[]
    cursor?: ObservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObservationScalarFieldEnum | ObservationScalarFieldEnum[]
  }

  /**
   * User.reports
   */
  export type User$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User.drawingVersions
   */
  export type User$drawingVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrawingVersion
     */
    select?: DrawingVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingVersionInclude<ExtArgs> | null
    where?: DrawingVersionWhereInput
    orderBy?: DrawingVersionOrderByWithRelationInput | DrawingVersionOrderByWithRelationInput[]
    cursor?: DrawingVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DrawingVersionScalarFieldEnum | DrawingVersionScalarFieldEnum[]
  }

  /**
   * User.logEntryHistory
   */
  export type User$logEntryHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntryHistory
     */
    select?: LogEntryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryHistoryInclude<ExtArgs> | null
    where?: LogEntryHistoryWhereInput
    orderBy?: LogEntryHistoryOrderByWithRelationInput | LogEntryHistoryOrderByWithRelationInput[]
    cursor?: LogEntryHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogEntryHistoryScalarFieldEnum | LogEntryHistoryScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    initialValue: number | null
    interventoriaInitialValue: number | null
  }

  export type ProjectSumAggregateOutputType = {
    initialValue: number | null
    interventoriaInitialValue: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    contractId: string | null
    object: string | null
    contractorName: string | null
    supervisorName: string | null
    initialValue: number | null
    startDate: Date | null
    initialEndDate: Date | null
    interventoriaContractId: string | null
    interventoriaInitialValue: number | null
    technicalSupervisorName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    contractId: string | null
    object: string | null
    contractorName: string | null
    supervisorName: string | null
    initialValue: number | null
    startDate: Date | null
    initialEndDate: Date | null
    interventoriaContractId: string | null
    interventoriaInitialValue: number | null
    technicalSupervisorName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    contractId: number
    object: number
    contractorName: number
    supervisorName: number
    initialValue: number
    startDate: number
    initialEndDate: number
    interventoriaContractId: number
    interventoriaInitialValue: number
    technicalSupervisorName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    initialValue?: true
    interventoriaInitialValue?: true
  }

  export type ProjectSumAggregateInputType = {
    initialValue?: true
    interventoriaInitialValue?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    contractId?: true
    object?: true
    contractorName?: true
    supervisorName?: true
    initialValue?: true
    startDate?: true
    initialEndDate?: true
    interventoriaContractId?: true
    interventoriaInitialValue?: true
    technicalSupervisorName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    contractId?: true
    object?: true
    contractorName?: true
    supervisorName?: true
    initialValue?: true
    startDate?: true
    initialEndDate?: true
    interventoriaContractId?: true
    interventoriaInitialValue?: true
    technicalSupervisorName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    contractId?: true
    object?: true
    contractorName?: true
    supervisorName?: true
    initialValue?: true
    startDate?: true
    initialEndDate?: true
    interventoriaContractId?: true
    interventoriaInitialValue?: true
    technicalSupervisorName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    contractId: string
    object: string
    contractorName: string
    supervisorName: string
    initialValue: number
    startDate: Date
    initialEndDate: Date
    interventoriaContractId: string
    interventoriaInitialValue: number
    technicalSupervisorName: string
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contractId?: boolean
    object?: boolean
    contractorName?: boolean
    supervisorName?: boolean
    initialValue?: boolean
    startDate?: boolean
    initialEndDate?: boolean
    interventoriaContractId?: boolean
    interventoriaInitialValue?: boolean
    technicalSupervisorName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    keyPersonnel?: boolean | Project$keyPersonnelArgs<ExtArgs>
    logEntries?: boolean | Project$logEntriesArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>


  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    contractId?: boolean
    object?: boolean
    contractorName?: boolean
    supervisorName?: boolean
    initialValue?: boolean
    startDate?: boolean
    initialEndDate?: boolean
    interventoriaContractId?: boolean
    interventoriaInitialValue?: boolean
    technicalSupervisorName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keyPersonnel?: boolean | Project$keyPersonnelArgs<ExtArgs>
    logEntries?: boolean | Project$logEntriesArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      keyPersonnel: Prisma.$KeyPersonnelPayload<ExtArgs>[]
      logEntries: Prisma.$LogEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      contractId: string
      object: string
      contractorName: string
      supervisorName: string
      initialValue: number
      startDate: Date
      initialEndDate: Date
      interventoriaContractId: string
      interventoriaInitialValue: number
      technicalSupervisorName: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    keyPersonnel<T extends Project$keyPersonnelArgs<ExtArgs> = {}>(args?: Subset<T, Project$keyPersonnelArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeyPersonnelPayload<ExtArgs>, T, "findMany"> | Null>
    logEntries<T extends Project$logEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Project$logEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */ 
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly contractId: FieldRef<"Project", 'String'>
    readonly object: FieldRef<"Project", 'String'>
    readonly contractorName: FieldRef<"Project", 'String'>
    readonly supervisorName: FieldRef<"Project", 'String'>
    readonly initialValue: FieldRef<"Project", 'Float'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly initialEndDate: FieldRef<"Project", 'DateTime'>
    readonly interventoriaContractId: FieldRef<"Project", 'String'>
    readonly interventoriaInitialValue: FieldRef<"Project", 'Float'>
    readonly technicalSupervisorName: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
  }

  /**
   * Project.keyPersonnel
   */
  export type Project$keyPersonnelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyPersonnel
     */
    select?: KeyPersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyPersonnelInclude<ExtArgs> | null
    where?: KeyPersonnelWhereInput
    orderBy?: KeyPersonnelOrderByWithRelationInput | KeyPersonnelOrderByWithRelationInput[]
    cursor?: KeyPersonnelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KeyPersonnelScalarFieldEnum | KeyPersonnelScalarFieldEnum[]
  }

  /**
   * Project.logEntries
   */
  export type Project$logEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    where?: LogEntryWhereInput
    orderBy?: LogEntryOrderByWithRelationInput | LogEntryOrderByWithRelationInput[]
    cursor?: LogEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogEntryScalarFieldEnum | LogEntryScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model KeyPersonnel
   */

  export type AggregateKeyPersonnel = {
    _count: KeyPersonnelCountAggregateOutputType | null
    _min: KeyPersonnelMinAggregateOutputType | null
    _max: KeyPersonnelMaxAggregateOutputType | null
  }

  export type KeyPersonnelMinAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    company: string | null
    email: string | null
    phone: string | null
    projectId: string | null
  }

  export type KeyPersonnelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    company: string | null
    email: string | null
    phone: string | null
    projectId: string | null
  }

  export type KeyPersonnelCountAggregateOutputType = {
    id: number
    name: number
    role: number
    company: number
    email: number
    phone: number
    projectId: number
    _all: number
  }


  export type KeyPersonnelMinAggregateInputType = {
    id?: true
    name?: true
    role?: true
    company?: true
    email?: true
    phone?: true
    projectId?: true
  }

  export type KeyPersonnelMaxAggregateInputType = {
    id?: true
    name?: true
    role?: true
    company?: true
    email?: true
    phone?: true
    projectId?: true
  }

  export type KeyPersonnelCountAggregateInputType = {
    id?: true
    name?: true
    role?: true
    company?: true
    email?: true
    phone?: true
    projectId?: true
    _all?: true
  }

  export type KeyPersonnelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KeyPersonnel to aggregate.
     */
    where?: KeyPersonnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyPersonnels to fetch.
     */
    orderBy?: KeyPersonnelOrderByWithRelationInput | KeyPersonnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KeyPersonnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyPersonnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyPersonnels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KeyPersonnels
    **/
    _count?: true | KeyPersonnelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KeyPersonnelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KeyPersonnelMaxAggregateInputType
  }

  export type GetKeyPersonnelAggregateType<T extends KeyPersonnelAggregateArgs> = {
        [P in keyof T & keyof AggregateKeyPersonnel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeyPersonnel[P]>
      : GetScalarType<T[P], AggregateKeyPersonnel[P]>
  }




  export type KeyPersonnelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeyPersonnelWhereInput
    orderBy?: KeyPersonnelOrderByWithAggregationInput | KeyPersonnelOrderByWithAggregationInput[]
    by: KeyPersonnelScalarFieldEnum[] | KeyPersonnelScalarFieldEnum
    having?: KeyPersonnelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KeyPersonnelCountAggregateInputType | true
    _min?: KeyPersonnelMinAggregateInputType
    _max?: KeyPersonnelMaxAggregateInputType
  }

  export type KeyPersonnelGroupByOutputType = {
    id: string
    name: string
    role: string
    company: string
    email: string
    phone: string
    projectId: string
    _count: KeyPersonnelCountAggregateOutputType | null
    _min: KeyPersonnelMinAggregateOutputType | null
    _max: KeyPersonnelMaxAggregateOutputType | null
  }

  type GetKeyPersonnelGroupByPayload<T extends KeyPersonnelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KeyPersonnelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KeyPersonnelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeyPersonnelGroupByOutputType[P]>
            : GetScalarType<T[P], KeyPersonnelGroupByOutputType[P]>
        }
      >
    >


  export type KeyPersonnelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    company?: boolean
    email?: boolean
    phone?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keyPersonnel"]>


  export type KeyPersonnelSelectScalar = {
    id?: boolean
    name?: boolean
    role?: boolean
    company?: boolean
    email?: boolean
    phone?: boolean
    projectId?: boolean
  }

  export type KeyPersonnelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $KeyPersonnelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KeyPersonnel"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      role: string
      company: string
      email: string
      phone: string
      projectId: string
    }, ExtArgs["result"]["keyPersonnel"]>
    composites: {}
  }

  type KeyPersonnelGetPayload<S extends boolean | null | undefined | KeyPersonnelDefaultArgs> = $Result.GetResult<Prisma.$KeyPersonnelPayload, S>

  type KeyPersonnelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KeyPersonnelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KeyPersonnelCountAggregateInputType | true
    }

  export interface KeyPersonnelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KeyPersonnel'], meta: { name: 'KeyPersonnel' } }
    /**
     * Find zero or one KeyPersonnel that matches the filter.
     * @param {KeyPersonnelFindUniqueArgs} args - Arguments to find a KeyPersonnel
     * @example
     * // Get one KeyPersonnel
     * const keyPersonnel = await prisma.keyPersonnel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KeyPersonnelFindUniqueArgs>(args: SelectSubset<T, KeyPersonnelFindUniqueArgs<ExtArgs>>): Prisma__KeyPersonnelClient<$Result.GetResult<Prisma.$KeyPersonnelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one KeyPersonnel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KeyPersonnelFindUniqueOrThrowArgs} args - Arguments to find a KeyPersonnel
     * @example
     * // Get one KeyPersonnel
     * const keyPersonnel = await prisma.keyPersonnel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KeyPersonnelFindUniqueOrThrowArgs>(args: SelectSubset<T, KeyPersonnelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KeyPersonnelClient<$Result.GetResult<Prisma.$KeyPersonnelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first KeyPersonnel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyPersonnelFindFirstArgs} args - Arguments to find a KeyPersonnel
     * @example
     * // Get one KeyPersonnel
     * const keyPersonnel = await prisma.keyPersonnel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KeyPersonnelFindFirstArgs>(args?: SelectSubset<T, KeyPersonnelFindFirstArgs<ExtArgs>>): Prisma__KeyPersonnelClient<$Result.GetResult<Prisma.$KeyPersonnelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first KeyPersonnel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyPersonnelFindFirstOrThrowArgs} args - Arguments to find a KeyPersonnel
     * @example
     * // Get one KeyPersonnel
     * const keyPersonnel = await prisma.keyPersonnel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KeyPersonnelFindFirstOrThrowArgs>(args?: SelectSubset<T, KeyPersonnelFindFirstOrThrowArgs<ExtArgs>>): Prisma__KeyPersonnelClient<$Result.GetResult<Prisma.$KeyPersonnelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more KeyPersonnels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyPersonnelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KeyPersonnels
     * const keyPersonnels = await prisma.keyPersonnel.findMany()
     * 
     * // Get first 10 KeyPersonnels
     * const keyPersonnels = await prisma.keyPersonnel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const keyPersonnelWithIdOnly = await prisma.keyPersonnel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KeyPersonnelFindManyArgs>(args?: SelectSubset<T, KeyPersonnelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeyPersonnelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a KeyPersonnel.
     * @param {KeyPersonnelCreateArgs} args - Arguments to create a KeyPersonnel.
     * @example
     * // Create one KeyPersonnel
     * const KeyPersonnel = await prisma.keyPersonnel.create({
     *   data: {
     *     // ... data to create a KeyPersonnel
     *   }
     * })
     * 
     */
    create<T extends KeyPersonnelCreateArgs>(args: SelectSubset<T, KeyPersonnelCreateArgs<ExtArgs>>): Prisma__KeyPersonnelClient<$Result.GetResult<Prisma.$KeyPersonnelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many KeyPersonnels.
     * @param {KeyPersonnelCreateManyArgs} args - Arguments to create many KeyPersonnels.
     * @example
     * // Create many KeyPersonnels
     * const keyPersonnel = await prisma.keyPersonnel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KeyPersonnelCreateManyArgs>(args?: SelectSubset<T, KeyPersonnelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KeyPersonnel.
     * @param {KeyPersonnelDeleteArgs} args - Arguments to delete one KeyPersonnel.
     * @example
     * // Delete one KeyPersonnel
     * const KeyPersonnel = await prisma.keyPersonnel.delete({
     *   where: {
     *     // ... filter to delete one KeyPersonnel
     *   }
     * })
     * 
     */
    delete<T extends KeyPersonnelDeleteArgs>(args: SelectSubset<T, KeyPersonnelDeleteArgs<ExtArgs>>): Prisma__KeyPersonnelClient<$Result.GetResult<Prisma.$KeyPersonnelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one KeyPersonnel.
     * @param {KeyPersonnelUpdateArgs} args - Arguments to update one KeyPersonnel.
     * @example
     * // Update one KeyPersonnel
     * const keyPersonnel = await prisma.keyPersonnel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KeyPersonnelUpdateArgs>(args: SelectSubset<T, KeyPersonnelUpdateArgs<ExtArgs>>): Prisma__KeyPersonnelClient<$Result.GetResult<Prisma.$KeyPersonnelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more KeyPersonnels.
     * @param {KeyPersonnelDeleteManyArgs} args - Arguments to filter KeyPersonnels to delete.
     * @example
     * // Delete a few KeyPersonnels
     * const { count } = await prisma.keyPersonnel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KeyPersonnelDeleteManyArgs>(args?: SelectSubset<T, KeyPersonnelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KeyPersonnels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyPersonnelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KeyPersonnels
     * const keyPersonnel = await prisma.keyPersonnel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KeyPersonnelUpdateManyArgs>(args: SelectSubset<T, KeyPersonnelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KeyPersonnel.
     * @param {KeyPersonnelUpsertArgs} args - Arguments to update or create a KeyPersonnel.
     * @example
     * // Update or create a KeyPersonnel
     * const keyPersonnel = await prisma.keyPersonnel.upsert({
     *   create: {
     *     // ... data to create a KeyPersonnel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KeyPersonnel we want to update
     *   }
     * })
     */
    upsert<T extends KeyPersonnelUpsertArgs>(args: SelectSubset<T, KeyPersonnelUpsertArgs<ExtArgs>>): Prisma__KeyPersonnelClient<$Result.GetResult<Prisma.$KeyPersonnelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of KeyPersonnels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyPersonnelCountArgs} args - Arguments to filter KeyPersonnels to count.
     * @example
     * // Count the number of KeyPersonnels
     * const count = await prisma.keyPersonnel.count({
     *   where: {
     *     // ... the filter for the KeyPersonnels we want to count
     *   }
     * })
    **/
    count<T extends KeyPersonnelCountArgs>(
      args?: Subset<T, KeyPersonnelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeyPersonnelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KeyPersonnel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyPersonnelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KeyPersonnelAggregateArgs>(args: Subset<T, KeyPersonnelAggregateArgs>): Prisma.PrismaPromise<GetKeyPersonnelAggregateType<T>>

    /**
     * Group by KeyPersonnel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyPersonnelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KeyPersonnelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KeyPersonnelGroupByArgs['orderBy'] }
        : { orderBy?: KeyPersonnelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KeyPersonnelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeyPersonnelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KeyPersonnel model
   */
  readonly fields: KeyPersonnelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KeyPersonnel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KeyPersonnelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KeyPersonnel model
   */ 
  interface KeyPersonnelFieldRefs {
    readonly id: FieldRef<"KeyPersonnel", 'String'>
    readonly name: FieldRef<"KeyPersonnel", 'String'>
    readonly role: FieldRef<"KeyPersonnel", 'String'>
    readonly company: FieldRef<"KeyPersonnel", 'String'>
    readonly email: FieldRef<"KeyPersonnel", 'String'>
    readonly phone: FieldRef<"KeyPersonnel", 'String'>
    readonly projectId: FieldRef<"KeyPersonnel", 'String'>
  }
    

  // Custom InputTypes
  /**
   * KeyPersonnel findUnique
   */
  export type KeyPersonnelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyPersonnel
     */
    select?: KeyPersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyPersonnelInclude<ExtArgs> | null
    /**
     * Filter, which KeyPersonnel to fetch.
     */
    where: KeyPersonnelWhereUniqueInput
  }

  /**
   * KeyPersonnel findUniqueOrThrow
   */
  export type KeyPersonnelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyPersonnel
     */
    select?: KeyPersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyPersonnelInclude<ExtArgs> | null
    /**
     * Filter, which KeyPersonnel to fetch.
     */
    where: KeyPersonnelWhereUniqueInput
  }

  /**
   * KeyPersonnel findFirst
   */
  export type KeyPersonnelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyPersonnel
     */
    select?: KeyPersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyPersonnelInclude<ExtArgs> | null
    /**
     * Filter, which KeyPersonnel to fetch.
     */
    where?: KeyPersonnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyPersonnels to fetch.
     */
    orderBy?: KeyPersonnelOrderByWithRelationInput | KeyPersonnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeyPersonnels.
     */
    cursor?: KeyPersonnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyPersonnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyPersonnels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeyPersonnels.
     */
    distinct?: KeyPersonnelScalarFieldEnum | KeyPersonnelScalarFieldEnum[]
  }

  /**
   * KeyPersonnel findFirstOrThrow
   */
  export type KeyPersonnelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyPersonnel
     */
    select?: KeyPersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyPersonnelInclude<ExtArgs> | null
    /**
     * Filter, which KeyPersonnel to fetch.
     */
    where?: KeyPersonnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyPersonnels to fetch.
     */
    orderBy?: KeyPersonnelOrderByWithRelationInput | KeyPersonnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeyPersonnels.
     */
    cursor?: KeyPersonnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyPersonnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyPersonnels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeyPersonnels.
     */
    distinct?: KeyPersonnelScalarFieldEnum | KeyPersonnelScalarFieldEnum[]
  }

  /**
   * KeyPersonnel findMany
   */
  export type KeyPersonnelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyPersonnel
     */
    select?: KeyPersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyPersonnelInclude<ExtArgs> | null
    /**
     * Filter, which KeyPersonnels to fetch.
     */
    where?: KeyPersonnelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyPersonnels to fetch.
     */
    orderBy?: KeyPersonnelOrderByWithRelationInput | KeyPersonnelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KeyPersonnels.
     */
    cursor?: KeyPersonnelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyPersonnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyPersonnels.
     */
    skip?: number
    distinct?: KeyPersonnelScalarFieldEnum | KeyPersonnelScalarFieldEnum[]
  }

  /**
   * KeyPersonnel create
   */
  export type KeyPersonnelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyPersonnel
     */
    select?: KeyPersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyPersonnelInclude<ExtArgs> | null
    /**
     * The data needed to create a KeyPersonnel.
     */
    data: XOR<KeyPersonnelCreateInput, KeyPersonnelUncheckedCreateInput>
  }

  /**
   * KeyPersonnel createMany
   */
  export type KeyPersonnelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KeyPersonnels.
     */
    data: KeyPersonnelCreateManyInput | KeyPersonnelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KeyPersonnel update
   */
  export type KeyPersonnelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyPersonnel
     */
    select?: KeyPersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyPersonnelInclude<ExtArgs> | null
    /**
     * The data needed to update a KeyPersonnel.
     */
    data: XOR<KeyPersonnelUpdateInput, KeyPersonnelUncheckedUpdateInput>
    /**
     * Choose, which KeyPersonnel to update.
     */
    where: KeyPersonnelWhereUniqueInput
  }

  /**
   * KeyPersonnel updateMany
   */
  export type KeyPersonnelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KeyPersonnels.
     */
    data: XOR<KeyPersonnelUpdateManyMutationInput, KeyPersonnelUncheckedUpdateManyInput>
    /**
     * Filter which KeyPersonnels to update
     */
    where?: KeyPersonnelWhereInput
  }

  /**
   * KeyPersonnel upsert
   */
  export type KeyPersonnelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyPersonnel
     */
    select?: KeyPersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyPersonnelInclude<ExtArgs> | null
    /**
     * The filter to search for the KeyPersonnel to update in case it exists.
     */
    where: KeyPersonnelWhereUniqueInput
    /**
     * In case the KeyPersonnel found by the `where` argument doesn't exist, create a new KeyPersonnel with this data.
     */
    create: XOR<KeyPersonnelCreateInput, KeyPersonnelUncheckedCreateInput>
    /**
     * In case the KeyPersonnel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KeyPersonnelUpdateInput, KeyPersonnelUncheckedUpdateInput>
  }

  /**
   * KeyPersonnel delete
   */
  export type KeyPersonnelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyPersonnel
     */
    select?: KeyPersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyPersonnelInclude<ExtArgs> | null
    /**
     * Filter which KeyPersonnel to delete.
     */
    where: KeyPersonnelWhereUniqueInput
  }

  /**
   * KeyPersonnel deleteMany
   */
  export type KeyPersonnelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KeyPersonnels to delete
     */
    where?: KeyPersonnelWhereInput
  }

  /**
   * KeyPersonnel without action
   */
  export type KeyPersonnelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyPersonnel
     */
    select?: KeyPersonnelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeyPersonnelInclude<ExtArgs> | null
  }


  /**
   * Model Communication
   */

  export type AggregateCommunication = {
    _count: CommunicationCountAggregateOutputType | null
    _min: CommunicationMinAggregateOutputType | null
    _max: CommunicationMaxAggregateOutputType | null
  }

  export type CommunicationMinAggregateOutputType = {
    id: string | null
    radicado: string | null
    subject: string | null
    description: string | null
    senderEntity: string | null
    senderName: string | null
    senderTitle: string | null
    recipientEntity: string | null
    recipientName: string | null
    recipientTitle: string | null
    signerName: string | null
    sentDate: Date | null
    dueDate: Date | null
    deliveryMethod: $Enums.DeliveryMethod | null
    notes: string | null
    status: $Enums.CommunicationStatus | null
    uploaderId: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunicationMaxAggregateOutputType = {
    id: string | null
    radicado: string | null
    subject: string | null
    description: string | null
    senderEntity: string | null
    senderName: string | null
    senderTitle: string | null
    recipientEntity: string | null
    recipientName: string | null
    recipientTitle: string | null
    signerName: string | null
    sentDate: Date | null
    dueDate: Date | null
    deliveryMethod: $Enums.DeliveryMethod | null
    notes: string | null
    status: $Enums.CommunicationStatus | null
    uploaderId: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunicationCountAggregateOutputType = {
    id: number
    radicado: number
    subject: number
    description: number
    senderEntity: number
    senderName: number
    senderTitle: number
    recipientEntity: number
    recipientName: number
    recipientTitle: number
    signerName: number
    sentDate: number
    dueDate: number
    deliveryMethod: number
    notes: number
    status: number
    uploaderId: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommunicationMinAggregateInputType = {
    id?: true
    radicado?: true
    subject?: true
    description?: true
    senderEntity?: true
    senderName?: true
    senderTitle?: true
    recipientEntity?: true
    recipientName?: true
    recipientTitle?: true
    signerName?: true
    sentDate?: true
    dueDate?: true
    deliveryMethod?: true
    notes?: true
    status?: true
    uploaderId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunicationMaxAggregateInputType = {
    id?: true
    radicado?: true
    subject?: true
    description?: true
    senderEntity?: true
    senderName?: true
    senderTitle?: true
    recipientEntity?: true
    recipientName?: true
    recipientTitle?: true
    signerName?: true
    sentDate?: true
    dueDate?: true
    deliveryMethod?: true
    notes?: true
    status?: true
    uploaderId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunicationCountAggregateInputType = {
    id?: true
    radicado?: true
    subject?: true
    description?: true
    senderEntity?: true
    senderName?: true
    senderTitle?: true
    recipientEntity?: true
    recipientName?: true
    recipientTitle?: true
    signerName?: true
    sentDate?: true
    dueDate?: true
    deliveryMethod?: true
    notes?: true
    status?: true
    uploaderId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommunicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Communication to aggregate.
     */
    where?: CommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communications to fetch.
     */
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Communications
    **/
    _count?: true | CommunicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunicationMaxAggregateInputType
  }

  export type GetCommunicationAggregateType<T extends CommunicationAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunication[P]>
      : GetScalarType<T[P], AggregateCommunication[P]>
  }




  export type CommunicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunicationWhereInput
    orderBy?: CommunicationOrderByWithAggregationInput | CommunicationOrderByWithAggregationInput[]
    by: CommunicationScalarFieldEnum[] | CommunicationScalarFieldEnum
    having?: CommunicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunicationCountAggregateInputType | true
    _min?: CommunicationMinAggregateInputType
    _max?: CommunicationMaxAggregateInputType
  }

  export type CommunicationGroupByOutputType = {
    id: string
    radicado: string
    subject: string
    description: string
    senderEntity: string
    senderName: string
    senderTitle: string
    recipientEntity: string
    recipientName: string
    recipientTitle: string
    signerName: string
    sentDate: Date
    dueDate: Date | null
    deliveryMethod: $Enums.DeliveryMethod
    notes: string | null
    status: $Enums.CommunicationStatus
    uploaderId: string
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CommunicationCountAggregateOutputType | null
    _min: CommunicationMinAggregateOutputType | null
    _max: CommunicationMaxAggregateOutputType | null
  }

  type GetCommunicationGroupByPayload<T extends CommunicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunicationGroupByOutputType[P]>
            : GetScalarType<T[P], CommunicationGroupByOutputType[P]>
        }
      >
    >


  export type CommunicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    radicado?: boolean
    subject?: boolean
    description?: boolean
    senderEntity?: boolean
    senderName?: boolean
    senderTitle?: boolean
    recipientEntity?: boolean
    recipientName?: boolean
    recipientTitle?: boolean
    signerName?: boolean
    sentDate?: boolean
    dueDate?: boolean
    deliveryMethod?: boolean
    notes?: boolean
    status?: boolean
    uploaderId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Communication$parentArgs<ExtArgs>
    replies?: boolean | Communication$repliesArgs<ExtArgs>
    statusHistory?: boolean | Communication$statusHistoryArgs<ExtArgs>
    attachments?: boolean | Communication$attachmentsArgs<ExtArgs>
    _count?: boolean | CommunicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communication"]>


  export type CommunicationSelectScalar = {
    id?: boolean
    radicado?: boolean
    subject?: boolean
    description?: boolean
    senderEntity?: boolean
    senderName?: boolean
    senderTitle?: boolean
    recipientEntity?: boolean
    recipientName?: boolean
    recipientTitle?: boolean
    signerName?: boolean
    sentDate?: boolean
    dueDate?: boolean
    deliveryMethod?: boolean
    notes?: boolean
    status?: boolean
    uploaderId?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommunicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Communication$parentArgs<ExtArgs>
    replies?: boolean | Communication$repliesArgs<ExtArgs>
    statusHistory?: boolean | Communication$statusHistoryArgs<ExtArgs>
    attachments?: boolean | Communication$attachmentsArgs<ExtArgs>
    _count?: boolean | CommunicationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CommunicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Communication"
    objects: {
      uploader: Prisma.$UserPayload<ExtArgs>
      parent: Prisma.$CommunicationPayload<ExtArgs> | null
      replies: Prisma.$CommunicationPayload<ExtArgs>[]
      statusHistory: Prisma.$CommunicationStatusHistoryPayload<ExtArgs>[]
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      radicado: string
      subject: string
      description: string
      senderEntity: string
      senderName: string
      senderTitle: string
      recipientEntity: string
      recipientName: string
      recipientTitle: string
      signerName: string
      sentDate: Date
      dueDate: Date | null
      deliveryMethod: $Enums.DeliveryMethod
      notes: string | null
      status: $Enums.CommunicationStatus
      uploaderId: string
      parentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["communication"]>
    composites: {}
  }

  type CommunicationGetPayload<S extends boolean | null | undefined | CommunicationDefaultArgs> = $Result.GetResult<Prisma.$CommunicationPayload, S>

  type CommunicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommunicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommunicationCountAggregateInputType | true
    }

  export interface CommunicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Communication'], meta: { name: 'Communication' } }
    /**
     * Find zero or one Communication that matches the filter.
     * @param {CommunicationFindUniqueArgs} args - Arguments to find a Communication
     * @example
     * // Get one Communication
     * const communication = await prisma.communication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunicationFindUniqueArgs>(args: SelectSubset<T, CommunicationFindUniqueArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Communication that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommunicationFindUniqueOrThrowArgs} args - Arguments to find a Communication
     * @example
     * // Get one Communication
     * const communication = await prisma.communication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunicationFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Communication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationFindFirstArgs} args - Arguments to find a Communication
     * @example
     * // Get one Communication
     * const communication = await prisma.communication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunicationFindFirstArgs>(args?: SelectSubset<T, CommunicationFindFirstArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Communication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationFindFirstOrThrowArgs} args - Arguments to find a Communication
     * @example
     * // Get one Communication
     * const communication = await prisma.communication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunicationFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Communications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Communications
     * const communications = await prisma.communication.findMany()
     * 
     * // Get first 10 Communications
     * const communications = await prisma.communication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communicationWithIdOnly = await prisma.communication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunicationFindManyArgs>(args?: SelectSubset<T, CommunicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Communication.
     * @param {CommunicationCreateArgs} args - Arguments to create a Communication.
     * @example
     * // Create one Communication
     * const Communication = await prisma.communication.create({
     *   data: {
     *     // ... data to create a Communication
     *   }
     * })
     * 
     */
    create<T extends CommunicationCreateArgs>(args: SelectSubset<T, CommunicationCreateArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Communications.
     * @param {CommunicationCreateManyArgs} args - Arguments to create many Communications.
     * @example
     * // Create many Communications
     * const communication = await prisma.communication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunicationCreateManyArgs>(args?: SelectSubset<T, CommunicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Communication.
     * @param {CommunicationDeleteArgs} args - Arguments to delete one Communication.
     * @example
     * // Delete one Communication
     * const Communication = await prisma.communication.delete({
     *   where: {
     *     // ... filter to delete one Communication
     *   }
     * })
     * 
     */
    delete<T extends CommunicationDeleteArgs>(args: SelectSubset<T, CommunicationDeleteArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Communication.
     * @param {CommunicationUpdateArgs} args - Arguments to update one Communication.
     * @example
     * // Update one Communication
     * const communication = await prisma.communication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunicationUpdateArgs>(args: SelectSubset<T, CommunicationUpdateArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Communications.
     * @param {CommunicationDeleteManyArgs} args - Arguments to filter Communications to delete.
     * @example
     * // Delete a few Communications
     * const { count } = await prisma.communication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunicationDeleteManyArgs>(args?: SelectSubset<T, CommunicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Communications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Communications
     * const communication = await prisma.communication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunicationUpdateManyArgs>(args: SelectSubset<T, CommunicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Communication.
     * @param {CommunicationUpsertArgs} args - Arguments to update or create a Communication.
     * @example
     * // Update or create a Communication
     * const communication = await prisma.communication.upsert({
     *   create: {
     *     // ... data to create a Communication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Communication we want to update
     *   }
     * })
     */
    upsert<T extends CommunicationUpsertArgs>(args: SelectSubset<T, CommunicationUpsertArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Communications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationCountArgs} args - Arguments to filter Communications to count.
     * @example
     * // Count the number of Communications
     * const count = await prisma.communication.count({
     *   where: {
     *     // ... the filter for the Communications we want to count
     *   }
     * })
    **/
    count<T extends CommunicationCountArgs>(
      args?: Subset<T, CommunicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Communication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunicationAggregateArgs>(args: Subset<T, CommunicationAggregateArgs>): Prisma.PrismaPromise<GetCommunicationAggregateType<T>>

    /**
     * Group by Communication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunicationGroupByArgs['orderBy'] }
        : { orderBy?: CommunicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Communication model
   */
  readonly fields: CommunicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Communication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parent<T extends Communication$parentArgs<ExtArgs> = {}>(args?: Subset<T, Communication$parentArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    replies<T extends Communication$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Communication$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findMany"> | Null>
    statusHistory<T extends Communication$statusHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Communication$statusHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationStatusHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    attachments<T extends Communication$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Communication$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Communication model
   */ 
  interface CommunicationFieldRefs {
    readonly id: FieldRef<"Communication", 'String'>
    readonly radicado: FieldRef<"Communication", 'String'>
    readonly subject: FieldRef<"Communication", 'String'>
    readonly description: FieldRef<"Communication", 'String'>
    readonly senderEntity: FieldRef<"Communication", 'String'>
    readonly senderName: FieldRef<"Communication", 'String'>
    readonly senderTitle: FieldRef<"Communication", 'String'>
    readonly recipientEntity: FieldRef<"Communication", 'String'>
    readonly recipientName: FieldRef<"Communication", 'String'>
    readonly recipientTitle: FieldRef<"Communication", 'String'>
    readonly signerName: FieldRef<"Communication", 'String'>
    readonly sentDate: FieldRef<"Communication", 'DateTime'>
    readonly dueDate: FieldRef<"Communication", 'DateTime'>
    readonly deliveryMethod: FieldRef<"Communication", 'DeliveryMethod'>
    readonly notes: FieldRef<"Communication", 'String'>
    readonly status: FieldRef<"Communication", 'CommunicationStatus'>
    readonly uploaderId: FieldRef<"Communication", 'String'>
    readonly parentId: FieldRef<"Communication", 'String'>
    readonly createdAt: FieldRef<"Communication", 'DateTime'>
    readonly updatedAt: FieldRef<"Communication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Communication findUnique
   */
  export type CommunicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter, which Communication to fetch.
     */
    where: CommunicationWhereUniqueInput
  }

  /**
   * Communication findUniqueOrThrow
   */
  export type CommunicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter, which Communication to fetch.
     */
    where: CommunicationWhereUniqueInput
  }

  /**
   * Communication findFirst
   */
  export type CommunicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter, which Communication to fetch.
     */
    where?: CommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communications to fetch.
     */
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communications.
     */
    cursor?: CommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communications.
     */
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * Communication findFirstOrThrow
   */
  export type CommunicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter, which Communication to fetch.
     */
    where?: CommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communications to fetch.
     */
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communications.
     */
    cursor?: CommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communications.
     */
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * Communication findMany
   */
  export type CommunicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter, which Communications to fetch.
     */
    where?: CommunicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communications to fetch.
     */
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Communications.
     */
    cursor?: CommunicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communications.
     */
    skip?: number
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * Communication create
   */
  export type CommunicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Communication.
     */
    data: XOR<CommunicationCreateInput, CommunicationUncheckedCreateInput>
  }

  /**
   * Communication createMany
   */
  export type CommunicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Communications.
     */
    data: CommunicationCreateManyInput | CommunicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Communication update
   */
  export type CommunicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Communication.
     */
    data: XOR<CommunicationUpdateInput, CommunicationUncheckedUpdateInput>
    /**
     * Choose, which Communication to update.
     */
    where: CommunicationWhereUniqueInput
  }

  /**
   * Communication updateMany
   */
  export type CommunicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Communications.
     */
    data: XOR<CommunicationUpdateManyMutationInput, CommunicationUncheckedUpdateManyInput>
    /**
     * Filter which Communications to update
     */
    where?: CommunicationWhereInput
  }

  /**
   * Communication upsert
   */
  export type CommunicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Communication to update in case it exists.
     */
    where: CommunicationWhereUniqueInput
    /**
     * In case the Communication found by the `where` argument doesn't exist, create a new Communication with this data.
     */
    create: XOR<CommunicationCreateInput, CommunicationUncheckedCreateInput>
    /**
     * In case the Communication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunicationUpdateInput, CommunicationUncheckedUpdateInput>
  }

  /**
   * Communication delete
   */
  export type CommunicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    /**
     * Filter which Communication to delete.
     */
    where: CommunicationWhereUniqueInput
  }

  /**
   * Communication deleteMany
   */
  export type CommunicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Communications to delete
     */
    where?: CommunicationWhereInput
  }

  /**
   * Communication.parent
   */
  export type Communication$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    where?: CommunicationWhereInput
  }

  /**
   * Communication.replies
   */
  export type Communication$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    where?: CommunicationWhereInput
    orderBy?: CommunicationOrderByWithRelationInput | CommunicationOrderByWithRelationInput[]
    cursor?: CommunicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunicationScalarFieldEnum | CommunicationScalarFieldEnum[]
  }

  /**
   * Communication.statusHistory
   */
  export type Communication$statusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationStatusHistory
     */
    select?: CommunicationStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationStatusHistoryInclude<ExtArgs> | null
    where?: CommunicationStatusHistoryWhereInput
    orderBy?: CommunicationStatusHistoryOrderByWithRelationInput | CommunicationStatusHistoryOrderByWithRelationInput[]
    cursor?: CommunicationStatusHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunicationStatusHistoryScalarFieldEnum | CommunicationStatusHistoryScalarFieldEnum[]
  }

  /**
   * Communication.attachments
   */
  export type Communication$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Communication without action
   */
  export type CommunicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
  }


  /**
   * Model CommunicationStatusHistory
   */

  export type AggregateCommunicationStatusHistory = {
    _count: CommunicationStatusHistoryCountAggregateOutputType | null
    _min: CommunicationStatusHistoryMinAggregateOutputType | null
    _max: CommunicationStatusHistoryMaxAggregateOutputType | null
  }

  export type CommunicationStatusHistoryMinAggregateOutputType = {
    id: string | null
    status: string | null
    timestamp: Date | null
    communicationId: string | null
    userId: string | null
  }

  export type CommunicationStatusHistoryMaxAggregateOutputType = {
    id: string | null
    status: string | null
    timestamp: Date | null
    communicationId: string | null
    userId: string | null
  }

  export type CommunicationStatusHistoryCountAggregateOutputType = {
    id: number
    status: number
    timestamp: number
    communicationId: number
    userId: number
    _all: number
  }


  export type CommunicationStatusHistoryMinAggregateInputType = {
    id?: true
    status?: true
    timestamp?: true
    communicationId?: true
    userId?: true
  }

  export type CommunicationStatusHistoryMaxAggregateInputType = {
    id?: true
    status?: true
    timestamp?: true
    communicationId?: true
    userId?: true
  }

  export type CommunicationStatusHistoryCountAggregateInputType = {
    id?: true
    status?: true
    timestamp?: true
    communicationId?: true
    userId?: true
    _all?: true
  }

  export type CommunicationStatusHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunicationStatusHistory to aggregate.
     */
    where?: CommunicationStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunicationStatusHistories to fetch.
     */
    orderBy?: CommunicationStatusHistoryOrderByWithRelationInput | CommunicationStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunicationStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunicationStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunicationStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunicationStatusHistories
    **/
    _count?: true | CommunicationStatusHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunicationStatusHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunicationStatusHistoryMaxAggregateInputType
  }

  export type GetCommunicationStatusHistoryAggregateType<T extends CommunicationStatusHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunicationStatusHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunicationStatusHistory[P]>
      : GetScalarType<T[P], AggregateCommunicationStatusHistory[P]>
  }




  export type CommunicationStatusHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunicationStatusHistoryWhereInput
    orderBy?: CommunicationStatusHistoryOrderByWithAggregationInput | CommunicationStatusHistoryOrderByWithAggregationInput[]
    by: CommunicationStatusHistoryScalarFieldEnum[] | CommunicationStatusHistoryScalarFieldEnum
    having?: CommunicationStatusHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunicationStatusHistoryCountAggregateInputType | true
    _min?: CommunicationStatusHistoryMinAggregateInputType
    _max?: CommunicationStatusHistoryMaxAggregateInputType
  }

  export type CommunicationStatusHistoryGroupByOutputType = {
    id: string
    status: string
    timestamp: Date
    communicationId: string
    userId: string
    _count: CommunicationStatusHistoryCountAggregateOutputType | null
    _min: CommunicationStatusHistoryMinAggregateOutputType | null
    _max: CommunicationStatusHistoryMaxAggregateOutputType | null
  }

  type GetCommunicationStatusHistoryGroupByPayload<T extends CommunicationStatusHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunicationStatusHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunicationStatusHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunicationStatusHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], CommunicationStatusHistoryGroupByOutputType[P]>
        }
      >
    >


  export type CommunicationStatusHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    timestamp?: boolean
    communicationId?: boolean
    userId?: boolean
    communication?: boolean | CommunicationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communicationStatusHistory"]>


  export type CommunicationStatusHistorySelectScalar = {
    id?: boolean
    status?: boolean
    timestamp?: boolean
    communicationId?: boolean
    userId?: boolean
  }

  export type CommunicationStatusHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    communication?: boolean | CommunicationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommunicationStatusHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunicationStatusHistory"
    objects: {
      communication: Prisma.$CommunicationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      timestamp: Date
      communicationId: string
      userId: string
    }, ExtArgs["result"]["communicationStatusHistory"]>
    composites: {}
  }

  type CommunicationStatusHistoryGetPayload<S extends boolean | null | undefined | CommunicationStatusHistoryDefaultArgs> = $Result.GetResult<Prisma.$CommunicationStatusHistoryPayload, S>

  type CommunicationStatusHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommunicationStatusHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommunicationStatusHistoryCountAggregateInputType | true
    }

  export interface CommunicationStatusHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunicationStatusHistory'], meta: { name: 'CommunicationStatusHistory' } }
    /**
     * Find zero or one CommunicationStatusHistory that matches the filter.
     * @param {CommunicationStatusHistoryFindUniqueArgs} args - Arguments to find a CommunicationStatusHistory
     * @example
     * // Get one CommunicationStatusHistory
     * const communicationStatusHistory = await prisma.communicationStatusHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunicationStatusHistoryFindUniqueArgs>(args: SelectSubset<T, CommunicationStatusHistoryFindUniqueArgs<ExtArgs>>): Prisma__CommunicationStatusHistoryClient<$Result.GetResult<Prisma.$CommunicationStatusHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CommunicationStatusHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommunicationStatusHistoryFindUniqueOrThrowArgs} args - Arguments to find a CommunicationStatusHistory
     * @example
     * // Get one CommunicationStatusHistory
     * const communicationStatusHistory = await prisma.communicationStatusHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunicationStatusHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunicationStatusHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunicationStatusHistoryClient<$Result.GetResult<Prisma.$CommunicationStatusHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CommunicationStatusHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationStatusHistoryFindFirstArgs} args - Arguments to find a CommunicationStatusHistory
     * @example
     * // Get one CommunicationStatusHistory
     * const communicationStatusHistory = await prisma.communicationStatusHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunicationStatusHistoryFindFirstArgs>(args?: SelectSubset<T, CommunicationStatusHistoryFindFirstArgs<ExtArgs>>): Prisma__CommunicationStatusHistoryClient<$Result.GetResult<Prisma.$CommunicationStatusHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CommunicationStatusHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationStatusHistoryFindFirstOrThrowArgs} args - Arguments to find a CommunicationStatusHistory
     * @example
     * // Get one CommunicationStatusHistory
     * const communicationStatusHistory = await prisma.communicationStatusHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunicationStatusHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunicationStatusHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunicationStatusHistoryClient<$Result.GetResult<Prisma.$CommunicationStatusHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CommunicationStatusHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationStatusHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunicationStatusHistories
     * const communicationStatusHistories = await prisma.communicationStatusHistory.findMany()
     * 
     * // Get first 10 CommunicationStatusHistories
     * const communicationStatusHistories = await prisma.communicationStatusHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communicationStatusHistoryWithIdOnly = await prisma.communicationStatusHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunicationStatusHistoryFindManyArgs>(args?: SelectSubset<T, CommunicationStatusHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunicationStatusHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CommunicationStatusHistory.
     * @param {CommunicationStatusHistoryCreateArgs} args - Arguments to create a CommunicationStatusHistory.
     * @example
     * // Create one CommunicationStatusHistory
     * const CommunicationStatusHistory = await prisma.communicationStatusHistory.create({
     *   data: {
     *     // ... data to create a CommunicationStatusHistory
     *   }
     * })
     * 
     */
    create<T extends CommunicationStatusHistoryCreateArgs>(args: SelectSubset<T, CommunicationStatusHistoryCreateArgs<ExtArgs>>): Prisma__CommunicationStatusHistoryClient<$Result.GetResult<Prisma.$CommunicationStatusHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CommunicationStatusHistories.
     * @param {CommunicationStatusHistoryCreateManyArgs} args - Arguments to create many CommunicationStatusHistories.
     * @example
     * // Create many CommunicationStatusHistories
     * const communicationStatusHistory = await prisma.communicationStatusHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunicationStatusHistoryCreateManyArgs>(args?: SelectSubset<T, CommunicationStatusHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CommunicationStatusHistory.
     * @param {CommunicationStatusHistoryDeleteArgs} args - Arguments to delete one CommunicationStatusHistory.
     * @example
     * // Delete one CommunicationStatusHistory
     * const CommunicationStatusHistory = await prisma.communicationStatusHistory.delete({
     *   where: {
     *     // ... filter to delete one CommunicationStatusHistory
     *   }
     * })
     * 
     */
    delete<T extends CommunicationStatusHistoryDeleteArgs>(args: SelectSubset<T, CommunicationStatusHistoryDeleteArgs<ExtArgs>>): Prisma__CommunicationStatusHistoryClient<$Result.GetResult<Prisma.$CommunicationStatusHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CommunicationStatusHistory.
     * @param {CommunicationStatusHistoryUpdateArgs} args - Arguments to update one CommunicationStatusHistory.
     * @example
     * // Update one CommunicationStatusHistory
     * const communicationStatusHistory = await prisma.communicationStatusHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunicationStatusHistoryUpdateArgs>(args: SelectSubset<T, CommunicationStatusHistoryUpdateArgs<ExtArgs>>): Prisma__CommunicationStatusHistoryClient<$Result.GetResult<Prisma.$CommunicationStatusHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CommunicationStatusHistories.
     * @param {CommunicationStatusHistoryDeleteManyArgs} args - Arguments to filter CommunicationStatusHistories to delete.
     * @example
     * // Delete a few CommunicationStatusHistories
     * const { count } = await prisma.communicationStatusHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunicationStatusHistoryDeleteManyArgs>(args?: SelectSubset<T, CommunicationStatusHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunicationStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationStatusHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunicationStatusHistories
     * const communicationStatusHistory = await prisma.communicationStatusHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunicationStatusHistoryUpdateManyArgs>(args: SelectSubset<T, CommunicationStatusHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommunicationStatusHistory.
     * @param {CommunicationStatusHistoryUpsertArgs} args - Arguments to update or create a CommunicationStatusHistory.
     * @example
     * // Update or create a CommunicationStatusHistory
     * const communicationStatusHistory = await prisma.communicationStatusHistory.upsert({
     *   create: {
     *     // ... data to create a CommunicationStatusHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunicationStatusHistory we want to update
     *   }
     * })
     */
    upsert<T extends CommunicationStatusHistoryUpsertArgs>(args: SelectSubset<T, CommunicationStatusHistoryUpsertArgs<ExtArgs>>): Prisma__CommunicationStatusHistoryClient<$Result.GetResult<Prisma.$CommunicationStatusHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CommunicationStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationStatusHistoryCountArgs} args - Arguments to filter CommunicationStatusHistories to count.
     * @example
     * // Count the number of CommunicationStatusHistories
     * const count = await prisma.communicationStatusHistory.count({
     *   where: {
     *     // ... the filter for the CommunicationStatusHistories we want to count
     *   }
     * })
    **/
    count<T extends CommunicationStatusHistoryCountArgs>(
      args?: Subset<T, CommunicationStatusHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunicationStatusHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunicationStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationStatusHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunicationStatusHistoryAggregateArgs>(args: Subset<T, CommunicationStatusHistoryAggregateArgs>): Prisma.PrismaPromise<GetCommunicationStatusHistoryAggregateType<T>>

    /**
     * Group by CommunicationStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunicationStatusHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunicationStatusHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunicationStatusHistoryGroupByArgs['orderBy'] }
        : { orderBy?: CommunicationStatusHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunicationStatusHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunicationStatusHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunicationStatusHistory model
   */
  readonly fields: CommunicationStatusHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunicationStatusHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunicationStatusHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    communication<T extends CommunicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunicationDefaultArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommunicationStatusHistory model
   */ 
  interface CommunicationStatusHistoryFieldRefs {
    readonly id: FieldRef<"CommunicationStatusHistory", 'String'>
    readonly status: FieldRef<"CommunicationStatusHistory", 'String'>
    readonly timestamp: FieldRef<"CommunicationStatusHistory", 'DateTime'>
    readonly communicationId: FieldRef<"CommunicationStatusHistory", 'String'>
    readonly userId: FieldRef<"CommunicationStatusHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CommunicationStatusHistory findUnique
   */
  export type CommunicationStatusHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationStatusHistory
     */
    select?: CommunicationStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CommunicationStatusHistory to fetch.
     */
    where: CommunicationStatusHistoryWhereUniqueInput
  }

  /**
   * CommunicationStatusHistory findUniqueOrThrow
   */
  export type CommunicationStatusHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationStatusHistory
     */
    select?: CommunicationStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CommunicationStatusHistory to fetch.
     */
    where: CommunicationStatusHistoryWhereUniqueInput
  }

  /**
   * CommunicationStatusHistory findFirst
   */
  export type CommunicationStatusHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationStatusHistory
     */
    select?: CommunicationStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CommunicationStatusHistory to fetch.
     */
    where?: CommunicationStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunicationStatusHistories to fetch.
     */
    orderBy?: CommunicationStatusHistoryOrderByWithRelationInput | CommunicationStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunicationStatusHistories.
     */
    cursor?: CommunicationStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunicationStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunicationStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunicationStatusHistories.
     */
    distinct?: CommunicationStatusHistoryScalarFieldEnum | CommunicationStatusHistoryScalarFieldEnum[]
  }

  /**
   * CommunicationStatusHistory findFirstOrThrow
   */
  export type CommunicationStatusHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationStatusHistory
     */
    select?: CommunicationStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CommunicationStatusHistory to fetch.
     */
    where?: CommunicationStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunicationStatusHistories to fetch.
     */
    orderBy?: CommunicationStatusHistoryOrderByWithRelationInput | CommunicationStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunicationStatusHistories.
     */
    cursor?: CommunicationStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunicationStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunicationStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunicationStatusHistories.
     */
    distinct?: CommunicationStatusHistoryScalarFieldEnum | CommunicationStatusHistoryScalarFieldEnum[]
  }

  /**
   * CommunicationStatusHistory findMany
   */
  export type CommunicationStatusHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationStatusHistory
     */
    select?: CommunicationStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CommunicationStatusHistories to fetch.
     */
    where?: CommunicationStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunicationStatusHistories to fetch.
     */
    orderBy?: CommunicationStatusHistoryOrderByWithRelationInput | CommunicationStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunicationStatusHistories.
     */
    cursor?: CommunicationStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunicationStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunicationStatusHistories.
     */
    skip?: number
    distinct?: CommunicationStatusHistoryScalarFieldEnum | CommunicationStatusHistoryScalarFieldEnum[]
  }

  /**
   * CommunicationStatusHistory create
   */
  export type CommunicationStatusHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationStatusHistory
     */
    select?: CommunicationStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationStatusHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a CommunicationStatusHistory.
     */
    data: XOR<CommunicationStatusHistoryCreateInput, CommunicationStatusHistoryUncheckedCreateInput>
  }

  /**
   * CommunicationStatusHistory createMany
   */
  export type CommunicationStatusHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunicationStatusHistories.
     */
    data: CommunicationStatusHistoryCreateManyInput | CommunicationStatusHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommunicationStatusHistory update
   */
  export type CommunicationStatusHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationStatusHistory
     */
    select?: CommunicationStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationStatusHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a CommunicationStatusHistory.
     */
    data: XOR<CommunicationStatusHistoryUpdateInput, CommunicationStatusHistoryUncheckedUpdateInput>
    /**
     * Choose, which CommunicationStatusHistory to update.
     */
    where: CommunicationStatusHistoryWhereUniqueInput
  }

  /**
   * CommunicationStatusHistory updateMany
   */
  export type CommunicationStatusHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunicationStatusHistories.
     */
    data: XOR<CommunicationStatusHistoryUpdateManyMutationInput, CommunicationStatusHistoryUncheckedUpdateManyInput>
    /**
     * Filter which CommunicationStatusHistories to update
     */
    where?: CommunicationStatusHistoryWhereInput
  }

  /**
   * CommunicationStatusHistory upsert
   */
  export type CommunicationStatusHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationStatusHistory
     */
    select?: CommunicationStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationStatusHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the CommunicationStatusHistory to update in case it exists.
     */
    where: CommunicationStatusHistoryWhereUniqueInput
    /**
     * In case the CommunicationStatusHistory found by the `where` argument doesn't exist, create a new CommunicationStatusHistory with this data.
     */
    create: XOR<CommunicationStatusHistoryCreateInput, CommunicationStatusHistoryUncheckedCreateInput>
    /**
     * In case the CommunicationStatusHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunicationStatusHistoryUpdateInput, CommunicationStatusHistoryUncheckedUpdateInput>
  }

  /**
   * CommunicationStatusHistory delete
   */
  export type CommunicationStatusHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationStatusHistory
     */
    select?: CommunicationStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter which CommunicationStatusHistory to delete.
     */
    where: CommunicationStatusHistoryWhereUniqueInput
  }

  /**
   * CommunicationStatusHistory deleteMany
   */
  export type CommunicationStatusHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunicationStatusHistories to delete
     */
    where?: CommunicationStatusHistoryWhereInput
  }

  /**
   * CommunicationStatusHistory without action
   */
  export type CommunicationStatusHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunicationStatusHistory
     */
    select?: CommunicationStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationStatusHistoryInclude<ExtArgs> | null
  }


  /**
   * Model ContractModification
   */

  export type AggregateContractModification = {
    _count: ContractModificationCountAggregateOutputType | null
    _avg: ContractModificationAvgAggregateOutputType | null
    _sum: ContractModificationSumAggregateOutputType | null
    _min: ContractModificationMinAggregateOutputType | null
    _max: ContractModificationMaxAggregateOutputType | null
  }

  export type ContractModificationAvgAggregateOutputType = {
    value: number | null
    days: number | null
  }

  export type ContractModificationSumAggregateOutputType = {
    value: number | null
    days: number | null
  }

  export type ContractModificationMinAggregateOutputType = {
    id: string | null
    number: string | null
    type: $Enums.ModificationType | null
    date: Date | null
    value: number | null
    days: number | null
    justification: string | null
    attachmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractModificationMaxAggregateOutputType = {
    id: string | null
    number: string | null
    type: $Enums.ModificationType | null
    date: Date | null
    value: number | null
    days: number | null
    justification: string | null
    attachmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractModificationCountAggregateOutputType = {
    id: number
    number: number
    type: number
    date: number
    value: number
    days: number
    justification: number
    attachmentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContractModificationAvgAggregateInputType = {
    value?: true
    days?: true
  }

  export type ContractModificationSumAggregateInputType = {
    value?: true
    days?: true
  }

  export type ContractModificationMinAggregateInputType = {
    id?: true
    number?: true
    type?: true
    date?: true
    value?: true
    days?: true
    justification?: true
    attachmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractModificationMaxAggregateInputType = {
    id?: true
    number?: true
    type?: true
    date?: true
    value?: true
    days?: true
    justification?: true
    attachmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractModificationCountAggregateInputType = {
    id?: true
    number?: true
    type?: true
    date?: true
    value?: true
    days?: true
    justification?: true
    attachmentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContractModificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractModification to aggregate.
     */
    where?: ContractModificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractModifications to fetch.
     */
    orderBy?: ContractModificationOrderByWithRelationInput | ContractModificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractModificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractModifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractModifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContractModifications
    **/
    _count?: true | ContractModificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractModificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractModificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractModificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractModificationMaxAggregateInputType
  }

  export type GetContractModificationAggregateType<T extends ContractModificationAggregateArgs> = {
        [P in keyof T & keyof AggregateContractModification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContractModification[P]>
      : GetScalarType<T[P], AggregateContractModification[P]>
  }




  export type ContractModificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractModificationWhereInput
    orderBy?: ContractModificationOrderByWithAggregationInput | ContractModificationOrderByWithAggregationInput[]
    by: ContractModificationScalarFieldEnum[] | ContractModificationScalarFieldEnum
    having?: ContractModificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractModificationCountAggregateInputType | true
    _avg?: ContractModificationAvgAggregateInputType
    _sum?: ContractModificationSumAggregateInputType
    _min?: ContractModificationMinAggregateInputType
    _max?: ContractModificationMaxAggregateInputType
  }

  export type ContractModificationGroupByOutputType = {
    id: string
    number: string
    type: $Enums.ModificationType
    date: Date
    value: number | null
    days: number | null
    justification: string
    attachmentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ContractModificationCountAggregateOutputType | null
    _avg: ContractModificationAvgAggregateOutputType | null
    _sum: ContractModificationSumAggregateOutputType | null
    _min: ContractModificationMinAggregateOutputType | null
    _max: ContractModificationMaxAggregateOutputType | null
  }

  type GetContractModificationGroupByPayload<T extends ContractModificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractModificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractModificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractModificationGroupByOutputType[P]>
            : GetScalarType<T[P], ContractModificationGroupByOutputType[P]>
        }
      >
    >


  export type ContractModificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    type?: boolean
    date?: boolean
    value?: boolean
    days?: boolean
    justification?: boolean
    attachmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    attachment?: boolean | ContractModification$attachmentArgs<ExtArgs>
  }, ExtArgs["result"]["contractModification"]>


  export type ContractModificationSelectScalar = {
    id?: boolean
    number?: boolean
    type?: boolean
    date?: boolean
    value?: boolean
    days?: boolean
    justification?: boolean
    attachmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContractModificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachment?: boolean | ContractModification$attachmentArgs<ExtArgs>
  }

  export type $ContractModificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContractModification"
    objects: {
      attachment: Prisma.$AttachmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      number: string
      type: $Enums.ModificationType
      date: Date
      value: number | null
      days: number | null
      justification: string
      attachmentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contractModification"]>
    composites: {}
  }

  type ContractModificationGetPayload<S extends boolean | null | undefined | ContractModificationDefaultArgs> = $Result.GetResult<Prisma.$ContractModificationPayload, S>

  type ContractModificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContractModificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContractModificationCountAggregateInputType | true
    }

  export interface ContractModificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContractModification'], meta: { name: 'ContractModification' } }
    /**
     * Find zero or one ContractModification that matches the filter.
     * @param {ContractModificationFindUniqueArgs} args - Arguments to find a ContractModification
     * @example
     * // Get one ContractModification
     * const contractModification = await prisma.contractModification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractModificationFindUniqueArgs>(args: SelectSubset<T, ContractModificationFindUniqueArgs<ExtArgs>>): Prisma__ContractModificationClient<$Result.GetResult<Prisma.$ContractModificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContractModification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContractModificationFindUniqueOrThrowArgs} args - Arguments to find a ContractModification
     * @example
     * // Get one ContractModification
     * const contractModification = await prisma.contractModification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractModificationFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractModificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractModificationClient<$Result.GetResult<Prisma.$ContractModificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContractModification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractModificationFindFirstArgs} args - Arguments to find a ContractModification
     * @example
     * // Get one ContractModification
     * const contractModification = await prisma.contractModification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractModificationFindFirstArgs>(args?: SelectSubset<T, ContractModificationFindFirstArgs<ExtArgs>>): Prisma__ContractModificationClient<$Result.GetResult<Prisma.$ContractModificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContractModification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractModificationFindFirstOrThrowArgs} args - Arguments to find a ContractModification
     * @example
     * // Get one ContractModification
     * const contractModification = await prisma.contractModification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractModificationFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractModificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractModificationClient<$Result.GetResult<Prisma.$ContractModificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContractModifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractModificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContractModifications
     * const contractModifications = await prisma.contractModification.findMany()
     * 
     * // Get first 10 ContractModifications
     * const contractModifications = await prisma.contractModification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractModificationWithIdOnly = await prisma.contractModification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractModificationFindManyArgs>(args?: SelectSubset<T, ContractModificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractModificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContractModification.
     * @param {ContractModificationCreateArgs} args - Arguments to create a ContractModification.
     * @example
     * // Create one ContractModification
     * const ContractModification = await prisma.contractModification.create({
     *   data: {
     *     // ... data to create a ContractModification
     *   }
     * })
     * 
     */
    create<T extends ContractModificationCreateArgs>(args: SelectSubset<T, ContractModificationCreateArgs<ExtArgs>>): Prisma__ContractModificationClient<$Result.GetResult<Prisma.$ContractModificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContractModifications.
     * @param {ContractModificationCreateManyArgs} args - Arguments to create many ContractModifications.
     * @example
     * // Create many ContractModifications
     * const contractModification = await prisma.contractModification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractModificationCreateManyArgs>(args?: SelectSubset<T, ContractModificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContractModification.
     * @param {ContractModificationDeleteArgs} args - Arguments to delete one ContractModification.
     * @example
     * // Delete one ContractModification
     * const ContractModification = await prisma.contractModification.delete({
     *   where: {
     *     // ... filter to delete one ContractModification
     *   }
     * })
     * 
     */
    delete<T extends ContractModificationDeleteArgs>(args: SelectSubset<T, ContractModificationDeleteArgs<ExtArgs>>): Prisma__ContractModificationClient<$Result.GetResult<Prisma.$ContractModificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContractModification.
     * @param {ContractModificationUpdateArgs} args - Arguments to update one ContractModification.
     * @example
     * // Update one ContractModification
     * const contractModification = await prisma.contractModification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractModificationUpdateArgs>(args: SelectSubset<T, ContractModificationUpdateArgs<ExtArgs>>): Prisma__ContractModificationClient<$Result.GetResult<Prisma.$ContractModificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContractModifications.
     * @param {ContractModificationDeleteManyArgs} args - Arguments to filter ContractModifications to delete.
     * @example
     * // Delete a few ContractModifications
     * const { count } = await prisma.contractModification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractModificationDeleteManyArgs>(args?: SelectSubset<T, ContractModificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractModifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractModificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContractModifications
     * const contractModification = await prisma.contractModification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractModificationUpdateManyArgs>(args: SelectSubset<T, ContractModificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContractModification.
     * @param {ContractModificationUpsertArgs} args - Arguments to update or create a ContractModification.
     * @example
     * // Update or create a ContractModification
     * const contractModification = await prisma.contractModification.upsert({
     *   create: {
     *     // ... data to create a ContractModification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContractModification we want to update
     *   }
     * })
     */
    upsert<T extends ContractModificationUpsertArgs>(args: SelectSubset<T, ContractModificationUpsertArgs<ExtArgs>>): Prisma__ContractModificationClient<$Result.GetResult<Prisma.$ContractModificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContractModifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractModificationCountArgs} args - Arguments to filter ContractModifications to count.
     * @example
     * // Count the number of ContractModifications
     * const count = await prisma.contractModification.count({
     *   where: {
     *     // ... the filter for the ContractModifications we want to count
     *   }
     * })
    **/
    count<T extends ContractModificationCountArgs>(
      args?: Subset<T, ContractModificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractModificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContractModification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractModificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractModificationAggregateArgs>(args: Subset<T, ContractModificationAggregateArgs>): Prisma.PrismaPromise<GetContractModificationAggregateType<T>>

    /**
     * Group by ContractModification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractModificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractModificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractModificationGroupByArgs['orderBy'] }
        : { orderBy?: ContractModificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractModificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractModificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContractModification model
   */
  readonly fields: ContractModificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContractModification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractModificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attachment<T extends ContractModification$attachmentArgs<ExtArgs> = {}>(args?: Subset<T, ContractModification$attachmentArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContractModification model
   */ 
  interface ContractModificationFieldRefs {
    readonly id: FieldRef<"ContractModification", 'String'>
    readonly number: FieldRef<"ContractModification", 'String'>
    readonly type: FieldRef<"ContractModification", 'ModificationType'>
    readonly date: FieldRef<"ContractModification", 'DateTime'>
    readonly value: FieldRef<"ContractModification", 'Float'>
    readonly days: FieldRef<"ContractModification", 'Int'>
    readonly justification: FieldRef<"ContractModification", 'String'>
    readonly attachmentId: FieldRef<"ContractModification", 'String'>
    readonly createdAt: FieldRef<"ContractModification", 'DateTime'>
    readonly updatedAt: FieldRef<"ContractModification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContractModification findUnique
   */
  export type ContractModificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractModification
     */
    select?: ContractModificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractModificationInclude<ExtArgs> | null
    /**
     * Filter, which ContractModification to fetch.
     */
    where: ContractModificationWhereUniqueInput
  }

  /**
   * ContractModification findUniqueOrThrow
   */
  export type ContractModificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractModification
     */
    select?: ContractModificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractModificationInclude<ExtArgs> | null
    /**
     * Filter, which ContractModification to fetch.
     */
    where: ContractModificationWhereUniqueInput
  }

  /**
   * ContractModification findFirst
   */
  export type ContractModificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractModification
     */
    select?: ContractModificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractModificationInclude<ExtArgs> | null
    /**
     * Filter, which ContractModification to fetch.
     */
    where?: ContractModificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractModifications to fetch.
     */
    orderBy?: ContractModificationOrderByWithRelationInput | ContractModificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractModifications.
     */
    cursor?: ContractModificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractModifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractModifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractModifications.
     */
    distinct?: ContractModificationScalarFieldEnum | ContractModificationScalarFieldEnum[]
  }

  /**
   * ContractModification findFirstOrThrow
   */
  export type ContractModificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractModification
     */
    select?: ContractModificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractModificationInclude<ExtArgs> | null
    /**
     * Filter, which ContractModification to fetch.
     */
    where?: ContractModificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractModifications to fetch.
     */
    orderBy?: ContractModificationOrderByWithRelationInput | ContractModificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractModifications.
     */
    cursor?: ContractModificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractModifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractModifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractModifications.
     */
    distinct?: ContractModificationScalarFieldEnum | ContractModificationScalarFieldEnum[]
  }

  /**
   * ContractModification findMany
   */
  export type ContractModificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractModification
     */
    select?: ContractModificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractModificationInclude<ExtArgs> | null
    /**
     * Filter, which ContractModifications to fetch.
     */
    where?: ContractModificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractModifications to fetch.
     */
    orderBy?: ContractModificationOrderByWithRelationInput | ContractModificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContractModifications.
     */
    cursor?: ContractModificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractModifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractModifications.
     */
    skip?: number
    distinct?: ContractModificationScalarFieldEnum | ContractModificationScalarFieldEnum[]
  }

  /**
   * ContractModification create
   */
  export type ContractModificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractModification
     */
    select?: ContractModificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractModificationInclude<ExtArgs> | null
    /**
     * The data needed to create a ContractModification.
     */
    data: XOR<ContractModificationCreateInput, ContractModificationUncheckedCreateInput>
  }

  /**
   * ContractModification createMany
   */
  export type ContractModificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContractModifications.
     */
    data: ContractModificationCreateManyInput | ContractModificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContractModification update
   */
  export type ContractModificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractModification
     */
    select?: ContractModificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractModificationInclude<ExtArgs> | null
    /**
     * The data needed to update a ContractModification.
     */
    data: XOR<ContractModificationUpdateInput, ContractModificationUncheckedUpdateInput>
    /**
     * Choose, which ContractModification to update.
     */
    where: ContractModificationWhereUniqueInput
  }

  /**
   * ContractModification updateMany
   */
  export type ContractModificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContractModifications.
     */
    data: XOR<ContractModificationUpdateManyMutationInput, ContractModificationUncheckedUpdateManyInput>
    /**
     * Filter which ContractModifications to update
     */
    where?: ContractModificationWhereInput
  }

  /**
   * ContractModification upsert
   */
  export type ContractModificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractModification
     */
    select?: ContractModificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractModificationInclude<ExtArgs> | null
    /**
     * The filter to search for the ContractModification to update in case it exists.
     */
    where: ContractModificationWhereUniqueInput
    /**
     * In case the ContractModification found by the `where` argument doesn't exist, create a new ContractModification with this data.
     */
    create: XOR<ContractModificationCreateInput, ContractModificationUncheckedCreateInput>
    /**
     * In case the ContractModification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractModificationUpdateInput, ContractModificationUncheckedUpdateInput>
  }

  /**
   * ContractModification delete
   */
  export type ContractModificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractModification
     */
    select?: ContractModificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractModificationInclude<ExtArgs> | null
    /**
     * Filter which ContractModification to delete.
     */
    where: ContractModificationWhereUniqueInput
  }

  /**
   * ContractModification deleteMany
   */
  export type ContractModificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractModifications to delete
     */
    where?: ContractModificationWhereInput
  }

  /**
   * ContractModification.attachment
   */
  export type ContractModification$attachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
  }

  /**
   * ContractModification without action
   */
  export type ContractModificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractModification
     */
    select?: ContractModificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractModificationInclude<ExtArgs> | null
  }


  /**
   * Model WeeklyReport
   */

  export type AggregateWeeklyReport = {
    _count: WeeklyReportCountAggregateOutputType | null
    _min: WeeklyReportMinAggregateOutputType | null
    _max: WeeklyReportMaxAggregateOutputType | null
  }

  export type WeeklyReportMinAggregateOutputType = {
    id: string | null
    number: string | null
    startDate: Date | null
    endDate: Date | null
    summary: string | null
    progressSummary: string | null
    nextWeekPlan: string | null
    issues: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WeeklyReportMaxAggregateOutputType = {
    id: string | null
    number: string | null
    startDate: Date | null
    endDate: Date | null
    summary: string | null
    progressSummary: string | null
    nextWeekPlan: string | null
    issues: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WeeklyReportCountAggregateOutputType = {
    id: number
    number: number
    startDate: number
    endDate: number
    summary: number
    progressSummary: number
    nextWeekPlan: number
    issues: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WeeklyReportMinAggregateInputType = {
    id?: true
    number?: true
    startDate?: true
    endDate?: true
    summary?: true
    progressSummary?: true
    nextWeekPlan?: true
    issues?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WeeklyReportMaxAggregateInputType = {
    id?: true
    number?: true
    startDate?: true
    endDate?: true
    summary?: true
    progressSummary?: true
    nextWeekPlan?: true
    issues?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WeeklyReportCountAggregateInputType = {
    id?: true
    number?: true
    startDate?: true
    endDate?: true
    summary?: true
    progressSummary?: true
    nextWeekPlan?: true
    issues?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WeeklyReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeeklyReport to aggregate.
     */
    where?: WeeklyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyReports to fetch.
     */
    orderBy?: WeeklyReportOrderByWithRelationInput | WeeklyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WeeklyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WeeklyReports
    **/
    _count?: true | WeeklyReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeeklyReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeeklyReportMaxAggregateInputType
  }

  export type GetWeeklyReportAggregateType<T extends WeeklyReportAggregateArgs> = {
        [P in keyof T & keyof AggregateWeeklyReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeeklyReport[P]>
      : GetScalarType<T[P], AggregateWeeklyReport[P]>
  }




  export type WeeklyReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WeeklyReportWhereInput
    orderBy?: WeeklyReportOrderByWithAggregationInput | WeeklyReportOrderByWithAggregationInput[]
    by: WeeklyReportScalarFieldEnum[] | WeeklyReportScalarFieldEnum
    having?: WeeklyReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeeklyReportCountAggregateInputType | true
    _min?: WeeklyReportMinAggregateInputType
    _max?: WeeklyReportMaxAggregateInputType
  }

  export type WeeklyReportGroupByOutputType = {
    id: string
    number: string
    startDate: Date
    endDate: Date
    summary: string
    progressSummary: string | null
    nextWeekPlan: string | null
    issues: string | null
    createdAt: Date
    updatedAt: Date
    _count: WeeklyReportCountAggregateOutputType | null
    _min: WeeklyReportMinAggregateOutputType | null
    _max: WeeklyReportMaxAggregateOutputType | null
  }

  type GetWeeklyReportGroupByPayload<T extends WeeklyReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WeeklyReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeeklyReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeeklyReportGroupByOutputType[P]>
            : GetScalarType<T[P], WeeklyReportGroupByOutputType[P]>
        }
      >
    >


  export type WeeklyReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    startDate?: boolean
    endDate?: boolean
    summary?: boolean
    progressSummary?: boolean
    nextWeekPlan?: boolean
    issues?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    attachments?: boolean | WeeklyReport$attachmentsArgs<ExtArgs>
    _count?: boolean | WeeklyReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["weeklyReport"]>


  export type WeeklyReportSelectScalar = {
    id?: boolean
    number?: boolean
    startDate?: boolean
    endDate?: boolean
    summary?: boolean
    progressSummary?: boolean
    nextWeekPlan?: boolean
    issues?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WeeklyReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | WeeklyReport$attachmentsArgs<ExtArgs>
    _count?: boolean | WeeklyReportCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WeeklyReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WeeklyReport"
    objects: {
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      number: string
      startDate: Date
      endDate: Date
      summary: string
      progressSummary: string | null
      nextWeekPlan: string | null
      issues: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["weeklyReport"]>
    composites: {}
  }

  type WeeklyReportGetPayload<S extends boolean | null | undefined | WeeklyReportDefaultArgs> = $Result.GetResult<Prisma.$WeeklyReportPayload, S>

  type WeeklyReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WeeklyReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WeeklyReportCountAggregateInputType | true
    }

  export interface WeeklyReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WeeklyReport'], meta: { name: 'WeeklyReport' } }
    /**
     * Find zero or one WeeklyReport that matches the filter.
     * @param {WeeklyReportFindUniqueArgs} args - Arguments to find a WeeklyReport
     * @example
     * // Get one WeeklyReport
     * const weeklyReport = await prisma.weeklyReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WeeklyReportFindUniqueArgs>(args: SelectSubset<T, WeeklyReportFindUniqueArgs<ExtArgs>>): Prisma__WeeklyReportClient<$Result.GetResult<Prisma.$WeeklyReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WeeklyReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WeeklyReportFindUniqueOrThrowArgs} args - Arguments to find a WeeklyReport
     * @example
     * // Get one WeeklyReport
     * const weeklyReport = await prisma.weeklyReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WeeklyReportFindUniqueOrThrowArgs>(args: SelectSubset<T, WeeklyReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WeeklyReportClient<$Result.GetResult<Prisma.$WeeklyReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WeeklyReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyReportFindFirstArgs} args - Arguments to find a WeeklyReport
     * @example
     * // Get one WeeklyReport
     * const weeklyReport = await prisma.weeklyReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WeeklyReportFindFirstArgs>(args?: SelectSubset<T, WeeklyReportFindFirstArgs<ExtArgs>>): Prisma__WeeklyReportClient<$Result.GetResult<Prisma.$WeeklyReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WeeklyReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyReportFindFirstOrThrowArgs} args - Arguments to find a WeeklyReport
     * @example
     * // Get one WeeklyReport
     * const weeklyReport = await prisma.weeklyReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WeeklyReportFindFirstOrThrowArgs>(args?: SelectSubset<T, WeeklyReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__WeeklyReportClient<$Result.GetResult<Prisma.$WeeklyReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WeeklyReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WeeklyReports
     * const weeklyReports = await prisma.weeklyReport.findMany()
     * 
     * // Get first 10 WeeklyReports
     * const weeklyReports = await prisma.weeklyReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weeklyReportWithIdOnly = await prisma.weeklyReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WeeklyReportFindManyArgs>(args?: SelectSubset<T, WeeklyReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WeeklyReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WeeklyReport.
     * @param {WeeklyReportCreateArgs} args - Arguments to create a WeeklyReport.
     * @example
     * // Create one WeeklyReport
     * const WeeklyReport = await prisma.weeklyReport.create({
     *   data: {
     *     // ... data to create a WeeklyReport
     *   }
     * })
     * 
     */
    create<T extends WeeklyReportCreateArgs>(args: SelectSubset<T, WeeklyReportCreateArgs<ExtArgs>>): Prisma__WeeklyReportClient<$Result.GetResult<Prisma.$WeeklyReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WeeklyReports.
     * @param {WeeklyReportCreateManyArgs} args - Arguments to create many WeeklyReports.
     * @example
     * // Create many WeeklyReports
     * const weeklyReport = await prisma.weeklyReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WeeklyReportCreateManyArgs>(args?: SelectSubset<T, WeeklyReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WeeklyReport.
     * @param {WeeklyReportDeleteArgs} args - Arguments to delete one WeeklyReport.
     * @example
     * // Delete one WeeklyReport
     * const WeeklyReport = await prisma.weeklyReport.delete({
     *   where: {
     *     // ... filter to delete one WeeklyReport
     *   }
     * })
     * 
     */
    delete<T extends WeeklyReportDeleteArgs>(args: SelectSubset<T, WeeklyReportDeleteArgs<ExtArgs>>): Prisma__WeeklyReportClient<$Result.GetResult<Prisma.$WeeklyReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WeeklyReport.
     * @param {WeeklyReportUpdateArgs} args - Arguments to update one WeeklyReport.
     * @example
     * // Update one WeeklyReport
     * const weeklyReport = await prisma.weeklyReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WeeklyReportUpdateArgs>(args: SelectSubset<T, WeeklyReportUpdateArgs<ExtArgs>>): Prisma__WeeklyReportClient<$Result.GetResult<Prisma.$WeeklyReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WeeklyReports.
     * @param {WeeklyReportDeleteManyArgs} args - Arguments to filter WeeklyReports to delete.
     * @example
     * // Delete a few WeeklyReports
     * const { count } = await prisma.weeklyReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WeeklyReportDeleteManyArgs>(args?: SelectSubset<T, WeeklyReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WeeklyReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WeeklyReports
     * const weeklyReport = await prisma.weeklyReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WeeklyReportUpdateManyArgs>(args: SelectSubset<T, WeeklyReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WeeklyReport.
     * @param {WeeklyReportUpsertArgs} args - Arguments to update or create a WeeklyReport.
     * @example
     * // Update or create a WeeklyReport
     * const weeklyReport = await prisma.weeklyReport.upsert({
     *   create: {
     *     // ... data to create a WeeklyReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WeeklyReport we want to update
     *   }
     * })
     */
    upsert<T extends WeeklyReportUpsertArgs>(args: SelectSubset<T, WeeklyReportUpsertArgs<ExtArgs>>): Prisma__WeeklyReportClient<$Result.GetResult<Prisma.$WeeklyReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WeeklyReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyReportCountArgs} args - Arguments to filter WeeklyReports to count.
     * @example
     * // Count the number of WeeklyReports
     * const count = await prisma.weeklyReport.count({
     *   where: {
     *     // ... the filter for the WeeklyReports we want to count
     *   }
     * })
    **/
    count<T extends WeeklyReportCountArgs>(
      args?: Subset<T, WeeklyReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeeklyReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WeeklyReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeeklyReportAggregateArgs>(args: Subset<T, WeeklyReportAggregateArgs>): Prisma.PrismaPromise<GetWeeklyReportAggregateType<T>>

    /**
     * Group by WeeklyReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeeklyReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeeklyReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeeklyReportGroupByArgs['orderBy'] }
        : { orderBy?: WeeklyReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeeklyReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeeklyReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WeeklyReport model
   */
  readonly fields: WeeklyReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WeeklyReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WeeklyReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attachments<T extends WeeklyReport$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, WeeklyReport$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WeeklyReport model
   */ 
  interface WeeklyReportFieldRefs {
    readonly id: FieldRef<"WeeklyReport", 'String'>
    readonly number: FieldRef<"WeeklyReport", 'String'>
    readonly startDate: FieldRef<"WeeklyReport", 'DateTime'>
    readonly endDate: FieldRef<"WeeklyReport", 'DateTime'>
    readonly summary: FieldRef<"WeeklyReport", 'String'>
    readonly progressSummary: FieldRef<"WeeklyReport", 'String'>
    readonly nextWeekPlan: FieldRef<"WeeklyReport", 'String'>
    readonly issues: FieldRef<"WeeklyReport", 'String'>
    readonly createdAt: FieldRef<"WeeklyReport", 'DateTime'>
    readonly updatedAt: FieldRef<"WeeklyReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WeeklyReport findUnique
   */
  export type WeeklyReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyReport
     */
    select?: WeeklyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyReportInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyReport to fetch.
     */
    where: WeeklyReportWhereUniqueInput
  }

  /**
   * WeeklyReport findUniqueOrThrow
   */
  export type WeeklyReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyReport
     */
    select?: WeeklyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyReportInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyReport to fetch.
     */
    where: WeeklyReportWhereUniqueInput
  }

  /**
   * WeeklyReport findFirst
   */
  export type WeeklyReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyReport
     */
    select?: WeeklyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyReportInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyReport to fetch.
     */
    where?: WeeklyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyReports to fetch.
     */
    orderBy?: WeeklyReportOrderByWithRelationInput | WeeklyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeeklyReports.
     */
    cursor?: WeeklyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeeklyReports.
     */
    distinct?: WeeklyReportScalarFieldEnum | WeeklyReportScalarFieldEnum[]
  }

  /**
   * WeeklyReport findFirstOrThrow
   */
  export type WeeklyReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyReport
     */
    select?: WeeklyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyReportInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyReport to fetch.
     */
    where?: WeeklyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyReports to fetch.
     */
    orderBy?: WeeklyReportOrderByWithRelationInput | WeeklyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WeeklyReports.
     */
    cursor?: WeeklyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WeeklyReports.
     */
    distinct?: WeeklyReportScalarFieldEnum | WeeklyReportScalarFieldEnum[]
  }

  /**
   * WeeklyReport findMany
   */
  export type WeeklyReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyReport
     */
    select?: WeeklyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyReportInclude<ExtArgs> | null
    /**
     * Filter, which WeeklyReports to fetch.
     */
    where?: WeeklyReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WeeklyReports to fetch.
     */
    orderBy?: WeeklyReportOrderByWithRelationInput | WeeklyReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WeeklyReports.
     */
    cursor?: WeeklyReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WeeklyReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WeeklyReports.
     */
    skip?: number
    distinct?: WeeklyReportScalarFieldEnum | WeeklyReportScalarFieldEnum[]
  }

  /**
   * WeeklyReport create
   */
  export type WeeklyReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyReport
     */
    select?: WeeklyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyReportInclude<ExtArgs> | null
    /**
     * The data needed to create a WeeklyReport.
     */
    data: XOR<WeeklyReportCreateInput, WeeklyReportUncheckedCreateInput>
  }

  /**
   * WeeklyReport createMany
   */
  export type WeeklyReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WeeklyReports.
     */
    data: WeeklyReportCreateManyInput | WeeklyReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WeeklyReport update
   */
  export type WeeklyReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyReport
     */
    select?: WeeklyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyReportInclude<ExtArgs> | null
    /**
     * The data needed to update a WeeklyReport.
     */
    data: XOR<WeeklyReportUpdateInput, WeeklyReportUncheckedUpdateInput>
    /**
     * Choose, which WeeklyReport to update.
     */
    where: WeeklyReportWhereUniqueInput
  }

  /**
   * WeeklyReport updateMany
   */
  export type WeeklyReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WeeklyReports.
     */
    data: XOR<WeeklyReportUpdateManyMutationInput, WeeklyReportUncheckedUpdateManyInput>
    /**
     * Filter which WeeklyReports to update
     */
    where?: WeeklyReportWhereInput
  }

  /**
   * WeeklyReport upsert
   */
  export type WeeklyReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyReport
     */
    select?: WeeklyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyReportInclude<ExtArgs> | null
    /**
     * The filter to search for the WeeklyReport to update in case it exists.
     */
    where: WeeklyReportWhereUniqueInput
    /**
     * In case the WeeklyReport found by the `where` argument doesn't exist, create a new WeeklyReport with this data.
     */
    create: XOR<WeeklyReportCreateInput, WeeklyReportUncheckedCreateInput>
    /**
     * In case the WeeklyReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WeeklyReportUpdateInput, WeeklyReportUncheckedUpdateInput>
  }

  /**
   * WeeklyReport delete
   */
  export type WeeklyReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyReport
     */
    select?: WeeklyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyReportInclude<ExtArgs> | null
    /**
     * Filter which WeeklyReport to delete.
     */
    where: WeeklyReportWhereUniqueInput
  }

  /**
   * WeeklyReport deleteMany
   */
  export type WeeklyReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WeeklyReports to delete
     */
    where?: WeeklyReportWhereInput
  }

  /**
   * WeeklyReport.attachments
   */
  export type WeeklyReport$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * WeeklyReport without action
   */
  export type WeeklyReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyReport
     */
    select?: WeeklyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyReportInclude<ExtArgs> | null
  }


  /**
   * Model LogEntry
   */

  export type AggregateLogEntry = {
    _count: LogEntryCountAggregateOutputType | null
    _avg: LogEntryAvgAggregateOutputType | null
    _sum: LogEntrySumAggregateOutputType | null
    _min: LogEntryMinAggregateOutputType | null
    _max: LogEntryMaxAggregateOutputType | null
  }

  export type LogEntryAvgAggregateOutputType = {
    folioNumber: number | null
  }

  export type LogEntrySumAggregateOutputType = {
    folioNumber: number | null
  }

  export type LogEntryMinAggregateOutputType = {
    id: string | null
    folioNumber: number | null
    title: string | null
    description: string | null
    type: $Enums.EntryType | null
    subject: string | null
    location: string | null
    activityStartDate: Date | null
    activityEndDate: Date | null
    isConfidential: boolean | null
    status: $Enums.EntryStatus | null
    authorId: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LogEntryMaxAggregateOutputType = {
    id: string | null
    folioNumber: number | null
    title: string | null
    description: string | null
    type: $Enums.EntryType | null
    subject: string | null
    location: string | null
    activityStartDate: Date | null
    activityEndDate: Date | null
    isConfidential: boolean | null
    status: $Enums.EntryStatus | null
    authorId: string | null
    projectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LogEntryCountAggregateOutputType = {
    id: number
    folioNumber: number
    title: number
    description: number
    type: number
    subject: number
    location: number
    activityStartDate: number
    activityEndDate: number
    isConfidential: number
    status: number
    authorId: number
    projectId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LogEntryAvgAggregateInputType = {
    folioNumber?: true
  }

  export type LogEntrySumAggregateInputType = {
    folioNumber?: true
  }

  export type LogEntryMinAggregateInputType = {
    id?: true
    folioNumber?: true
    title?: true
    description?: true
    type?: true
    subject?: true
    location?: true
    activityStartDate?: true
    activityEndDate?: true
    isConfidential?: true
    status?: true
    authorId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LogEntryMaxAggregateInputType = {
    id?: true
    folioNumber?: true
    title?: true
    description?: true
    type?: true
    subject?: true
    location?: true
    activityStartDate?: true
    activityEndDate?: true
    isConfidential?: true
    status?: true
    authorId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LogEntryCountAggregateInputType = {
    id?: true
    folioNumber?: true
    title?: true
    description?: true
    type?: true
    subject?: true
    location?: true
    activityStartDate?: true
    activityEndDate?: true
    isConfidential?: true
    status?: true
    authorId?: true
    projectId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LogEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogEntry to aggregate.
     */
    where?: LogEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogEntries to fetch.
     */
    orderBy?: LogEntryOrderByWithRelationInput | LogEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogEntries
    **/
    _count?: true | LogEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogEntryMaxAggregateInputType
  }

  export type GetLogEntryAggregateType<T extends LogEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateLogEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogEntry[P]>
      : GetScalarType<T[P], AggregateLogEntry[P]>
  }




  export type LogEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogEntryWhereInput
    orderBy?: LogEntryOrderByWithAggregationInput | LogEntryOrderByWithAggregationInput[]
    by: LogEntryScalarFieldEnum[] | LogEntryScalarFieldEnum
    having?: LogEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogEntryCountAggregateInputType | true
    _avg?: LogEntryAvgAggregateInputType
    _sum?: LogEntrySumAggregateInputType
    _min?: LogEntryMinAggregateInputType
    _max?: LogEntryMaxAggregateInputType
  }

  export type LogEntryGroupByOutputType = {
    id: string
    folioNumber: number
    title: string
    description: string
    type: $Enums.EntryType
    subject: string
    location: string
    activityStartDate: Date
    activityEndDate: Date
    isConfidential: boolean
    status: $Enums.EntryStatus
    authorId: string
    projectId: string
    createdAt: Date
    updatedAt: Date
    _count: LogEntryCountAggregateOutputType | null
    _avg: LogEntryAvgAggregateOutputType | null
    _sum: LogEntrySumAggregateOutputType | null
    _min: LogEntryMinAggregateOutputType | null
    _max: LogEntryMaxAggregateOutputType | null
  }

  type GetLogEntryGroupByPayload<T extends LogEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogEntryGroupByOutputType[P]>
            : GetScalarType<T[P], LogEntryGroupByOutputType[P]>
        }
      >
    >


  export type LogEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    folioNumber?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    subject?: boolean
    location?: boolean
    activityStartDate?: boolean
    activityEndDate?: boolean
    isConfidential?: boolean
    status?: boolean
    authorId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    assignees?: boolean | LogEntry$assigneesArgs<ExtArgs>
    comments?: boolean | LogEntry$commentsArgs<ExtArgs>
    attachments?: boolean | LogEntry$attachmentsArgs<ExtArgs>
    signatures?: boolean | LogEntry$signaturesArgs<ExtArgs>
    history?: boolean | LogEntry$historyArgs<ExtArgs>
    _count?: boolean | LogEntryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logEntry"]>


  export type LogEntrySelectScalar = {
    id?: boolean
    folioNumber?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    subject?: boolean
    location?: boolean
    activityStartDate?: boolean
    activityEndDate?: boolean
    isConfidential?: boolean
    status?: boolean
    authorId?: boolean
    projectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LogEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    assignees?: boolean | LogEntry$assigneesArgs<ExtArgs>
    comments?: boolean | LogEntry$commentsArgs<ExtArgs>
    attachments?: boolean | LogEntry$attachmentsArgs<ExtArgs>
    signatures?: boolean | LogEntry$signaturesArgs<ExtArgs>
    history?: boolean | LogEntry$historyArgs<ExtArgs>
    _count?: boolean | LogEntryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LogEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogEntry"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
      assignees: Prisma.$UserPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
      signatures: Prisma.$SignaturePayload<ExtArgs>[]
      history: Prisma.$LogEntryHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      folioNumber: number
      title: string
      description: string
      type: $Enums.EntryType
      subject: string
      location: string
      activityStartDate: Date
      activityEndDate: Date
      isConfidential: boolean
      status: $Enums.EntryStatus
      authorId: string
      projectId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["logEntry"]>
    composites: {}
  }

  type LogEntryGetPayload<S extends boolean | null | undefined | LogEntryDefaultArgs> = $Result.GetResult<Prisma.$LogEntryPayload, S>

  type LogEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogEntryCountAggregateInputType | true
    }

  export interface LogEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogEntry'], meta: { name: 'LogEntry' } }
    /**
     * Find zero or one LogEntry that matches the filter.
     * @param {LogEntryFindUniqueArgs} args - Arguments to find a LogEntry
     * @example
     * // Get one LogEntry
     * const logEntry = await prisma.logEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogEntryFindUniqueArgs>(args: SelectSubset<T, LogEntryFindUniqueArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LogEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LogEntryFindUniqueOrThrowArgs} args - Arguments to find a LogEntry
     * @example
     * // Get one LogEntry
     * const logEntry = await prisma.logEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, LogEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LogEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryFindFirstArgs} args - Arguments to find a LogEntry
     * @example
     * // Get one LogEntry
     * const logEntry = await prisma.logEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogEntryFindFirstArgs>(args?: SelectSubset<T, LogEntryFindFirstArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LogEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryFindFirstOrThrowArgs} args - Arguments to find a LogEntry
     * @example
     * // Get one LogEntry
     * const logEntry = await prisma.logEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, LogEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LogEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogEntries
     * const logEntries = await prisma.logEntry.findMany()
     * 
     * // Get first 10 LogEntries
     * const logEntries = await prisma.logEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logEntryWithIdOnly = await prisma.logEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogEntryFindManyArgs>(args?: SelectSubset<T, LogEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LogEntry.
     * @param {LogEntryCreateArgs} args - Arguments to create a LogEntry.
     * @example
     * // Create one LogEntry
     * const LogEntry = await prisma.logEntry.create({
     *   data: {
     *     // ... data to create a LogEntry
     *   }
     * })
     * 
     */
    create<T extends LogEntryCreateArgs>(args: SelectSubset<T, LogEntryCreateArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LogEntries.
     * @param {LogEntryCreateManyArgs} args - Arguments to create many LogEntries.
     * @example
     * // Create many LogEntries
     * const logEntry = await prisma.logEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogEntryCreateManyArgs>(args?: SelectSubset<T, LogEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LogEntry.
     * @param {LogEntryDeleteArgs} args - Arguments to delete one LogEntry.
     * @example
     * // Delete one LogEntry
     * const LogEntry = await prisma.logEntry.delete({
     *   where: {
     *     // ... filter to delete one LogEntry
     *   }
     * })
     * 
     */
    delete<T extends LogEntryDeleteArgs>(args: SelectSubset<T, LogEntryDeleteArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LogEntry.
     * @param {LogEntryUpdateArgs} args - Arguments to update one LogEntry.
     * @example
     * // Update one LogEntry
     * const logEntry = await prisma.logEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogEntryUpdateArgs>(args: SelectSubset<T, LogEntryUpdateArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LogEntries.
     * @param {LogEntryDeleteManyArgs} args - Arguments to filter LogEntries to delete.
     * @example
     * // Delete a few LogEntries
     * const { count } = await prisma.logEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogEntryDeleteManyArgs>(args?: SelectSubset<T, LogEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogEntries
     * const logEntry = await prisma.logEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogEntryUpdateManyArgs>(args: SelectSubset<T, LogEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogEntry.
     * @param {LogEntryUpsertArgs} args - Arguments to update or create a LogEntry.
     * @example
     * // Update or create a LogEntry
     * const logEntry = await prisma.logEntry.upsert({
     *   create: {
     *     // ... data to create a LogEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogEntry we want to update
     *   }
     * })
     */
    upsert<T extends LogEntryUpsertArgs>(args: SelectSubset<T, LogEntryUpsertArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LogEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryCountArgs} args - Arguments to filter LogEntries to count.
     * @example
     * // Count the number of LogEntries
     * const count = await prisma.logEntry.count({
     *   where: {
     *     // ... the filter for the LogEntries we want to count
     *   }
     * })
    **/
    count<T extends LogEntryCountArgs>(
      args?: Subset<T, LogEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogEntryAggregateArgs>(args: Subset<T, LogEntryAggregateArgs>): Prisma.PrismaPromise<GetLogEntryAggregateType<T>>

    /**
     * Group by LogEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogEntryGroupByArgs['orderBy'] }
        : { orderBy?: LogEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogEntry model
   */
  readonly fields: LogEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignees<T extends LogEntry$assigneesArgs<ExtArgs> = {}>(args?: Subset<T, LogEntry$assigneesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends LogEntry$commentsArgs<ExtArgs> = {}>(args?: Subset<T, LogEntry$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    attachments<T extends LogEntry$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, LogEntry$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    signatures<T extends LogEntry$signaturesArgs<ExtArgs> = {}>(args?: Subset<T, LogEntry$signaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findMany"> | Null>
    history<T extends LogEntry$historyArgs<ExtArgs> = {}>(args?: Subset<T, LogEntry$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogEntryHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LogEntry model
   */ 
  interface LogEntryFieldRefs {
    readonly id: FieldRef<"LogEntry", 'String'>
    readonly folioNumber: FieldRef<"LogEntry", 'Int'>
    readonly title: FieldRef<"LogEntry", 'String'>
    readonly description: FieldRef<"LogEntry", 'String'>
    readonly type: FieldRef<"LogEntry", 'EntryType'>
    readonly subject: FieldRef<"LogEntry", 'String'>
    readonly location: FieldRef<"LogEntry", 'String'>
    readonly activityStartDate: FieldRef<"LogEntry", 'DateTime'>
    readonly activityEndDate: FieldRef<"LogEntry", 'DateTime'>
    readonly isConfidential: FieldRef<"LogEntry", 'Boolean'>
    readonly status: FieldRef<"LogEntry", 'EntryStatus'>
    readonly authorId: FieldRef<"LogEntry", 'String'>
    readonly projectId: FieldRef<"LogEntry", 'String'>
    readonly createdAt: FieldRef<"LogEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"LogEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LogEntry findUnique
   */
  export type LogEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * Filter, which LogEntry to fetch.
     */
    where: LogEntryWhereUniqueInput
  }

  /**
   * LogEntry findUniqueOrThrow
   */
  export type LogEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * Filter, which LogEntry to fetch.
     */
    where: LogEntryWhereUniqueInput
  }

  /**
   * LogEntry findFirst
   */
  export type LogEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * Filter, which LogEntry to fetch.
     */
    where?: LogEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogEntries to fetch.
     */
    orderBy?: LogEntryOrderByWithRelationInput | LogEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogEntries.
     */
    cursor?: LogEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogEntries.
     */
    distinct?: LogEntryScalarFieldEnum | LogEntryScalarFieldEnum[]
  }

  /**
   * LogEntry findFirstOrThrow
   */
  export type LogEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * Filter, which LogEntry to fetch.
     */
    where?: LogEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogEntries to fetch.
     */
    orderBy?: LogEntryOrderByWithRelationInput | LogEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogEntries.
     */
    cursor?: LogEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogEntries.
     */
    distinct?: LogEntryScalarFieldEnum | LogEntryScalarFieldEnum[]
  }

  /**
   * LogEntry findMany
   */
  export type LogEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * Filter, which LogEntries to fetch.
     */
    where?: LogEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogEntries to fetch.
     */
    orderBy?: LogEntryOrderByWithRelationInput | LogEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogEntries.
     */
    cursor?: LogEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogEntries.
     */
    skip?: number
    distinct?: LogEntryScalarFieldEnum | LogEntryScalarFieldEnum[]
  }

  /**
   * LogEntry create
   */
  export type LogEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a LogEntry.
     */
    data: XOR<LogEntryCreateInput, LogEntryUncheckedCreateInput>
  }

  /**
   * LogEntry createMany
   */
  export type LogEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogEntries.
     */
    data: LogEntryCreateManyInput | LogEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LogEntry update
   */
  export type LogEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a LogEntry.
     */
    data: XOR<LogEntryUpdateInput, LogEntryUncheckedUpdateInput>
    /**
     * Choose, which LogEntry to update.
     */
    where: LogEntryWhereUniqueInput
  }

  /**
   * LogEntry updateMany
   */
  export type LogEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogEntries.
     */
    data: XOR<LogEntryUpdateManyMutationInput, LogEntryUncheckedUpdateManyInput>
    /**
     * Filter which LogEntries to update
     */
    where?: LogEntryWhereInput
  }

  /**
   * LogEntry upsert
   */
  export type LogEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the LogEntry to update in case it exists.
     */
    where: LogEntryWhereUniqueInput
    /**
     * In case the LogEntry found by the `where` argument doesn't exist, create a new LogEntry with this data.
     */
    create: XOR<LogEntryCreateInput, LogEntryUncheckedCreateInput>
    /**
     * In case the LogEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogEntryUpdateInput, LogEntryUncheckedUpdateInput>
  }

  /**
   * LogEntry delete
   */
  export type LogEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    /**
     * Filter which LogEntry to delete.
     */
    where: LogEntryWhereUniqueInput
  }

  /**
   * LogEntry deleteMany
   */
  export type LogEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogEntries to delete
     */
    where?: LogEntryWhereInput
  }

  /**
   * LogEntry.assignees
   */
  export type LogEntry$assigneesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * LogEntry.comments
   */
  export type LogEntry$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * LogEntry.attachments
   */
  export type LogEntry$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * LogEntry.signatures
   */
  export type LogEntry$signaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    where?: SignatureWhereInput
    orderBy?: SignatureOrderByWithRelationInput | SignatureOrderByWithRelationInput[]
    cursor?: SignatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SignatureScalarFieldEnum | SignatureScalarFieldEnum[]
  }

  /**
   * LogEntry.history
   */
  export type LogEntry$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntryHistory
     */
    select?: LogEntryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryHistoryInclude<ExtArgs> | null
    where?: LogEntryHistoryWhereInput
    orderBy?: LogEntryHistoryOrderByWithRelationInput | LogEntryHistoryOrderByWithRelationInput[]
    cursor?: LogEntryHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogEntryHistoryScalarFieldEnum | LogEntryHistoryScalarFieldEnum[]
  }

  /**
   * LogEntry without action
   */
  export type LogEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
  }


  /**
   * Model LogEntryHistory
   */

  export type AggregateLogEntryHistory = {
    _count: LogEntryHistoryCountAggregateOutputType | null
    _min: LogEntryHistoryMinAggregateOutputType | null
    _max: LogEntryHistoryMaxAggregateOutputType | null
  }

  export type LogEntryHistoryMinAggregateOutputType = {
    id: string | null
    fieldName: string | null
    oldValue: string | null
    newValue: string | null
    timestamp: Date | null
    logEntryId: string | null
    userId: string | null
  }

  export type LogEntryHistoryMaxAggregateOutputType = {
    id: string | null
    fieldName: string | null
    oldValue: string | null
    newValue: string | null
    timestamp: Date | null
    logEntryId: string | null
    userId: string | null
  }

  export type LogEntryHistoryCountAggregateOutputType = {
    id: number
    fieldName: number
    oldValue: number
    newValue: number
    timestamp: number
    logEntryId: number
    userId: number
    _all: number
  }


  export type LogEntryHistoryMinAggregateInputType = {
    id?: true
    fieldName?: true
    oldValue?: true
    newValue?: true
    timestamp?: true
    logEntryId?: true
    userId?: true
  }

  export type LogEntryHistoryMaxAggregateInputType = {
    id?: true
    fieldName?: true
    oldValue?: true
    newValue?: true
    timestamp?: true
    logEntryId?: true
    userId?: true
  }

  export type LogEntryHistoryCountAggregateInputType = {
    id?: true
    fieldName?: true
    oldValue?: true
    newValue?: true
    timestamp?: true
    logEntryId?: true
    userId?: true
    _all?: true
  }

  export type LogEntryHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogEntryHistory to aggregate.
     */
    where?: LogEntryHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogEntryHistories to fetch.
     */
    orderBy?: LogEntryHistoryOrderByWithRelationInput | LogEntryHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogEntryHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogEntryHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogEntryHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogEntryHistories
    **/
    _count?: true | LogEntryHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogEntryHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogEntryHistoryMaxAggregateInputType
  }

  export type GetLogEntryHistoryAggregateType<T extends LogEntryHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateLogEntryHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogEntryHistory[P]>
      : GetScalarType<T[P], AggregateLogEntryHistory[P]>
  }




  export type LogEntryHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogEntryHistoryWhereInput
    orderBy?: LogEntryHistoryOrderByWithAggregationInput | LogEntryHistoryOrderByWithAggregationInput[]
    by: LogEntryHistoryScalarFieldEnum[] | LogEntryHistoryScalarFieldEnum
    having?: LogEntryHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogEntryHistoryCountAggregateInputType | true
    _min?: LogEntryHistoryMinAggregateInputType
    _max?: LogEntryHistoryMaxAggregateInputType
  }

  export type LogEntryHistoryGroupByOutputType = {
    id: string
    fieldName: string
    oldValue: string | null
    newValue: string | null
    timestamp: Date
    logEntryId: string
    userId: string | null
    _count: LogEntryHistoryCountAggregateOutputType | null
    _min: LogEntryHistoryMinAggregateOutputType | null
    _max: LogEntryHistoryMaxAggregateOutputType | null
  }

  type GetLogEntryHistoryGroupByPayload<T extends LogEntryHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogEntryHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogEntryHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogEntryHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], LogEntryHistoryGroupByOutputType[P]>
        }
      >
    >


  export type LogEntryHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fieldName?: boolean
    oldValue?: boolean
    newValue?: boolean
    timestamp?: boolean
    logEntryId?: boolean
    userId?: boolean
    logEntry?: boolean | LogEntryDefaultArgs<ExtArgs>
    user?: boolean | LogEntryHistory$userArgs<ExtArgs>
  }, ExtArgs["result"]["logEntryHistory"]>


  export type LogEntryHistorySelectScalar = {
    id?: boolean
    fieldName?: boolean
    oldValue?: boolean
    newValue?: boolean
    timestamp?: boolean
    logEntryId?: boolean
    userId?: boolean
  }

  export type LogEntryHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logEntry?: boolean | LogEntryDefaultArgs<ExtArgs>
    user?: boolean | LogEntryHistory$userArgs<ExtArgs>
  }

  export type $LogEntryHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogEntryHistory"
    objects: {
      logEntry: Prisma.$LogEntryPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fieldName: string
      oldValue: string | null
      newValue: string | null
      timestamp: Date
      logEntryId: string
      userId: string | null
    }, ExtArgs["result"]["logEntryHistory"]>
    composites: {}
  }

  type LogEntryHistoryGetPayload<S extends boolean | null | undefined | LogEntryHistoryDefaultArgs> = $Result.GetResult<Prisma.$LogEntryHistoryPayload, S>

  type LogEntryHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogEntryHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogEntryHistoryCountAggregateInputType | true
    }

  export interface LogEntryHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogEntryHistory'], meta: { name: 'LogEntryHistory' } }
    /**
     * Find zero or one LogEntryHistory that matches the filter.
     * @param {LogEntryHistoryFindUniqueArgs} args - Arguments to find a LogEntryHistory
     * @example
     * // Get one LogEntryHistory
     * const logEntryHistory = await prisma.logEntryHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogEntryHistoryFindUniqueArgs>(args: SelectSubset<T, LogEntryHistoryFindUniqueArgs<ExtArgs>>): Prisma__LogEntryHistoryClient<$Result.GetResult<Prisma.$LogEntryHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LogEntryHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LogEntryHistoryFindUniqueOrThrowArgs} args - Arguments to find a LogEntryHistory
     * @example
     * // Get one LogEntryHistory
     * const logEntryHistory = await prisma.logEntryHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogEntryHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, LogEntryHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogEntryHistoryClient<$Result.GetResult<Prisma.$LogEntryHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LogEntryHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryHistoryFindFirstArgs} args - Arguments to find a LogEntryHistory
     * @example
     * // Get one LogEntryHistory
     * const logEntryHistory = await prisma.logEntryHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogEntryHistoryFindFirstArgs>(args?: SelectSubset<T, LogEntryHistoryFindFirstArgs<ExtArgs>>): Prisma__LogEntryHistoryClient<$Result.GetResult<Prisma.$LogEntryHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LogEntryHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryHistoryFindFirstOrThrowArgs} args - Arguments to find a LogEntryHistory
     * @example
     * // Get one LogEntryHistory
     * const logEntryHistory = await prisma.logEntryHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogEntryHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, LogEntryHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogEntryHistoryClient<$Result.GetResult<Prisma.$LogEntryHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LogEntryHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogEntryHistories
     * const logEntryHistories = await prisma.logEntryHistory.findMany()
     * 
     * // Get first 10 LogEntryHistories
     * const logEntryHistories = await prisma.logEntryHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logEntryHistoryWithIdOnly = await prisma.logEntryHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogEntryHistoryFindManyArgs>(args?: SelectSubset<T, LogEntryHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogEntryHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LogEntryHistory.
     * @param {LogEntryHistoryCreateArgs} args - Arguments to create a LogEntryHistory.
     * @example
     * // Create one LogEntryHistory
     * const LogEntryHistory = await prisma.logEntryHistory.create({
     *   data: {
     *     // ... data to create a LogEntryHistory
     *   }
     * })
     * 
     */
    create<T extends LogEntryHistoryCreateArgs>(args: SelectSubset<T, LogEntryHistoryCreateArgs<ExtArgs>>): Prisma__LogEntryHistoryClient<$Result.GetResult<Prisma.$LogEntryHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LogEntryHistories.
     * @param {LogEntryHistoryCreateManyArgs} args - Arguments to create many LogEntryHistories.
     * @example
     * // Create many LogEntryHistories
     * const logEntryHistory = await prisma.logEntryHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogEntryHistoryCreateManyArgs>(args?: SelectSubset<T, LogEntryHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LogEntryHistory.
     * @param {LogEntryHistoryDeleteArgs} args - Arguments to delete one LogEntryHistory.
     * @example
     * // Delete one LogEntryHistory
     * const LogEntryHistory = await prisma.logEntryHistory.delete({
     *   where: {
     *     // ... filter to delete one LogEntryHistory
     *   }
     * })
     * 
     */
    delete<T extends LogEntryHistoryDeleteArgs>(args: SelectSubset<T, LogEntryHistoryDeleteArgs<ExtArgs>>): Prisma__LogEntryHistoryClient<$Result.GetResult<Prisma.$LogEntryHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LogEntryHistory.
     * @param {LogEntryHistoryUpdateArgs} args - Arguments to update one LogEntryHistory.
     * @example
     * // Update one LogEntryHistory
     * const logEntryHistory = await prisma.logEntryHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogEntryHistoryUpdateArgs>(args: SelectSubset<T, LogEntryHistoryUpdateArgs<ExtArgs>>): Prisma__LogEntryHistoryClient<$Result.GetResult<Prisma.$LogEntryHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LogEntryHistories.
     * @param {LogEntryHistoryDeleteManyArgs} args - Arguments to filter LogEntryHistories to delete.
     * @example
     * // Delete a few LogEntryHistories
     * const { count } = await prisma.logEntryHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogEntryHistoryDeleteManyArgs>(args?: SelectSubset<T, LogEntryHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogEntryHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogEntryHistories
     * const logEntryHistory = await prisma.logEntryHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogEntryHistoryUpdateManyArgs>(args: SelectSubset<T, LogEntryHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogEntryHistory.
     * @param {LogEntryHistoryUpsertArgs} args - Arguments to update or create a LogEntryHistory.
     * @example
     * // Update or create a LogEntryHistory
     * const logEntryHistory = await prisma.logEntryHistory.upsert({
     *   create: {
     *     // ... data to create a LogEntryHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogEntryHistory we want to update
     *   }
     * })
     */
    upsert<T extends LogEntryHistoryUpsertArgs>(args: SelectSubset<T, LogEntryHistoryUpsertArgs<ExtArgs>>): Prisma__LogEntryHistoryClient<$Result.GetResult<Prisma.$LogEntryHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LogEntryHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryHistoryCountArgs} args - Arguments to filter LogEntryHistories to count.
     * @example
     * // Count the number of LogEntryHistories
     * const count = await prisma.logEntryHistory.count({
     *   where: {
     *     // ... the filter for the LogEntryHistories we want to count
     *   }
     * })
    **/
    count<T extends LogEntryHistoryCountArgs>(
      args?: Subset<T, LogEntryHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogEntryHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogEntryHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogEntryHistoryAggregateArgs>(args: Subset<T, LogEntryHistoryAggregateArgs>): Prisma.PrismaPromise<GetLogEntryHistoryAggregateType<T>>

    /**
     * Group by LogEntryHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogEntryHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogEntryHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogEntryHistoryGroupByArgs['orderBy'] }
        : { orderBy?: LogEntryHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogEntryHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogEntryHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogEntryHistory model
   */
  readonly fields: LogEntryHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogEntryHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogEntryHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    logEntry<T extends LogEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LogEntryDefaultArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends LogEntryHistory$userArgs<ExtArgs> = {}>(args?: Subset<T, LogEntryHistory$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LogEntryHistory model
   */ 
  interface LogEntryHistoryFieldRefs {
    readonly id: FieldRef<"LogEntryHistory", 'String'>
    readonly fieldName: FieldRef<"LogEntryHistory", 'String'>
    readonly oldValue: FieldRef<"LogEntryHistory", 'String'>
    readonly newValue: FieldRef<"LogEntryHistory", 'String'>
    readonly timestamp: FieldRef<"LogEntryHistory", 'DateTime'>
    readonly logEntryId: FieldRef<"LogEntryHistory", 'String'>
    readonly userId: FieldRef<"LogEntryHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LogEntryHistory findUnique
   */
  export type LogEntryHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntryHistory
     */
    select?: LogEntryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LogEntryHistory to fetch.
     */
    where: LogEntryHistoryWhereUniqueInput
  }

  /**
   * LogEntryHistory findUniqueOrThrow
   */
  export type LogEntryHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntryHistory
     */
    select?: LogEntryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LogEntryHistory to fetch.
     */
    where: LogEntryHistoryWhereUniqueInput
  }

  /**
   * LogEntryHistory findFirst
   */
  export type LogEntryHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntryHistory
     */
    select?: LogEntryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LogEntryHistory to fetch.
     */
    where?: LogEntryHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogEntryHistories to fetch.
     */
    orderBy?: LogEntryHistoryOrderByWithRelationInput | LogEntryHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogEntryHistories.
     */
    cursor?: LogEntryHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogEntryHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogEntryHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogEntryHistories.
     */
    distinct?: LogEntryHistoryScalarFieldEnum | LogEntryHistoryScalarFieldEnum[]
  }

  /**
   * LogEntryHistory findFirstOrThrow
   */
  export type LogEntryHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntryHistory
     */
    select?: LogEntryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LogEntryHistory to fetch.
     */
    where?: LogEntryHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogEntryHistories to fetch.
     */
    orderBy?: LogEntryHistoryOrderByWithRelationInput | LogEntryHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogEntryHistories.
     */
    cursor?: LogEntryHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogEntryHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogEntryHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogEntryHistories.
     */
    distinct?: LogEntryHistoryScalarFieldEnum | LogEntryHistoryScalarFieldEnum[]
  }

  /**
   * LogEntryHistory findMany
   */
  export type LogEntryHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntryHistory
     */
    select?: LogEntryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryHistoryInclude<ExtArgs> | null
    /**
     * Filter, which LogEntryHistories to fetch.
     */
    where?: LogEntryHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogEntryHistories to fetch.
     */
    orderBy?: LogEntryHistoryOrderByWithRelationInput | LogEntryHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogEntryHistories.
     */
    cursor?: LogEntryHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogEntryHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogEntryHistories.
     */
    skip?: number
    distinct?: LogEntryHistoryScalarFieldEnum | LogEntryHistoryScalarFieldEnum[]
  }

  /**
   * LogEntryHistory create
   */
  export type LogEntryHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntryHistory
     */
    select?: LogEntryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a LogEntryHistory.
     */
    data: XOR<LogEntryHistoryCreateInput, LogEntryHistoryUncheckedCreateInput>
  }

  /**
   * LogEntryHistory createMany
   */
  export type LogEntryHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogEntryHistories.
     */
    data: LogEntryHistoryCreateManyInput | LogEntryHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LogEntryHistory update
   */
  export type LogEntryHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntryHistory
     */
    select?: LogEntryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a LogEntryHistory.
     */
    data: XOR<LogEntryHistoryUpdateInput, LogEntryHistoryUncheckedUpdateInput>
    /**
     * Choose, which LogEntryHistory to update.
     */
    where: LogEntryHistoryWhereUniqueInput
  }

  /**
   * LogEntryHistory updateMany
   */
  export type LogEntryHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogEntryHistories.
     */
    data: XOR<LogEntryHistoryUpdateManyMutationInput, LogEntryHistoryUncheckedUpdateManyInput>
    /**
     * Filter which LogEntryHistories to update
     */
    where?: LogEntryHistoryWhereInput
  }

  /**
   * LogEntryHistory upsert
   */
  export type LogEntryHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntryHistory
     */
    select?: LogEntryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the LogEntryHistory to update in case it exists.
     */
    where: LogEntryHistoryWhereUniqueInput
    /**
     * In case the LogEntryHistory found by the `where` argument doesn't exist, create a new LogEntryHistory with this data.
     */
    create: XOR<LogEntryHistoryCreateInput, LogEntryHistoryUncheckedCreateInput>
    /**
     * In case the LogEntryHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogEntryHistoryUpdateInput, LogEntryHistoryUncheckedUpdateInput>
  }

  /**
   * LogEntryHistory delete
   */
  export type LogEntryHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntryHistory
     */
    select?: LogEntryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryHistoryInclude<ExtArgs> | null
    /**
     * Filter which LogEntryHistory to delete.
     */
    where: LogEntryHistoryWhereUniqueInput
  }

  /**
   * LogEntryHistory deleteMany
   */
  export type LogEntryHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogEntryHistories to delete
     */
    where?: LogEntryHistoryWhereInput
  }

  /**
   * LogEntryHistory.user
   */
  export type LogEntryHistory$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LogEntryHistory without action
   */
  export type LogEntryHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntryHistory
     */
    select?: LogEntryHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    timestamp: Date | null
    authorId: string | null
    logEntryId: string | null
    drawingId: string | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    timestamp: Date | null
    authorId: string | null
    logEntryId: string | null
    drawingId: string | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    content: number
    timestamp: number
    authorId: number
    logEntryId: number
    drawingId: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    content?: true
    timestamp?: true
    authorId?: true
    logEntryId?: true
    drawingId?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    content?: true
    timestamp?: true
    authorId?: true
    logEntryId?: true
    drawingId?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    content?: true
    timestamp?: true
    authorId?: true
    logEntryId?: true
    drawingId?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    content: string
    timestamp: Date
    authorId: string
    logEntryId: string | null
    drawingId: string | null
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    timestamp?: boolean
    authorId?: boolean
    logEntryId?: boolean
    drawingId?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    logEntry?: boolean | Comment$logEntryArgs<ExtArgs>
    drawing?: boolean | Comment$drawingArgs<ExtArgs>
    attachments?: boolean | Comment$attachmentsArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>


  export type CommentSelectScalar = {
    id?: boolean
    content?: boolean
    timestamp?: boolean
    authorId?: boolean
    logEntryId?: boolean
    drawingId?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    logEntry?: boolean | Comment$logEntryArgs<ExtArgs>
    drawing?: boolean | Comment$drawingArgs<ExtArgs>
    attachments?: boolean | Comment$attachmentsArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      logEntry: Prisma.$LogEntryPayload<ExtArgs> | null
      drawing: Prisma.$DrawingPayload<ExtArgs> | null
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      timestamp: Date
      authorId: string
      logEntryId: string | null
      drawingId: string | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    logEntry<T extends Comment$logEntryArgs<ExtArgs> = {}>(args?: Subset<T, Comment$logEntryArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    drawing<T extends Comment$drawingArgs<ExtArgs> = {}>(args?: Subset<T, Comment$drawingArgs<ExtArgs>>): Prisma__DrawingClient<$Result.GetResult<Prisma.$DrawingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    attachments<T extends Comment$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly timestamp: FieldRef<"Comment", 'DateTime'>
    readonly authorId: FieldRef<"Comment", 'String'>
    readonly logEntryId: FieldRef<"Comment", 'String'>
    readonly drawingId: FieldRef<"Comment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment.logEntry
   */
  export type Comment$logEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    where?: LogEntryWhereInput
  }

  /**
   * Comment.drawing
   */
  export type Comment$drawingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drawing
     */
    select?: DrawingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingInclude<ExtArgs> | null
    where?: DrawingWhereInput
  }

  /**
   * Comment.attachments
   */
  export type Comment$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Signature
   */

  export type AggregateSignature = {
    _count: SignatureCountAggregateOutputType | null
    _min: SignatureMinAggregateOutputType | null
    _max: SignatureMaxAggregateOutputType | null
  }

  export type SignatureMinAggregateOutputType = {
    id: string | null
    signedAt: Date | null
    signerId: string | null
    logEntryId: string | null
    actaId: string | null
    reportId: string | null
  }

  export type SignatureMaxAggregateOutputType = {
    id: string | null
    signedAt: Date | null
    signerId: string | null
    logEntryId: string | null
    actaId: string | null
    reportId: string | null
  }

  export type SignatureCountAggregateOutputType = {
    id: number
    signedAt: number
    signerId: number
    logEntryId: number
    actaId: number
    reportId: number
    _all: number
  }


  export type SignatureMinAggregateInputType = {
    id?: true
    signedAt?: true
    signerId?: true
    logEntryId?: true
    actaId?: true
    reportId?: true
  }

  export type SignatureMaxAggregateInputType = {
    id?: true
    signedAt?: true
    signerId?: true
    logEntryId?: true
    actaId?: true
    reportId?: true
  }

  export type SignatureCountAggregateInputType = {
    id?: true
    signedAt?: true
    signerId?: true
    logEntryId?: true
    actaId?: true
    reportId?: true
    _all?: true
  }

  export type SignatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Signature to aggregate.
     */
    where?: SignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signatures to fetch.
     */
    orderBy?: SignatureOrderByWithRelationInput | SignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Signatures
    **/
    _count?: true | SignatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SignatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SignatureMaxAggregateInputType
  }

  export type GetSignatureAggregateType<T extends SignatureAggregateArgs> = {
        [P in keyof T & keyof AggregateSignature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSignature[P]>
      : GetScalarType<T[P], AggregateSignature[P]>
  }




  export type SignatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SignatureWhereInput
    orderBy?: SignatureOrderByWithAggregationInput | SignatureOrderByWithAggregationInput[]
    by: SignatureScalarFieldEnum[] | SignatureScalarFieldEnum
    having?: SignatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SignatureCountAggregateInputType | true
    _min?: SignatureMinAggregateInputType
    _max?: SignatureMaxAggregateInputType
  }

  export type SignatureGroupByOutputType = {
    id: string
    signedAt: Date
    signerId: string
    logEntryId: string | null
    actaId: string | null
    reportId: string | null
    _count: SignatureCountAggregateOutputType | null
    _min: SignatureMinAggregateOutputType | null
    _max: SignatureMaxAggregateOutputType | null
  }

  type GetSignatureGroupByPayload<T extends SignatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SignatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SignatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SignatureGroupByOutputType[P]>
            : GetScalarType<T[P], SignatureGroupByOutputType[P]>
        }
      >
    >


  export type SignatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    signedAt?: boolean
    signerId?: boolean
    logEntryId?: boolean
    actaId?: boolean
    reportId?: boolean
    signer?: boolean | UserDefaultArgs<ExtArgs>
    logEntry?: boolean | Signature$logEntryArgs<ExtArgs>
    acta?: boolean | Signature$actaArgs<ExtArgs>
    report?: boolean | Signature$reportArgs<ExtArgs>
  }, ExtArgs["result"]["signature"]>


  export type SignatureSelectScalar = {
    id?: boolean
    signedAt?: boolean
    signerId?: boolean
    logEntryId?: boolean
    actaId?: boolean
    reportId?: boolean
  }

  export type SignatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    signer?: boolean | UserDefaultArgs<ExtArgs>
    logEntry?: boolean | Signature$logEntryArgs<ExtArgs>
    acta?: boolean | Signature$actaArgs<ExtArgs>
    report?: boolean | Signature$reportArgs<ExtArgs>
  }

  export type $SignaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Signature"
    objects: {
      signer: Prisma.$UserPayload<ExtArgs>
      logEntry: Prisma.$LogEntryPayload<ExtArgs> | null
      acta: Prisma.$ActaPayload<ExtArgs> | null
      report: Prisma.$ReportPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      signedAt: Date
      signerId: string
      logEntryId: string | null
      actaId: string | null
      reportId: string | null
    }, ExtArgs["result"]["signature"]>
    composites: {}
  }

  type SignatureGetPayload<S extends boolean | null | undefined | SignatureDefaultArgs> = $Result.GetResult<Prisma.$SignaturePayload, S>

  type SignatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SignatureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SignatureCountAggregateInputType | true
    }

  export interface SignatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Signature'], meta: { name: 'Signature' } }
    /**
     * Find zero or one Signature that matches the filter.
     * @param {SignatureFindUniqueArgs} args - Arguments to find a Signature
     * @example
     * // Get one Signature
     * const signature = await prisma.signature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SignatureFindUniqueArgs>(args: SelectSubset<T, SignatureFindUniqueArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Signature that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SignatureFindUniqueOrThrowArgs} args - Arguments to find a Signature
     * @example
     * // Get one Signature
     * const signature = await prisma.signature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SignatureFindUniqueOrThrowArgs>(args: SelectSubset<T, SignatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Signature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureFindFirstArgs} args - Arguments to find a Signature
     * @example
     * // Get one Signature
     * const signature = await prisma.signature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SignatureFindFirstArgs>(args?: SelectSubset<T, SignatureFindFirstArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Signature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureFindFirstOrThrowArgs} args - Arguments to find a Signature
     * @example
     * // Get one Signature
     * const signature = await prisma.signature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SignatureFindFirstOrThrowArgs>(args?: SelectSubset<T, SignatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Signatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Signatures
     * const signatures = await prisma.signature.findMany()
     * 
     * // Get first 10 Signatures
     * const signatures = await prisma.signature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const signatureWithIdOnly = await prisma.signature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SignatureFindManyArgs>(args?: SelectSubset<T, SignatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Signature.
     * @param {SignatureCreateArgs} args - Arguments to create a Signature.
     * @example
     * // Create one Signature
     * const Signature = await prisma.signature.create({
     *   data: {
     *     // ... data to create a Signature
     *   }
     * })
     * 
     */
    create<T extends SignatureCreateArgs>(args: SelectSubset<T, SignatureCreateArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Signatures.
     * @param {SignatureCreateManyArgs} args - Arguments to create many Signatures.
     * @example
     * // Create many Signatures
     * const signature = await prisma.signature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SignatureCreateManyArgs>(args?: SelectSubset<T, SignatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Signature.
     * @param {SignatureDeleteArgs} args - Arguments to delete one Signature.
     * @example
     * // Delete one Signature
     * const Signature = await prisma.signature.delete({
     *   where: {
     *     // ... filter to delete one Signature
     *   }
     * })
     * 
     */
    delete<T extends SignatureDeleteArgs>(args: SelectSubset<T, SignatureDeleteArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Signature.
     * @param {SignatureUpdateArgs} args - Arguments to update one Signature.
     * @example
     * // Update one Signature
     * const signature = await prisma.signature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SignatureUpdateArgs>(args: SelectSubset<T, SignatureUpdateArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Signatures.
     * @param {SignatureDeleteManyArgs} args - Arguments to filter Signatures to delete.
     * @example
     * // Delete a few Signatures
     * const { count } = await prisma.signature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SignatureDeleteManyArgs>(args?: SelectSubset<T, SignatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Signatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Signatures
     * const signature = await prisma.signature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SignatureUpdateManyArgs>(args: SelectSubset<T, SignatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Signature.
     * @param {SignatureUpsertArgs} args - Arguments to update or create a Signature.
     * @example
     * // Update or create a Signature
     * const signature = await prisma.signature.upsert({
     *   create: {
     *     // ... data to create a Signature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Signature we want to update
     *   }
     * })
     */
    upsert<T extends SignatureUpsertArgs>(args: SelectSubset<T, SignatureUpsertArgs<ExtArgs>>): Prisma__SignatureClient<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Signatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureCountArgs} args - Arguments to filter Signatures to count.
     * @example
     * // Count the number of Signatures
     * const count = await prisma.signature.count({
     *   where: {
     *     // ... the filter for the Signatures we want to count
     *   }
     * })
    **/
    count<T extends SignatureCountArgs>(
      args?: Subset<T, SignatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SignatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Signature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SignatureAggregateArgs>(args: Subset<T, SignatureAggregateArgs>): Prisma.PrismaPromise<GetSignatureAggregateType<T>>

    /**
     * Group by Signature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SignatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SignatureGroupByArgs['orderBy'] }
        : { orderBy?: SignatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SignatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSignatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Signature model
   */
  readonly fields: SignatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Signature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SignatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    signer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    logEntry<T extends Signature$logEntryArgs<ExtArgs> = {}>(args?: Subset<T, Signature$logEntryArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    acta<T extends Signature$actaArgs<ExtArgs> = {}>(args?: Subset<T, Signature$actaArgs<ExtArgs>>): Prisma__ActaClient<$Result.GetResult<Prisma.$ActaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    report<T extends Signature$reportArgs<ExtArgs> = {}>(args?: Subset<T, Signature$reportArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Signature model
   */ 
  interface SignatureFieldRefs {
    readonly id: FieldRef<"Signature", 'String'>
    readonly signedAt: FieldRef<"Signature", 'DateTime'>
    readonly signerId: FieldRef<"Signature", 'String'>
    readonly logEntryId: FieldRef<"Signature", 'String'>
    readonly actaId: FieldRef<"Signature", 'String'>
    readonly reportId: FieldRef<"Signature", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Signature findUnique
   */
  export type SignatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * Filter, which Signature to fetch.
     */
    where: SignatureWhereUniqueInput
  }

  /**
   * Signature findUniqueOrThrow
   */
  export type SignatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * Filter, which Signature to fetch.
     */
    where: SignatureWhereUniqueInput
  }

  /**
   * Signature findFirst
   */
  export type SignatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * Filter, which Signature to fetch.
     */
    where?: SignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signatures to fetch.
     */
    orderBy?: SignatureOrderByWithRelationInput | SignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Signatures.
     */
    cursor?: SignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Signatures.
     */
    distinct?: SignatureScalarFieldEnum | SignatureScalarFieldEnum[]
  }

  /**
   * Signature findFirstOrThrow
   */
  export type SignatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * Filter, which Signature to fetch.
     */
    where?: SignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signatures to fetch.
     */
    orderBy?: SignatureOrderByWithRelationInput | SignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Signatures.
     */
    cursor?: SignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Signatures.
     */
    distinct?: SignatureScalarFieldEnum | SignatureScalarFieldEnum[]
  }

  /**
   * Signature findMany
   */
  export type SignatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * Filter, which Signatures to fetch.
     */
    where?: SignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Signatures to fetch.
     */
    orderBy?: SignatureOrderByWithRelationInput | SignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Signatures.
     */
    cursor?: SignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Signatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Signatures.
     */
    skip?: number
    distinct?: SignatureScalarFieldEnum | SignatureScalarFieldEnum[]
  }

  /**
   * Signature create
   */
  export type SignatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * The data needed to create a Signature.
     */
    data: XOR<SignatureCreateInput, SignatureUncheckedCreateInput>
  }

  /**
   * Signature createMany
   */
  export type SignatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Signatures.
     */
    data: SignatureCreateManyInput | SignatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Signature update
   */
  export type SignatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * The data needed to update a Signature.
     */
    data: XOR<SignatureUpdateInput, SignatureUncheckedUpdateInput>
    /**
     * Choose, which Signature to update.
     */
    where: SignatureWhereUniqueInput
  }

  /**
   * Signature updateMany
   */
  export type SignatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Signatures.
     */
    data: XOR<SignatureUpdateManyMutationInput, SignatureUncheckedUpdateManyInput>
    /**
     * Filter which Signatures to update
     */
    where?: SignatureWhereInput
  }

  /**
   * Signature upsert
   */
  export type SignatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * The filter to search for the Signature to update in case it exists.
     */
    where: SignatureWhereUniqueInput
    /**
     * In case the Signature found by the `where` argument doesn't exist, create a new Signature with this data.
     */
    create: XOR<SignatureCreateInput, SignatureUncheckedCreateInput>
    /**
     * In case the Signature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SignatureUpdateInput, SignatureUncheckedUpdateInput>
  }

  /**
   * Signature delete
   */
  export type SignatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    /**
     * Filter which Signature to delete.
     */
    where: SignatureWhereUniqueInput
  }

  /**
   * Signature deleteMany
   */
  export type SignatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Signatures to delete
     */
    where?: SignatureWhereInput
  }

  /**
   * Signature.logEntry
   */
  export type Signature$logEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    where?: LogEntryWhereInput
  }

  /**
   * Signature.acta
   */
  export type Signature$actaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acta
     */
    select?: ActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActaInclude<ExtArgs> | null
    where?: ActaWhereInput
  }

  /**
   * Signature.report
   */
  export type Signature$reportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
  }

  /**
   * Signature without action
   */
  export type SignatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
  }


  /**
   * Model Attachment
   */

  export type AggregateAttachment = {
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  export type AttachmentAvgAggregateOutputType = {
    size: number | null
  }

  export type AttachmentSumAggregateOutputType = {
    size: number | null
  }

  export type AttachmentMinAggregateOutputType = {
    id: string | null
    fileName: string | null
    url: string | null
    size: number | null
    type: string | null
    logEntryId: string | null
    communicationId: string | null
    actaId: string | null
    costActaId: string | null
    reportId: string | null
    commentId: string | null
    workActaId: string | null
    weeklyReportId: string | null
    createdAt: Date | null
  }

  export type AttachmentMaxAggregateOutputType = {
    id: string | null
    fileName: string | null
    url: string | null
    size: number | null
    type: string | null
    logEntryId: string | null
    communicationId: string | null
    actaId: string | null
    costActaId: string | null
    reportId: string | null
    commentId: string | null
    workActaId: string | null
    weeklyReportId: string | null
    createdAt: Date | null
  }

  export type AttachmentCountAggregateOutputType = {
    id: number
    fileName: number
    url: number
    size: number
    type: number
    logEntryId: number
    communicationId: number
    actaId: number
    costActaId: number
    reportId: number
    commentId: number
    workActaId: number
    weeklyReportId: number
    createdAt: number
    _all: number
  }


  export type AttachmentAvgAggregateInputType = {
    size?: true
  }

  export type AttachmentSumAggregateInputType = {
    size?: true
  }

  export type AttachmentMinAggregateInputType = {
    id?: true
    fileName?: true
    url?: true
    size?: true
    type?: true
    logEntryId?: true
    communicationId?: true
    actaId?: true
    costActaId?: true
    reportId?: true
    commentId?: true
    workActaId?: true
    weeklyReportId?: true
    createdAt?: true
  }

  export type AttachmentMaxAggregateInputType = {
    id?: true
    fileName?: true
    url?: true
    size?: true
    type?: true
    logEntryId?: true
    communicationId?: true
    actaId?: true
    costActaId?: true
    reportId?: true
    commentId?: true
    workActaId?: true
    weeklyReportId?: true
    createdAt?: true
  }

  export type AttachmentCountAggregateInputType = {
    id?: true
    fileName?: true
    url?: true
    size?: true
    type?: true
    logEntryId?: true
    communicationId?: true
    actaId?: true
    costActaId?: true
    reportId?: true
    commentId?: true
    workActaId?: true
    weeklyReportId?: true
    createdAt?: true
    _all?: true
  }

  export type AttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachment to aggregate.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attachments
    **/
    _count?: true | AttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttachmentMaxAggregateInputType
  }

  export type GetAttachmentAggregateType<T extends AttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttachment[P]>
      : GetScalarType<T[P], AggregateAttachment[P]>
  }




  export type AttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithAggregationInput | AttachmentOrderByWithAggregationInput[]
    by: AttachmentScalarFieldEnum[] | AttachmentScalarFieldEnum
    having?: AttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttachmentCountAggregateInputType | true
    _avg?: AttachmentAvgAggregateInputType
    _sum?: AttachmentSumAggregateInputType
    _min?: AttachmentMinAggregateInputType
    _max?: AttachmentMaxAggregateInputType
  }

  export type AttachmentGroupByOutputType = {
    id: string
    fileName: string
    url: string
    size: number
    type: string
    logEntryId: string | null
    communicationId: string | null
    actaId: string | null
    costActaId: string | null
    reportId: string | null
    commentId: string | null
    workActaId: string | null
    weeklyReportId: string | null
    createdAt: Date
    _count: AttachmentCountAggregateOutputType | null
    _avg: AttachmentAvgAggregateOutputType | null
    _sum: AttachmentSumAggregateOutputType | null
    _min: AttachmentMinAggregateOutputType | null
    _max: AttachmentMaxAggregateOutputType | null
  }

  type GetAttachmentGroupByPayload<T extends AttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], AttachmentGroupByOutputType[P]>
        }
      >
    >


  export type AttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileName?: boolean
    url?: boolean
    size?: boolean
    type?: boolean
    logEntryId?: boolean
    communicationId?: boolean
    actaId?: boolean
    costActaId?: boolean
    reportId?: boolean
    commentId?: boolean
    workActaId?: boolean
    weeklyReportId?: boolean
    createdAt?: boolean
    logEntry?: boolean | Attachment$logEntryArgs<ExtArgs>
    communication?: boolean | Attachment$communicationArgs<ExtArgs>
    acta?: boolean | Attachment$actaArgs<ExtArgs>
    costActa?: boolean | Attachment$costActaArgs<ExtArgs>
    report?: boolean | Attachment$reportArgs<ExtArgs>
    comment?: boolean | Attachment$commentArgs<ExtArgs>
    contractMod?: boolean | Attachment$contractModArgs<ExtArgs>
    workActa?: boolean | Attachment$workActaArgs<ExtArgs>
    weeklyReport?: boolean | Attachment$weeklyReportArgs<ExtArgs>
    photoEntry?: boolean | Attachment$photoEntryArgs<ExtArgs>
  }, ExtArgs["result"]["attachment"]>


  export type AttachmentSelectScalar = {
    id?: boolean
    fileName?: boolean
    url?: boolean
    size?: boolean
    type?: boolean
    logEntryId?: boolean
    communicationId?: boolean
    actaId?: boolean
    costActaId?: boolean
    reportId?: boolean
    commentId?: boolean
    workActaId?: boolean
    weeklyReportId?: boolean
    createdAt?: boolean
  }

  export type AttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logEntry?: boolean | Attachment$logEntryArgs<ExtArgs>
    communication?: boolean | Attachment$communicationArgs<ExtArgs>
    acta?: boolean | Attachment$actaArgs<ExtArgs>
    costActa?: boolean | Attachment$costActaArgs<ExtArgs>
    report?: boolean | Attachment$reportArgs<ExtArgs>
    comment?: boolean | Attachment$commentArgs<ExtArgs>
    contractMod?: boolean | Attachment$contractModArgs<ExtArgs>
    workActa?: boolean | Attachment$workActaArgs<ExtArgs>
    weeklyReport?: boolean | Attachment$weeklyReportArgs<ExtArgs>
    photoEntry?: boolean | Attachment$photoEntryArgs<ExtArgs>
  }

  export type $AttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attachment"
    objects: {
      logEntry: Prisma.$LogEntryPayload<ExtArgs> | null
      communication: Prisma.$CommunicationPayload<ExtArgs> | null
      acta: Prisma.$ActaPayload<ExtArgs> | null
      costActa: Prisma.$CostActaPayload<ExtArgs> | null
      report: Prisma.$ReportPayload<ExtArgs> | null
      comment: Prisma.$CommentPayload<ExtArgs> | null
      contractMod: Prisma.$ContractModificationPayload<ExtArgs> | null
      workActa: Prisma.$WorkActaPayload<ExtArgs> | null
      weeklyReport: Prisma.$WeeklyReportPayload<ExtArgs> | null
      photoEntry: Prisma.$PhotoEntryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fileName: string
      url: string
      size: number
      type: string
      logEntryId: string | null
      communicationId: string | null
      actaId: string | null
      costActaId: string | null
      reportId: string | null
      commentId: string | null
      workActaId: string | null
      weeklyReportId: string | null
      createdAt: Date
    }, ExtArgs["result"]["attachment"]>
    composites: {}
  }

  type AttachmentGetPayload<S extends boolean | null | undefined | AttachmentDefaultArgs> = $Result.GetResult<Prisma.$AttachmentPayload, S>

  type AttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AttachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttachmentCountAggregateInputType | true
    }

  export interface AttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attachment'], meta: { name: 'Attachment' } }
    /**
     * Find zero or one Attachment that matches the filter.
     * @param {AttachmentFindUniqueArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttachmentFindUniqueArgs>(args: SelectSubset<T, AttachmentFindUniqueArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Attachment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AttachmentFindUniqueOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Attachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttachmentFindFirstArgs>(args?: SelectSubset<T, AttachmentFindFirstArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Attachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindFirstOrThrowArgs} args - Arguments to find a Attachment
     * @example
     * // Get one Attachment
     * const attachment = await prisma.attachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Attachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attachments
     * const attachments = await prisma.attachment.findMany()
     * 
     * // Get first 10 Attachments
     * const attachments = await prisma.attachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attachmentWithIdOnly = await prisma.attachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttachmentFindManyArgs>(args?: SelectSubset<T, AttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Attachment.
     * @param {AttachmentCreateArgs} args - Arguments to create a Attachment.
     * @example
     * // Create one Attachment
     * const Attachment = await prisma.attachment.create({
     *   data: {
     *     // ... data to create a Attachment
     *   }
     * })
     * 
     */
    create<T extends AttachmentCreateArgs>(args: SelectSubset<T, AttachmentCreateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Attachments.
     * @param {AttachmentCreateManyArgs} args - Arguments to create many Attachments.
     * @example
     * // Create many Attachments
     * const attachment = await prisma.attachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttachmentCreateManyArgs>(args?: SelectSubset<T, AttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Attachment.
     * @param {AttachmentDeleteArgs} args - Arguments to delete one Attachment.
     * @example
     * // Delete one Attachment
     * const Attachment = await prisma.attachment.delete({
     *   where: {
     *     // ... filter to delete one Attachment
     *   }
     * })
     * 
     */
    delete<T extends AttachmentDeleteArgs>(args: SelectSubset<T, AttachmentDeleteArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Attachment.
     * @param {AttachmentUpdateArgs} args - Arguments to update one Attachment.
     * @example
     * // Update one Attachment
     * const attachment = await prisma.attachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttachmentUpdateArgs>(args: SelectSubset<T, AttachmentUpdateArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Attachments.
     * @param {AttachmentDeleteManyArgs} args - Arguments to filter Attachments to delete.
     * @example
     * // Delete a few Attachments
     * const { count } = await prisma.attachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttachmentDeleteManyArgs>(args?: SelectSubset<T, AttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attachments
     * const attachment = await prisma.attachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttachmentUpdateManyArgs>(args: SelectSubset<T, AttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attachment.
     * @param {AttachmentUpsertArgs} args - Arguments to update or create a Attachment.
     * @example
     * // Update or create a Attachment
     * const attachment = await prisma.attachment.upsert({
     *   create: {
     *     // ... data to create a Attachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attachment we want to update
     *   }
     * })
     */
    upsert<T extends AttachmentUpsertArgs>(args: SelectSubset<T, AttachmentUpsertArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Attachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentCountArgs} args - Arguments to filter Attachments to count.
     * @example
     * // Count the number of Attachments
     * const count = await prisma.attachment.count({
     *   where: {
     *     // ... the filter for the Attachments we want to count
     *   }
     * })
    **/
    count<T extends AttachmentCountArgs>(
      args?: Subset<T, AttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttachmentAggregateArgs>(args: Subset<T, AttachmentAggregateArgs>): Prisma.PrismaPromise<GetAttachmentAggregateType<T>>

    /**
     * Group by Attachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttachmentGroupByArgs['orderBy'] }
        : { orderBy?: AttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attachment model
   */
  readonly fields: AttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    logEntry<T extends Attachment$logEntryArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$logEntryArgs<ExtArgs>>): Prisma__LogEntryClient<$Result.GetResult<Prisma.$LogEntryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    communication<T extends Attachment$communicationArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$communicationArgs<ExtArgs>>): Prisma__CommunicationClient<$Result.GetResult<Prisma.$CommunicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    acta<T extends Attachment$actaArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$actaArgs<ExtArgs>>): Prisma__ActaClient<$Result.GetResult<Prisma.$ActaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    costActa<T extends Attachment$costActaArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$costActaArgs<ExtArgs>>): Prisma__CostActaClient<$Result.GetResult<Prisma.$CostActaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    report<T extends Attachment$reportArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$reportArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    comment<T extends Attachment$commentArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$commentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    contractMod<T extends Attachment$contractModArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$contractModArgs<ExtArgs>>): Prisma__ContractModificationClient<$Result.GetResult<Prisma.$ContractModificationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    workActa<T extends Attachment$workActaArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$workActaArgs<ExtArgs>>): Prisma__WorkActaClient<$Result.GetResult<Prisma.$WorkActaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    weeklyReport<T extends Attachment$weeklyReportArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$weeklyReportArgs<ExtArgs>>): Prisma__WeeklyReportClient<$Result.GetResult<Prisma.$WeeklyReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    photoEntry<T extends Attachment$photoEntryArgs<ExtArgs> = {}>(args?: Subset<T, Attachment$photoEntryArgs<ExtArgs>>): Prisma__PhotoEntryClient<$Result.GetResult<Prisma.$PhotoEntryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attachment model
   */ 
  interface AttachmentFieldRefs {
    readonly id: FieldRef<"Attachment", 'String'>
    readonly fileName: FieldRef<"Attachment", 'String'>
    readonly url: FieldRef<"Attachment", 'String'>
    readonly size: FieldRef<"Attachment", 'Int'>
    readonly type: FieldRef<"Attachment", 'String'>
    readonly logEntryId: FieldRef<"Attachment", 'String'>
    readonly communicationId: FieldRef<"Attachment", 'String'>
    readonly actaId: FieldRef<"Attachment", 'String'>
    readonly costActaId: FieldRef<"Attachment", 'String'>
    readonly reportId: FieldRef<"Attachment", 'String'>
    readonly commentId: FieldRef<"Attachment", 'String'>
    readonly workActaId: FieldRef<"Attachment", 'String'>
    readonly weeklyReportId: FieldRef<"Attachment", 'String'>
    readonly createdAt: FieldRef<"Attachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attachment findUnique
   */
  export type AttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findUniqueOrThrow
   */
  export type AttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment findFirst
   */
  export type AttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findFirstOrThrow
   */
  export type AttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachment to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attachments.
     */
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment findMany
   */
  export type AttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter, which Attachments to fetch.
     */
    where?: AttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attachments to fetch.
     */
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attachments.
     */
    cursor?: AttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attachments.
     */
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Attachment create
   */
  export type AttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Attachment.
     */
    data: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
  }

  /**
   * Attachment createMany
   */
  export type AttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attachments.
     */
    data: AttachmentCreateManyInput | AttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attachment update
   */
  export type AttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Attachment.
     */
    data: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
    /**
     * Choose, which Attachment to update.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment updateMany
   */
  export type AttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attachments.
     */
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyInput>
    /**
     * Filter which Attachments to update
     */
    where?: AttachmentWhereInput
  }

  /**
   * Attachment upsert
   */
  export type AttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Attachment to update in case it exists.
     */
    where: AttachmentWhereUniqueInput
    /**
     * In case the Attachment found by the `where` argument doesn't exist, create a new Attachment with this data.
     */
    create: XOR<AttachmentCreateInput, AttachmentUncheckedCreateInput>
    /**
     * In case the Attachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttachmentUpdateInput, AttachmentUncheckedUpdateInput>
  }

  /**
   * Attachment delete
   */
  export type AttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    /**
     * Filter which Attachment to delete.
     */
    where: AttachmentWhereUniqueInput
  }

  /**
   * Attachment deleteMany
   */
  export type AttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attachments to delete
     */
    where?: AttachmentWhereInput
  }

  /**
   * Attachment.logEntry
   */
  export type Attachment$logEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogEntry
     */
    select?: LogEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogEntryInclude<ExtArgs> | null
    where?: LogEntryWhereInput
  }

  /**
   * Attachment.communication
   */
  export type Attachment$communicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Communication
     */
    select?: CommunicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunicationInclude<ExtArgs> | null
    where?: CommunicationWhereInput
  }

  /**
   * Attachment.acta
   */
  export type Attachment$actaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acta
     */
    select?: ActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActaInclude<ExtArgs> | null
    where?: ActaWhereInput
  }

  /**
   * Attachment.costActa
   */
  export type Attachment$costActaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostActa
     */
    select?: CostActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostActaInclude<ExtArgs> | null
    where?: CostActaWhereInput
  }

  /**
   * Attachment.report
   */
  export type Attachment$reportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
  }

  /**
   * Attachment.comment
   */
  export type Attachment$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Attachment.contractMod
   */
  export type Attachment$contractModArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractModification
     */
    select?: ContractModificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractModificationInclude<ExtArgs> | null
    where?: ContractModificationWhereInput
  }

  /**
   * Attachment.workActa
   */
  export type Attachment$workActaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActa
     */
    select?: WorkActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaInclude<ExtArgs> | null
    where?: WorkActaWhereInput
  }

  /**
   * Attachment.weeklyReport
   */
  export type Attachment$weeklyReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WeeklyReport
     */
    select?: WeeklyReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WeeklyReportInclude<ExtArgs> | null
    where?: WeeklyReportWhereInput
  }

  /**
   * Attachment.photoEntry
   */
  export type Attachment$photoEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoEntry
     */
    select?: PhotoEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoEntryInclude<ExtArgs> | null
    where?: PhotoEntryWhereInput
  }

  /**
   * Attachment without action
   */
  export type AttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
  }


  /**
   * Model Acta
   */

  export type AggregateActa = {
    _count: ActaCountAggregateOutputType | null
    _min: ActaMinAggregateOutputType | null
    _max: ActaMaxAggregateOutputType | null
  }

  export type ActaMinAggregateOutputType = {
    id: string | null
    number: string | null
    title: string | null
    date: Date | null
    area: $Enums.ActaArea | null
    status: $Enums.ActaStatus | null
    summary: string | null
    requiredSignatoriesJson: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActaMaxAggregateOutputType = {
    id: string | null
    number: string | null
    title: string | null
    date: Date | null
    area: $Enums.ActaArea | null
    status: $Enums.ActaStatus | null
    summary: string | null
    requiredSignatoriesJson: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActaCountAggregateOutputType = {
    id: number
    number: number
    title: number
    date: number
    area: number
    status: number
    summary: number
    requiredSignatoriesJson: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActaMinAggregateInputType = {
    id?: true
    number?: true
    title?: true
    date?: true
    area?: true
    status?: true
    summary?: true
    requiredSignatoriesJson?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActaMaxAggregateInputType = {
    id?: true
    number?: true
    title?: true
    date?: true
    area?: true
    status?: true
    summary?: true
    requiredSignatoriesJson?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActaCountAggregateInputType = {
    id?: true
    number?: true
    title?: true
    date?: true
    area?: true
    status?: true
    summary?: true
    requiredSignatoriesJson?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Acta to aggregate.
     */
    where?: ActaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actas to fetch.
     */
    orderBy?: ActaOrderByWithRelationInput | ActaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Actas
    **/
    _count?: true | ActaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActaMaxAggregateInputType
  }

  export type GetActaAggregateType<T extends ActaAggregateArgs> = {
        [P in keyof T & keyof AggregateActa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActa[P]>
      : GetScalarType<T[P], AggregateActa[P]>
  }




  export type ActaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActaWhereInput
    orderBy?: ActaOrderByWithAggregationInput | ActaOrderByWithAggregationInput[]
    by: ActaScalarFieldEnum[] | ActaScalarFieldEnum
    having?: ActaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActaCountAggregateInputType | true
    _min?: ActaMinAggregateInputType
    _max?: ActaMaxAggregateInputType
  }

  export type ActaGroupByOutputType = {
    id: string
    number: string
    title: string
    date: Date
    area: $Enums.ActaArea
    status: $Enums.ActaStatus
    summary: string
    requiredSignatoriesJson: string | null
    createdAt: Date
    updatedAt: Date
    _count: ActaCountAggregateOutputType | null
    _min: ActaMinAggregateOutputType | null
    _max: ActaMaxAggregateOutputType | null
  }

  type GetActaGroupByPayload<T extends ActaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActaGroupByOutputType[P]>
            : GetScalarType<T[P], ActaGroupByOutputType[P]>
        }
      >
    >


  export type ActaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    title?: boolean
    date?: boolean
    area?: boolean
    status?: boolean
    summary?: boolean
    requiredSignatoriesJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    attachments?: boolean | Acta$attachmentsArgs<ExtArgs>
    signatures?: boolean | Acta$signaturesArgs<ExtArgs>
    commitments?: boolean | Acta$commitmentsArgs<ExtArgs>
    _count?: boolean | ActaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["acta"]>


  export type ActaSelectScalar = {
    id?: boolean
    number?: boolean
    title?: boolean
    date?: boolean
    area?: boolean
    status?: boolean
    summary?: boolean
    requiredSignatoriesJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ActaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | Acta$attachmentsArgs<ExtArgs>
    signatures?: boolean | Acta$signaturesArgs<ExtArgs>
    commitments?: boolean | Acta$commitmentsArgs<ExtArgs>
    _count?: boolean | ActaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ActaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Acta"
    objects: {
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
      signatures: Prisma.$SignaturePayload<ExtArgs>[]
      commitments: Prisma.$CommitmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      number: string
      title: string
      date: Date
      area: $Enums.ActaArea
      status: $Enums.ActaStatus
      summary: string
      requiredSignatoriesJson: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["acta"]>
    composites: {}
  }

  type ActaGetPayload<S extends boolean | null | undefined | ActaDefaultArgs> = $Result.GetResult<Prisma.$ActaPayload, S>

  type ActaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActaCountAggregateInputType | true
    }

  export interface ActaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Acta'], meta: { name: 'Acta' } }
    /**
     * Find zero or one Acta that matches the filter.
     * @param {ActaFindUniqueArgs} args - Arguments to find a Acta
     * @example
     * // Get one Acta
     * const acta = await prisma.acta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActaFindUniqueArgs>(args: SelectSubset<T, ActaFindUniqueArgs<ExtArgs>>): Prisma__ActaClient<$Result.GetResult<Prisma.$ActaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Acta that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActaFindUniqueOrThrowArgs} args - Arguments to find a Acta
     * @example
     * // Get one Acta
     * const acta = await prisma.acta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActaFindUniqueOrThrowArgs>(args: SelectSubset<T, ActaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActaClient<$Result.GetResult<Prisma.$ActaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Acta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActaFindFirstArgs} args - Arguments to find a Acta
     * @example
     * // Get one Acta
     * const acta = await prisma.acta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActaFindFirstArgs>(args?: SelectSubset<T, ActaFindFirstArgs<ExtArgs>>): Prisma__ActaClient<$Result.GetResult<Prisma.$ActaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Acta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActaFindFirstOrThrowArgs} args - Arguments to find a Acta
     * @example
     * // Get one Acta
     * const acta = await prisma.acta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActaFindFirstOrThrowArgs>(args?: SelectSubset<T, ActaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActaClient<$Result.GetResult<Prisma.$ActaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Actas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actas
     * const actas = await prisma.acta.findMany()
     * 
     * // Get first 10 Actas
     * const actas = await prisma.acta.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actaWithIdOnly = await prisma.acta.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActaFindManyArgs>(args?: SelectSubset<T, ActaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Acta.
     * @param {ActaCreateArgs} args - Arguments to create a Acta.
     * @example
     * // Create one Acta
     * const Acta = await prisma.acta.create({
     *   data: {
     *     // ... data to create a Acta
     *   }
     * })
     * 
     */
    create<T extends ActaCreateArgs>(args: SelectSubset<T, ActaCreateArgs<ExtArgs>>): Prisma__ActaClient<$Result.GetResult<Prisma.$ActaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Actas.
     * @param {ActaCreateManyArgs} args - Arguments to create many Actas.
     * @example
     * // Create many Actas
     * const acta = await prisma.acta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActaCreateManyArgs>(args?: SelectSubset<T, ActaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Acta.
     * @param {ActaDeleteArgs} args - Arguments to delete one Acta.
     * @example
     * // Delete one Acta
     * const Acta = await prisma.acta.delete({
     *   where: {
     *     // ... filter to delete one Acta
     *   }
     * })
     * 
     */
    delete<T extends ActaDeleteArgs>(args: SelectSubset<T, ActaDeleteArgs<ExtArgs>>): Prisma__ActaClient<$Result.GetResult<Prisma.$ActaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Acta.
     * @param {ActaUpdateArgs} args - Arguments to update one Acta.
     * @example
     * // Update one Acta
     * const acta = await prisma.acta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActaUpdateArgs>(args: SelectSubset<T, ActaUpdateArgs<ExtArgs>>): Prisma__ActaClient<$Result.GetResult<Prisma.$ActaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Actas.
     * @param {ActaDeleteManyArgs} args - Arguments to filter Actas to delete.
     * @example
     * // Delete a few Actas
     * const { count } = await prisma.acta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActaDeleteManyArgs>(args?: SelectSubset<T, ActaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actas
     * const acta = await prisma.acta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActaUpdateManyArgs>(args: SelectSubset<T, ActaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Acta.
     * @param {ActaUpsertArgs} args - Arguments to update or create a Acta.
     * @example
     * // Update or create a Acta
     * const acta = await prisma.acta.upsert({
     *   create: {
     *     // ... data to create a Acta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Acta we want to update
     *   }
     * })
     */
    upsert<T extends ActaUpsertArgs>(args: SelectSubset<T, ActaUpsertArgs<ExtArgs>>): Prisma__ActaClient<$Result.GetResult<Prisma.$ActaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Actas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActaCountArgs} args - Arguments to filter Actas to count.
     * @example
     * // Count the number of Actas
     * const count = await prisma.acta.count({
     *   where: {
     *     // ... the filter for the Actas we want to count
     *   }
     * })
    **/
    count<T extends ActaCountArgs>(
      args?: Subset<T, ActaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Acta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActaAggregateArgs>(args: Subset<T, ActaAggregateArgs>): Prisma.PrismaPromise<GetActaAggregateType<T>>

    /**
     * Group by Acta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActaGroupByArgs['orderBy'] }
        : { orderBy?: ActaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Acta model
   */
  readonly fields: ActaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Acta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attachments<T extends Acta$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Acta$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    signatures<T extends Acta$signaturesArgs<ExtArgs> = {}>(args?: Subset<T, Acta$signaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findMany"> | Null>
    commitments<T extends Acta$commitmentsArgs<ExtArgs> = {}>(args?: Subset<T, Acta$commitmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommitmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Acta model
   */ 
  interface ActaFieldRefs {
    readonly id: FieldRef<"Acta", 'String'>
    readonly number: FieldRef<"Acta", 'String'>
    readonly title: FieldRef<"Acta", 'String'>
    readonly date: FieldRef<"Acta", 'DateTime'>
    readonly area: FieldRef<"Acta", 'ActaArea'>
    readonly status: FieldRef<"Acta", 'ActaStatus'>
    readonly summary: FieldRef<"Acta", 'String'>
    readonly requiredSignatoriesJson: FieldRef<"Acta", 'String'>
    readonly createdAt: FieldRef<"Acta", 'DateTime'>
    readonly updatedAt: FieldRef<"Acta", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Acta findUnique
   */
  export type ActaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acta
     */
    select?: ActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActaInclude<ExtArgs> | null
    /**
     * Filter, which Acta to fetch.
     */
    where: ActaWhereUniqueInput
  }

  /**
   * Acta findUniqueOrThrow
   */
  export type ActaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acta
     */
    select?: ActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActaInclude<ExtArgs> | null
    /**
     * Filter, which Acta to fetch.
     */
    where: ActaWhereUniqueInput
  }

  /**
   * Acta findFirst
   */
  export type ActaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acta
     */
    select?: ActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActaInclude<ExtArgs> | null
    /**
     * Filter, which Acta to fetch.
     */
    where?: ActaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actas to fetch.
     */
    orderBy?: ActaOrderByWithRelationInput | ActaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actas.
     */
    cursor?: ActaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actas.
     */
    distinct?: ActaScalarFieldEnum | ActaScalarFieldEnum[]
  }

  /**
   * Acta findFirstOrThrow
   */
  export type ActaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acta
     */
    select?: ActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActaInclude<ExtArgs> | null
    /**
     * Filter, which Acta to fetch.
     */
    where?: ActaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actas to fetch.
     */
    orderBy?: ActaOrderByWithRelationInput | ActaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actas.
     */
    cursor?: ActaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actas.
     */
    distinct?: ActaScalarFieldEnum | ActaScalarFieldEnum[]
  }

  /**
   * Acta findMany
   */
  export type ActaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acta
     */
    select?: ActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActaInclude<ExtArgs> | null
    /**
     * Filter, which Actas to fetch.
     */
    where?: ActaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actas to fetch.
     */
    orderBy?: ActaOrderByWithRelationInput | ActaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Actas.
     */
    cursor?: ActaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actas.
     */
    skip?: number
    distinct?: ActaScalarFieldEnum | ActaScalarFieldEnum[]
  }

  /**
   * Acta create
   */
  export type ActaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acta
     */
    select?: ActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActaInclude<ExtArgs> | null
    /**
     * The data needed to create a Acta.
     */
    data: XOR<ActaCreateInput, ActaUncheckedCreateInput>
  }

  /**
   * Acta createMany
   */
  export type ActaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Actas.
     */
    data: ActaCreateManyInput | ActaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Acta update
   */
  export type ActaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acta
     */
    select?: ActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActaInclude<ExtArgs> | null
    /**
     * The data needed to update a Acta.
     */
    data: XOR<ActaUpdateInput, ActaUncheckedUpdateInput>
    /**
     * Choose, which Acta to update.
     */
    where: ActaWhereUniqueInput
  }

  /**
   * Acta updateMany
   */
  export type ActaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Actas.
     */
    data: XOR<ActaUpdateManyMutationInput, ActaUncheckedUpdateManyInput>
    /**
     * Filter which Actas to update
     */
    where?: ActaWhereInput
  }

  /**
   * Acta upsert
   */
  export type ActaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acta
     */
    select?: ActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActaInclude<ExtArgs> | null
    /**
     * The filter to search for the Acta to update in case it exists.
     */
    where: ActaWhereUniqueInput
    /**
     * In case the Acta found by the `where` argument doesn't exist, create a new Acta with this data.
     */
    create: XOR<ActaCreateInput, ActaUncheckedCreateInput>
    /**
     * In case the Acta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActaUpdateInput, ActaUncheckedUpdateInput>
  }

  /**
   * Acta delete
   */
  export type ActaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acta
     */
    select?: ActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActaInclude<ExtArgs> | null
    /**
     * Filter which Acta to delete.
     */
    where: ActaWhereUniqueInput
  }

  /**
   * Acta deleteMany
   */
  export type ActaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Actas to delete
     */
    where?: ActaWhereInput
  }

  /**
   * Acta.attachments
   */
  export type Acta$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Acta.signatures
   */
  export type Acta$signaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    where?: SignatureWhereInput
    orderBy?: SignatureOrderByWithRelationInput | SignatureOrderByWithRelationInput[]
    cursor?: SignatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SignatureScalarFieldEnum | SignatureScalarFieldEnum[]
  }

  /**
   * Acta.commitments
   */
  export type Acta$commitmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commitment
     */
    select?: CommitmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitmentInclude<ExtArgs> | null
    where?: CommitmentWhereInput
    orderBy?: CommitmentOrderByWithRelationInput | CommitmentOrderByWithRelationInput[]
    cursor?: CommitmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommitmentScalarFieldEnum | CommitmentScalarFieldEnum[]
  }

  /**
   * Acta without action
   */
  export type ActaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Acta
     */
    select?: ActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActaInclude<ExtArgs> | null
  }


  /**
   * Model Commitment
   */

  export type AggregateCommitment = {
    _count: CommitmentCountAggregateOutputType | null
    _min: CommitmentMinAggregateOutputType | null
    _max: CommitmentMaxAggregateOutputType | null
  }

  export type CommitmentMinAggregateOutputType = {
    id: string | null
    description: string | null
    dueDate: Date | null
    status: $Enums.CommitmentStatus | null
    responsibleId: string | null
    actaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommitmentMaxAggregateOutputType = {
    id: string | null
    description: string | null
    dueDate: Date | null
    status: $Enums.CommitmentStatus | null
    responsibleId: string | null
    actaId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommitmentCountAggregateOutputType = {
    id: number
    description: number
    dueDate: number
    status: number
    responsibleId: number
    actaId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommitmentMinAggregateInputType = {
    id?: true
    description?: true
    dueDate?: true
    status?: true
    responsibleId?: true
    actaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommitmentMaxAggregateInputType = {
    id?: true
    description?: true
    dueDate?: true
    status?: true
    responsibleId?: true
    actaId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommitmentCountAggregateInputType = {
    id?: true
    description?: true
    dueDate?: true
    status?: true
    responsibleId?: true
    actaId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommitmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commitment to aggregate.
     */
    where?: CommitmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commitments to fetch.
     */
    orderBy?: CommitmentOrderByWithRelationInput | CommitmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommitmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commitments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commitments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Commitments
    **/
    _count?: true | CommitmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommitmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommitmentMaxAggregateInputType
  }

  export type GetCommitmentAggregateType<T extends CommitmentAggregateArgs> = {
        [P in keyof T & keyof AggregateCommitment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommitment[P]>
      : GetScalarType<T[P], AggregateCommitment[P]>
  }




  export type CommitmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommitmentWhereInput
    orderBy?: CommitmentOrderByWithAggregationInput | CommitmentOrderByWithAggregationInput[]
    by: CommitmentScalarFieldEnum[] | CommitmentScalarFieldEnum
    having?: CommitmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommitmentCountAggregateInputType | true
    _min?: CommitmentMinAggregateInputType
    _max?: CommitmentMaxAggregateInputType
  }

  export type CommitmentGroupByOutputType = {
    id: string
    description: string
    dueDate: Date
    status: $Enums.CommitmentStatus
    responsibleId: string
    actaId: string
    createdAt: Date
    updatedAt: Date
    _count: CommitmentCountAggregateOutputType | null
    _min: CommitmentMinAggregateOutputType | null
    _max: CommitmentMaxAggregateOutputType | null
  }

  type GetCommitmentGroupByPayload<T extends CommitmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommitmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommitmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommitmentGroupByOutputType[P]>
            : GetScalarType<T[P], CommitmentGroupByOutputType[P]>
        }
      >
    >


  export type CommitmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    dueDate?: boolean
    status?: boolean
    responsibleId?: boolean
    actaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    responsible?: boolean | UserDefaultArgs<ExtArgs>
    acta?: boolean | ActaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commitment"]>


  export type CommitmentSelectScalar = {
    id?: boolean
    description?: boolean
    dueDate?: boolean
    status?: boolean
    responsibleId?: boolean
    actaId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommitmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsible?: boolean | UserDefaultArgs<ExtArgs>
    acta?: boolean | ActaDefaultArgs<ExtArgs>
  }

  export type $CommitmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Commitment"
    objects: {
      responsible: Prisma.$UserPayload<ExtArgs>
      acta: Prisma.$ActaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      dueDate: Date
      status: $Enums.CommitmentStatus
      responsibleId: string
      actaId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["commitment"]>
    composites: {}
  }

  type CommitmentGetPayload<S extends boolean | null | undefined | CommitmentDefaultArgs> = $Result.GetResult<Prisma.$CommitmentPayload, S>

  type CommitmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommitmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommitmentCountAggregateInputType | true
    }

  export interface CommitmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Commitment'], meta: { name: 'Commitment' } }
    /**
     * Find zero or one Commitment that matches the filter.
     * @param {CommitmentFindUniqueArgs} args - Arguments to find a Commitment
     * @example
     * // Get one Commitment
     * const commitment = await prisma.commitment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommitmentFindUniqueArgs>(args: SelectSubset<T, CommitmentFindUniqueArgs<ExtArgs>>): Prisma__CommitmentClient<$Result.GetResult<Prisma.$CommitmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Commitment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommitmentFindUniqueOrThrowArgs} args - Arguments to find a Commitment
     * @example
     * // Get one Commitment
     * const commitment = await prisma.commitment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommitmentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommitmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommitmentClient<$Result.GetResult<Prisma.$CommitmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Commitment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommitmentFindFirstArgs} args - Arguments to find a Commitment
     * @example
     * // Get one Commitment
     * const commitment = await prisma.commitment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommitmentFindFirstArgs>(args?: SelectSubset<T, CommitmentFindFirstArgs<ExtArgs>>): Prisma__CommitmentClient<$Result.GetResult<Prisma.$CommitmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Commitment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommitmentFindFirstOrThrowArgs} args - Arguments to find a Commitment
     * @example
     * // Get one Commitment
     * const commitment = await prisma.commitment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommitmentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommitmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommitmentClient<$Result.GetResult<Prisma.$CommitmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Commitments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommitmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commitments
     * const commitments = await prisma.commitment.findMany()
     * 
     * // Get first 10 Commitments
     * const commitments = await prisma.commitment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commitmentWithIdOnly = await prisma.commitment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommitmentFindManyArgs>(args?: SelectSubset<T, CommitmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommitmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Commitment.
     * @param {CommitmentCreateArgs} args - Arguments to create a Commitment.
     * @example
     * // Create one Commitment
     * const Commitment = await prisma.commitment.create({
     *   data: {
     *     // ... data to create a Commitment
     *   }
     * })
     * 
     */
    create<T extends CommitmentCreateArgs>(args: SelectSubset<T, CommitmentCreateArgs<ExtArgs>>): Prisma__CommitmentClient<$Result.GetResult<Prisma.$CommitmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Commitments.
     * @param {CommitmentCreateManyArgs} args - Arguments to create many Commitments.
     * @example
     * // Create many Commitments
     * const commitment = await prisma.commitment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommitmentCreateManyArgs>(args?: SelectSubset<T, CommitmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Commitment.
     * @param {CommitmentDeleteArgs} args - Arguments to delete one Commitment.
     * @example
     * // Delete one Commitment
     * const Commitment = await prisma.commitment.delete({
     *   where: {
     *     // ... filter to delete one Commitment
     *   }
     * })
     * 
     */
    delete<T extends CommitmentDeleteArgs>(args: SelectSubset<T, CommitmentDeleteArgs<ExtArgs>>): Prisma__CommitmentClient<$Result.GetResult<Prisma.$CommitmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Commitment.
     * @param {CommitmentUpdateArgs} args - Arguments to update one Commitment.
     * @example
     * // Update one Commitment
     * const commitment = await prisma.commitment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommitmentUpdateArgs>(args: SelectSubset<T, CommitmentUpdateArgs<ExtArgs>>): Prisma__CommitmentClient<$Result.GetResult<Prisma.$CommitmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Commitments.
     * @param {CommitmentDeleteManyArgs} args - Arguments to filter Commitments to delete.
     * @example
     * // Delete a few Commitments
     * const { count } = await prisma.commitment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommitmentDeleteManyArgs>(args?: SelectSubset<T, CommitmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commitments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommitmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commitments
     * const commitment = await prisma.commitment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommitmentUpdateManyArgs>(args: SelectSubset<T, CommitmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Commitment.
     * @param {CommitmentUpsertArgs} args - Arguments to update or create a Commitment.
     * @example
     * // Update or create a Commitment
     * const commitment = await prisma.commitment.upsert({
     *   create: {
     *     // ... data to create a Commitment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Commitment we want to update
     *   }
     * })
     */
    upsert<T extends CommitmentUpsertArgs>(args: SelectSubset<T, CommitmentUpsertArgs<ExtArgs>>): Prisma__CommitmentClient<$Result.GetResult<Prisma.$CommitmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Commitments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommitmentCountArgs} args - Arguments to filter Commitments to count.
     * @example
     * // Count the number of Commitments
     * const count = await prisma.commitment.count({
     *   where: {
     *     // ... the filter for the Commitments we want to count
     *   }
     * })
    **/
    count<T extends CommitmentCountArgs>(
      args?: Subset<T, CommitmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommitmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Commitment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommitmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommitmentAggregateArgs>(args: Subset<T, CommitmentAggregateArgs>): Prisma.PrismaPromise<GetCommitmentAggregateType<T>>

    /**
     * Group by Commitment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommitmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommitmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommitmentGroupByArgs['orderBy'] }
        : { orderBy?: CommitmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommitmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommitmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Commitment model
   */
  readonly fields: CommitmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Commitment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommitmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    responsible<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    acta<T extends ActaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ActaDefaultArgs<ExtArgs>>): Prisma__ActaClient<$Result.GetResult<Prisma.$ActaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Commitment model
   */ 
  interface CommitmentFieldRefs {
    readonly id: FieldRef<"Commitment", 'String'>
    readonly description: FieldRef<"Commitment", 'String'>
    readonly dueDate: FieldRef<"Commitment", 'DateTime'>
    readonly status: FieldRef<"Commitment", 'CommitmentStatus'>
    readonly responsibleId: FieldRef<"Commitment", 'String'>
    readonly actaId: FieldRef<"Commitment", 'String'>
    readonly createdAt: FieldRef<"Commitment", 'DateTime'>
    readonly updatedAt: FieldRef<"Commitment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Commitment findUnique
   */
  export type CommitmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commitment
     */
    select?: CommitmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitmentInclude<ExtArgs> | null
    /**
     * Filter, which Commitment to fetch.
     */
    where: CommitmentWhereUniqueInput
  }

  /**
   * Commitment findUniqueOrThrow
   */
  export type CommitmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commitment
     */
    select?: CommitmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitmentInclude<ExtArgs> | null
    /**
     * Filter, which Commitment to fetch.
     */
    where: CommitmentWhereUniqueInput
  }

  /**
   * Commitment findFirst
   */
  export type CommitmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commitment
     */
    select?: CommitmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitmentInclude<ExtArgs> | null
    /**
     * Filter, which Commitment to fetch.
     */
    where?: CommitmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commitments to fetch.
     */
    orderBy?: CommitmentOrderByWithRelationInput | CommitmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commitments.
     */
    cursor?: CommitmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commitments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commitments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commitments.
     */
    distinct?: CommitmentScalarFieldEnum | CommitmentScalarFieldEnum[]
  }

  /**
   * Commitment findFirstOrThrow
   */
  export type CommitmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commitment
     */
    select?: CommitmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitmentInclude<ExtArgs> | null
    /**
     * Filter, which Commitment to fetch.
     */
    where?: CommitmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commitments to fetch.
     */
    orderBy?: CommitmentOrderByWithRelationInput | CommitmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commitments.
     */
    cursor?: CommitmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commitments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commitments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commitments.
     */
    distinct?: CommitmentScalarFieldEnum | CommitmentScalarFieldEnum[]
  }

  /**
   * Commitment findMany
   */
  export type CommitmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commitment
     */
    select?: CommitmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitmentInclude<ExtArgs> | null
    /**
     * Filter, which Commitments to fetch.
     */
    where?: CommitmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commitments to fetch.
     */
    orderBy?: CommitmentOrderByWithRelationInput | CommitmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Commitments.
     */
    cursor?: CommitmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commitments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commitments.
     */
    skip?: number
    distinct?: CommitmentScalarFieldEnum | CommitmentScalarFieldEnum[]
  }

  /**
   * Commitment create
   */
  export type CommitmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commitment
     */
    select?: CommitmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Commitment.
     */
    data: XOR<CommitmentCreateInput, CommitmentUncheckedCreateInput>
  }

  /**
   * Commitment createMany
   */
  export type CommitmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Commitments.
     */
    data: CommitmentCreateManyInput | CommitmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Commitment update
   */
  export type CommitmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commitment
     */
    select?: CommitmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Commitment.
     */
    data: XOR<CommitmentUpdateInput, CommitmentUncheckedUpdateInput>
    /**
     * Choose, which Commitment to update.
     */
    where: CommitmentWhereUniqueInput
  }

  /**
   * Commitment updateMany
   */
  export type CommitmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Commitments.
     */
    data: XOR<CommitmentUpdateManyMutationInput, CommitmentUncheckedUpdateManyInput>
    /**
     * Filter which Commitments to update
     */
    where?: CommitmentWhereInput
  }

  /**
   * Commitment upsert
   */
  export type CommitmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commitment
     */
    select?: CommitmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Commitment to update in case it exists.
     */
    where: CommitmentWhereUniqueInput
    /**
     * In case the Commitment found by the `where` argument doesn't exist, create a new Commitment with this data.
     */
    create: XOR<CommitmentCreateInput, CommitmentUncheckedCreateInput>
    /**
     * In case the Commitment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommitmentUpdateInput, CommitmentUncheckedUpdateInput>
  }

  /**
   * Commitment delete
   */
  export type CommitmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commitment
     */
    select?: CommitmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitmentInclude<ExtArgs> | null
    /**
     * Filter which Commitment to delete.
     */
    where: CommitmentWhereUniqueInput
  }

  /**
   * Commitment deleteMany
   */
  export type CommitmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commitments to delete
     */
    where?: CommitmentWhereInput
  }

  /**
   * Commitment without action
   */
  export type CommitmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commitment
     */
    select?: CommitmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommitmentInclude<ExtArgs> | null
  }


  /**
   * Model CostActa
   */

  export type AggregateCostActa = {
    _count: CostActaCountAggregateOutputType | null
    _avg: CostActaAvgAggregateOutputType | null
    _sum: CostActaSumAggregateOutputType | null
    _min: CostActaMinAggregateOutputType | null
    _max: CostActaMaxAggregateOutputType | null
  }

  export type CostActaAvgAggregateOutputType = {
    billedAmount: number | null
    totalContractValue: number | null
  }

  export type CostActaSumAggregateOutputType = {
    billedAmount: number | null
    totalContractValue: number | null
  }

  export type CostActaMinAggregateOutputType = {
    id: string | null
    number: string | null
    period: string | null
    submissionDate: Date | null
    approvalDate: Date | null
    paymentDueDate: Date | null
    billedAmount: number | null
    totalContractValue: number | null
    status: $Enums.CostActaStatus | null
    relatedProgress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostActaMaxAggregateOutputType = {
    id: string | null
    number: string | null
    period: string | null
    submissionDate: Date | null
    approvalDate: Date | null
    paymentDueDate: Date | null
    billedAmount: number | null
    totalContractValue: number | null
    status: $Enums.CostActaStatus | null
    relatedProgress: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostActaCountAggregateOutputType = {
    id: number
    number: number
    period: number
    submissionDate: number
    approvalDate: number
    paymentDueDate: number
    billedAmount: number
    totalContractValue: number
    status: number
    relatedProgress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CostActaAvgAggregateInputType = {
    billedAmount?: true
    totalContractValue?: true
  }

  export type CostActaSumAggregateInputType = {
    billedAmount?: true
    totalContractValue?: true
  }

  export type CostActaMinAggregateInputType = {
    id?: true
    number?: true
    period?: true
    submissionDate?: true
    approvalDate?: true
    paymentDueDate?: true
    billedAmount?: true
    totalContractValue?: true
    status?: true
    relatedProgress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostActaMaxAggregateInputType = {
    id?: true
    number?: true
    period?: true
    submissionDate?: true
    approvalDate?: true
    paymentDueDate?: true
    billedAmount?: true
    totalContractValue?: true
    status?: true
    relatedProgress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostActaCountAggregateInputType = {
    id?: true
    number?: true
    period?: true
    submissionDate?: true
    approvalDate?: true
    paymentDueDate?: true
    billedAmount?: true
    totalContractValue?: true
    status?: true
    relatedProgress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CostActaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostActa to aggregate.
     */
    where?: CostActaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostActas to fetch.
     */
    orderBy?: CostActaOrderByWithRelationInput | CostActaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostActaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostActas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostActas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CostActas
    **/
    _count?: true | CostActaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostActaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostActaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostActaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostActaMaxAggregateInputType
  }

  export type GetCostActaAggregateType<T extends CostActaAggregateArgs> = {
        [P in keyof T & keyof AggregateCostActa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostActa[P]>
      : GetScalarType<T[P], AggregateCostActa[P]>
  }




  export type CostActaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostActaWhereInput
    orderBy?: CostActaOrderByWithAggregationInput | CostActaOrderByWithAggregationInput[]
    by: CostActaScalarFieldEnum[] | CostActaScalarFieldEnum
    having?: CostActaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostActaCountAggregateInputType | true
    _avg?: CostActaAvgAggregateInputType
    _sum?: CostActaSumAggregateInputType
    _min?: CostActaMinAggregateInputType
    _max?: CostActaMaxAggregateInputType
  }

  export type CostActaGroupByOutputType = {
    id: string
    number: string
    period: string
    submissionDate: Date
    approvalDate: Date | null
    paymentDueDate: Date | null
    billedAmount: number
    totalContractValue: number
    status: $Enums.CostActaStatus
    relatedProgress: string | null
    createdAt: Date
    updatedAt: Date
    _count: CostActaCountAggregateOutputType | null
    _avg: CostActaAvgAggregateOutputType | null
    _sum: CostActaSumAggregateOutputType | null
    _min: CostActaMinAggregateOutputType | null
    _max: CostActaMaxAggregateOutputType | null
  }

  type GetCostActaGroupByPayload<T extends CostActaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CostActaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostActaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostActaGroupByOutputType[P]>
            : GetScalarType<T[P], CostActaGroupByOutputType[P]>
        }
      >
    >


  export type CostActaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    period?: boolean
    submissionDate?: boolean
    approvalDate?: boolean
    paymentDueDate?: boolean
    billedAmount?: boolean
    totalContractValue?: boolean
    status?: boolean
    relatedProgress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    observations?: boolean | CostActa$observationsArgs<ExtArgs>
    attachments?: boolean | CostActa$attachmentsArgs<ExtArgs>
    _count?: boolean | CostActaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costActa"]>


  export type CostActaSelectScalar = {
    id?: boolean
    number?: boolean
    period?: boolean
    submissionDate?: boolean
    approvalDate?: boolean
    paymentDueDate?: boolean
    billedAmount?: boolean
    totalContractValue?: boolean
    status?: boolean
    relatedProgress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CostActaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    observations?: boolean | CostActa$observationsArgs<ExtArgs>
    attachments?: boolean | CostActa$attachmentsArgs<ExtArgs>
    _count?: boolean | CostActaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CostActaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CostActa"
    objects: {
      observations: Prisma.$ObservationPayload<ExtArgs>[]
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      number: string
      period: string
      submissionDate: Date
      approvalDate: Date | null
      paymentDueDate: Date | null
      billedAmount: number
      totalContractValue: number
      status: $Enums.CostActaStatus
      relatedProgress: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["costActa"]>
    composites: {}
  }

  type CostActaGetPayload<S extends boolean | null | undefined | CostActaDefaultArgs> = $Result.GetResult<Prisma.$CostActaPayload, S>

  type CostActaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CostActaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CostActaCountAggregateInputType | true
    }

  export interface CostActaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CostActa'], meta: { name: 'CostActa' } }
    /**
     * Find zero or one CostActa that matches the filter.
     * @param {CostActaFindUniqueArgs} args - Arguments to find a CostActa
     * @example
     * // Get one CostActa
     * const costActa = await prisma.costActa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CostActaFindUniqueArgs>(args: SelectSubset<T, CostActaFindUniqueArgs<ExtArgs>>): Prisma__CostActaClient<$Result.GetResult<Prisma.$CostActaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CostActa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CostActaFindUniqueOrThrowArgs} args - Arguments to find a CostActa
     * @example
     * // Get one CostActa
     * const costActa = await prisma.costActa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CostActaFindUniqueOrThrowArgs>(args: SelectSubset<T, CostActaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CostActaClient<$Result.GetResult<Prisma.$CostActaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CostActa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostActaFindFirstArgs} args - Arguments to find a CostActa
     * @example
     * // Get one CostActa
     * const costActa = await prisma.costActa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CostActaFindFirstArgs>(args?: SelectSubset<T, CostActaFindFirstArgs<ExtArgs>>): Prisma__CostActaClient<$Result.GetResult<Prisma.$CostActaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CostActa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostActaFindFirstOrThrowArgs} args - Arguments to find a CostActa
     * @example
     * // Get one CostActa
     * const costActa = await prisma.costActa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CostActaFindFirstOrThrowArgs>(args?: SelectSubset<T, CostActaFindFirstOrThrowArgs<ExtArgs>>): Prisma__CostActaClient<$Result.GetResult<Prisma.$CostActaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CostActas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostActaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CostActas
     * const costActas = await prisma.costActa.findMany()
     * 
     * // Get first 10 CostActas
     * const costActas = await prisma.costActa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costActaWithIdOnly = await prisma.costActa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CostActaFindManyArgs>(args?: SelectSubset<T, CostActaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostActaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CostActa.
     * @param {CostActaCreateArgs} args - Arguments to create a CostActa.
     * @example
     * // Create one CostActa
     * const CostActa = await prisma.costActa.create({
     *   data: {
     *     // ... data to create a CostActa
     *   }
     * })
     * 
     */
    create<T extends CostActaCreateArgs>(args: SelectSubset<T, CostActaCreateArgs<ExtArgs>>): Prisma__CostActaClient<$Result.GetResult<Prisma.$CostActaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CostActas.
     * @param {CostActaCreateManyArgs} args - Arguments to create many CostActas.
     * @example
     * // Create many CostActas
     * const costActa = await prisma.costActa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CostActaCreateManyArgs>(args?: SelectSubset<T, CostActaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CostActa.
     * @param {CostActaDeleteArgs} args - Arguments to delete one CostActa.
     * @example
     * // Delete one CostActa
     * const CostActa = await prisma.costActa.delete({
     *   where: {
     *     // ... filter to delete one CostActa
     *   }
     * })
     * 
     */
    delete<T extends CostActaDeleteArgs>(args: SelectSubset<T, CostActaDeleteArgs<ExtArgs>>): Prisma__CostActaClient<$Result.GetResult<Prisma.$CostActaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CostActa.
     * @param {CostActaUpdateArgs} args - Arguments to update one CostActa.
     * @example
     * // Update one CostActa
     * const costActa = await prisma.costActa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CostActaUpdateArgs>(args: SelectSubset<T, CostActaUpdateArgs<ExtArgs>>): Prisma__CostActaClient<$Result.GetResult<Prisma.$CostActaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CostActas.
     * @param {CostActaDeleteManyArgs} args - Arguments to filter CostActas to delete.
     * @example
     * // Delete a few CostActas
     * const { count } = await prisma.costActa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CostActaDeleteManyArgs>(args?: SelectSubset<T, CostActaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostActas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostActaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CostActas
     * const costActa = await prisma.costActa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CostActaUpdateManyArgs>(args: SelectSubset<T, CostActaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CostActa.
     * @param {CostActaUpsertArgs} args - Arguments to update or create a CostActa.
     * @example
     * // Update or create a CostActa
     * const costActa = await prisma.costActa.upsert({
     *   create: {
     *     // ... data to create a CostActa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CostActa we want to update
     *   }
     * })
     */
    upsert<T extends CostActaUpsertArgs>(args: SelectSubset<T, CostActaUpsertArgs<ExtArgs>>): Prisma__CostActaClient<$Result.GetResult<Prisma.$CostActaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CostActas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostActaCountArgs} args - Arguments to filter CostActas to count.
     * @example
     * // Count the number of CostActas
     * const count = await prisma.costActa.count({
     *   where: {
     *     // ... the filter for the CostActas we want to count
     *   }
     * })
    **/
    count<T extends CostActaCountArgs>(
      args?: Subset<T, CostActaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostActaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CostActa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostActaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostActaAggregateArgs>(args: Subset<T, CostActaAggregateArgs>): Prisma.PrismaPromise<GetCostActaAggregateType<T>>

    /**
     * Group by CostActa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostActaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostActaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostActaGroupByArgs['orderBy'] }
        : { orderBy?: CostActaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostActaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostActaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CostActa model
   */
  readonly fields: CostActaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CostActa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CostActaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    observations<T extends CostActa$observationsArgs<ExtArgs> = {}>(args?: Subset<T, CostActa$observationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findMany"> | Null>
    attachments<T extends CostActa$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, CostActa$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CostActa model
   */ 
  interface CostActaFieldRefs {
    readonly id: FieldRef<"CostActa", 'String'>
    readonly number: FieldRef<"CostActa", 'String'>
    readonly period: FieldRef<"CostActa", 'String'>
    readonly submissionDate: FieldRef<"CostActa", 'DateTime'>
    readonly approvalDate: FieldRef<"CostActa", 'DateTime'>
    readonly paymentDueDate: FieldRef<"CostActa", 'DateTime'>
    readonly billedAmount: FieldRef<"CostActa", 'Float'>
    readonly totalContractValue: FieldRef<"CostActa", 'Float'>
    readonly status: FieldRef<"CostActa", 'CostActaStatus'>
    readonly relatedProgress: FieldRef<"CostActa", 'String'>
    readonly createdAt: FieldRef<"CostActa", 'DateTime'>
    readonly updatedAt: FieldRef<"CostActa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CostActa findUnique
   */
  export type CostActaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostActa
     */
    select?: CostActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostActaInclude<ExtArgs> | null
    /**
     * Filter, which CostActa to fetch.
     */
    where: CostActaWhereUniqueInput
  }

  /**
   * CostActa findUniqueOrThrow
   */
  export type CostActaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostActa
     */
    select?: CostActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostActaInclude<ExtArgs> | null
    /**
     * Filter, which CostActa to fetch.
     */
    where: CostActaWhereUniqueInput
  }

  /**
   * CostActa findFirst
   */
  export type CostActaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostActa
     */
    select?: CostActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostActaInclude<ExtArgs> | null
    /**
     * Filter, which CostActa to fetch.
     */
    where?: CostActaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostActas to fetch.
     */
    orderBy?: CostActaOrderByWithRelationInput | CostActaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostActas.
     */
    cursor?: CostActaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostActas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostActas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostActas.
     */
    distinct?: CostActaScalarFieldEnum | CostActaScalarFieldEnum[]
  }

  /**
   * CostActa findFirstOrThrow
   */
  export type CostActaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostActa
     */
    select?: CostActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostActaInclude<ExtArgs> | null
    /**
     * Filter, which CostActa to fetch.
     */
    where?: CostActaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostActas to fetch.
     */
    orderBy?: CostActaOrderByWithRelationInput | CostActaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostActas.
     */
    cursor?: CostActaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostActas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostActas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostActas.
     */
    distinct?: CostActaScalarFieldEnum | CostActaScalarFieldEnum[]
  }

  /**
   * CostActa findMany
   */
  export type CostActaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostActa
     */
    select?: CostActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostActaInclude<ExtArgs> | null
    /**
     * Filter, which CostActas to fetch.
     */
    where?: CostActaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostActas to fetch.
     */
    orderBy?: CostActaOrderByWithRelationInput | CostActaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CostActas.
     */
    cursor?: CostActaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostActas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostActas.
     */
    skip?: number
    distinct?: CostActaScalarFieldEnum | CostActaScalarFieldEnum[]
  }

  /**
   * CostActa create
   */
  export type CostActaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostActa
     */
    select?: CostActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostActaInclude<ExtArgs> | null
    /**
     * The data needed to create a CostActa.
     */
    data: XOR<CostActaCreateInput, CostActaUncheckedCreateInput>
  }

  /**
   * CostActa createMany
   */
  export type CostActaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CostActas.
     */
    data: CostActaCreateManyInput | CostActaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostActa update
   */
  export type CostActaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostActa
     */
    select?: CostActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostActaInclude<ExtArgs> | null
    /**
     * The data needed to update a CostActa.
     */
    data: XOR<CostActaUpdateInput, CostActaUncheckedUpdateInput>
    /**
     * Choose, which CostActa to update.
     */
    where: CostActaWhereUniqueInput
  }

  /**
   * CostActa updateMany
   */
  export type CostActaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CostActas.
     */
    data: XOR<CostActaUpdateManyMutationInput, CostActaUncheckedUpdateManyInput>
    /**
     * Filter which CostActas to update
     */
    where?: CostActaWhereInput
  }

  /**
   * CostActa upsert
   */
  export type CostActaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostActa
     */
    select?: CostActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostActaInclude<ExtArgs> | null
    /**
     * The filter to search for the CostActa to update in case it exists.
     */
    where: CostActaWhereUniqueInput
    /**
     * In case the CostActa found by the `where` argument doesn't exist, create a new CostActa with this data.
     */
    create: XOR<CostActaCreateInput, CostActaUncheckedCreateInput>
    /**
     * In case the CostActa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostActaUpdateInput, CostActaUncheckedUpdateInput>
  }

  /**
   * CostActa delete
   */
  export type CostActaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostActa
     */
    select?: CostActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostActaInclude<ExtArgs> | null
    /**
     * Filter which CostActa to delete.
     */
    where: CostActaWhereUniqueInput
  }

  /**
   * CostActa deleteMany
   */
  export type CostActaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostActas to delete
     */
    where?: CostActaWhereInput
  }

  /**
   * CostActa.observations
   */
  export type CostActa$observationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    where?: ObservationWhereInput
    orderBy?: ObservationOrderByWithRelationInput | ObservationOrderByWithRelationInput[]
    cursor?: ObservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObservationScalarFieldEnum | ObservationScalarFieldEnum[]
  }

  /**
   * CostActa.attachments
   */
  export type CostActa$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * CostActa without action
   */
  export type CostActaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostActa
     */
    select?: CostActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostActaInclude<ExtArgs> | null
  }


  /**
   * Model Observation
   */

  export type AggregateObservation = {
    _count: ObservationCountAggregateOutputType | null
    _min: ObservationMinAggregateOutputType | null
    _max: ObservationMaxAggregateOutputType | null
  }

  export type ObservationMinAggregateOutputType = {
    id: string | null
    text: string | null
    timestamp: Date | null
    authorId: string | null
    costActaId: string | null
  }

  export type ObservationMaxAggregateOutputType = {
    id: string | null
    text: string | null
    timestamp: Date | null
    authorId: string | null
    costActaId: string | null
  }

  export type ObservationCountAggregateOutputType = {
    id: number
    text: number
    timestamp: number
    authorId: number
    costActaId: number
    _all: number
  }


  export type ObservationMinAggregateInputType = {
    id?: true
    text?: true
    timestamp?: true
    authorId?: true
    costActaId?: true
  }

  export type ObservationMaxAggregateInputType = {
    id?: true
    text?: true
    timestamp?: true
    authorId?: true
    costActaId?: true
  }

  export type ObservationCountAggregateInputType = {
    id?: true
    text?: true
    timestamp?: true
    authorId?: true
    costActaId?: true
    _all?: true
  }

  export type ObservationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Observation to aggregate.
     */
    where?: ObservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Observations to fetch.
     */
    orderBy?: ObservationOrderByWithRelationInput | ObservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Observations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Observations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Observations
    **/
    _count?: true | ObservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObservationMaxAggregateInputType
  }

  export type GetObservationAggregateType<T extends ObservationAggregateArgs> = {
        [P in keyof T & keyof AggregateObservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObservation[P]>
      : GetScalarType<T[P], AggregateObservation[P]>
  }




  export type ObservationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObservationWhereInput
    orderBy?: ObservationOrderByWithAggregationInput | ObservationOrderByWithAggregationInput[]
    by: ObservationScalarFieldEnum[] | ObservationScalarFieldEnum
    having?: ObservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObservationCountAggregateInputType | true
    _min?: ObservationMinAggregateInputType
    _max?: ObservationMaxAggregateInputType
  }

  export type ObservationGroupByOutputType = {
    id: string
    text: string
    timestamp: Date
    authorId: string
    costActaId: string
    _count: ObservationCountAggregateOutputType | null
    _min: ObservationMinAggregateOutputType | null
    _max: ObservationMaxAggregateOutputType | null
  }

  type GetObservationGroupByPayload<T extends ObservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObservationGroupByOutputType[P]>
            : GetScalarType<T[P], ObservationGroupByOutputType[P]>
        }
      >
    >


  export type ObservationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    timestamp?: boolean
    authorId?: boolean
    costActaId?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    costActa?: boolean | CostActaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["observation"]>


  export type ObservationSelectScalar = {
    id?: boolean
    text?: boolean
    timestamp?: boolean
    authorId?: boolean
    costActaId?: boolean
  }

  export type ObservationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    costActa?: boolean | CostActaDefaultArgs<ExtArgs>
  }

  export type $ObservationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Observation"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      costActa: Prisma.$CostActaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string
      timestamp: Date
      authorId: string
      costActaId: string
    }, ExtArgs["result"]["observation"]>
    composites: {}
  }

  type ObservationGetPayload<S extends boolean | null | undefined | ObservationDefaultArgs> = $Result.GetResult<Prisma.$ObservationPayload, S>

  type ObservationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ObservationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ObservationCountAggregateInputType | true
    }

  export interface ObservationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Observation'], meta: { name: 'Observation' } }
    /**
     * Find zero or one Observation that matches the filter.
     * @param {ObservationFindUniqueArgs} args - Arguments to find a Observation
     * @example
     * // Get one Observation
     * const observation = await prisma.observation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ObservationFindUniqueArgs>(args: SelectSubset<T, ObservationFindUniqueArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Observation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ObservationFindUniqueOrThrowArgs} args - Arguments to find a Observation
     * @example
     * // Get one Observation
     * const observation = await prisma.observation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ObservationFindUniqueOrThrowArgs>(args: SelectSubset<T, ObservationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Observation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationFindFirstArgs} args - Arguments to find a Observation
     * @example
     * // Get one Observation
     * const observation = await prisma.observation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ObservationFindFirstArgs>(args?: SelectSubset<T, ObservationFindFirstArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Observation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationFindFirstOrThrowArgs} args - Arguments to find a Observation
     * @example
     * // Get one Observation
     * const observation = await prisma.observation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ObservationFindFirstOrThrowArgs>(args?: SelectSubset<T, ObservationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Observations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Observations
     * const observations = await prisma.observation.findMany()
     * 
     * // Get first 10 Observations
     * const observations = await prisma.observation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const observationWithIdOnly = await prisma.observation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ObservationFindManyArgs>(args?: SelectSubset<T, ObservationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Observation.
     * @param {ObservationCreateArgs} args - Arguments to create a Observation.
     * @example
     * // Create one Observation
     * const Observation = await prisma.observation.create({
     *   data: {
     *     // ... data to create a Observation
     *   }
     * })
     * 
     */
    create<T extends ObservationCreateArgs>(args: SelectSubset<T, ObservationCreateArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Observations.
     * @param {ObservationCreateManyArgs} args - Arguments to create many Observations.
     * @example
     * // Create many Observations
     * const observation = await prisma.observation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ObservationCreateManyArgs>(args?: SelectSubset<T, ObservationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Observation.
     * @param {ObservationDeleteArgs} args - Arguments to delete one Observation.
     * @example
     * // Delete one Observation
     * const Observation = await prisma.observation.delete({
     *   where: {
     *     // ... filter to delete one Observation
     *   }
     * })
     * 
     */
    delete<T extends ObservationDeleteArgs>(args: SelectSubset<T, ObservationDeleteArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Observation.
     * @param {ObservationUpdateArgs} args - Arguments to update one Observation.
     * @example
     * // Update one Observation
     * const observation = await prisma.observation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ObservationUpdateArgs>(args: SelectSubset<T, ObservationUpdateArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Observations.
     * @param {ObservationDeleteManyArgs} args - Arguments to filter Observations to delete.
     * @example
     * // Delete a few Observations
     * const { count } = await prisma.observation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ObservationDeleteManyArgs>(args?: SelectSubset<T, ObservationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Observations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Observations
     * const observation = await prisma.observation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ObservationUpdateManyArgs>(args: SelectSubset<T, ObservationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Observation.
     * @param {ObservationUpsertArgs} args - Arguments to update or create a Observation.
     * @example
     * // Update or create a Observation
     * const observation = await prisma.observation.upsert({
     *   create: {
     *     // ... data to create a Observation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Observation we want to update
     *   }
     * })
     */
    upsert<T extends ObservationUpsertArgs>(args: SelectSubset<T, ObservationUpsertArgs<ExtArgs>>): Prisma__ObservationClient<$Result.GetResult<Prisma.$ObservationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Observations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationCountArgs} args - Arguments to filter Observations to count.
     * @example
     * // Count the number of Observations
     * const count = await prisma.observation.count({
     *   where: {
     *     // ... the filter for the Observations we want to count
     *   }
     * })
    **/
    count<T extends ObservationCountArgs>(
      args?: Subset<T, ObservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Observation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObservationAggregateArgs>(args: Subset<T, ObservationAggregateArgs>): Prisma.PrismaPromise<GetObservationAggregateType<T>>

    /**
     * Group by Observation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObservationGroupByArgs['orderBy'] }
        : { orderBy?: ObservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Observation model
   */
  readonly fields: ObservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Observation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObservationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    costActa<T extends CostActaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CostActaDefaultArgs<ExtArgs>>): Prisma__CostActaClient<$Result.GetResult<Prisma.$CostActaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Observation model
   */ 
  interface ObservationFieldRefs {
    readonly id: FieldRef<"Observation", 'String'>
    readonly text: FieldRef<"Observation", 'String'>
    readonly timestamp: FieldRef<"Observation", 'DateTime'>
    readonly authorId: FieldRef<"Observation", 'String'>
    readonly costActaId: FieldRef<"Observation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Observation findUnique
   */
  export type ObservationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter, which Observation to fetch.
     */
    where: ObservationWhereUniqueInput
  }

  /**
   * Observation findUniqueOrThrow
   */
  export type ObservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter, which Observation to fetch.
     */
    where: ObservationWhereUniqueInput
  }

  /**
   * Observation findFirst
   */
  export type ObservationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter, which Observation to fetch.
     */
    where?: ObservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Observations to fetch.
     */
    orderBy?: ObservationOrderByWithRelationInput | ObservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Observations.
     */
    cursor?: ObservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Observations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Observations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Observations.
     */
    distinct?: ObservationScalarFieldEnum | ObservationScalarFieldEnum[]
  }

  /**
   * Observation findFirstOrThrow
   */
  export type ObservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter, which Observation to fetch.
     */
    where?: ObservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Observations to fetch.
     */
    orderBy?: ObservationOrderByWithRelationInput | ObservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Observations.
     */
    cursor?: ObservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Observations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Observations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Observations.
     */
    distinct?: ObservationScalarFieldEnum | ObservationScalarFieldEnum[]
  }

  /**
   * Observation findMany
   */
  export type ObservationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter, which Observations to fetch.
     */
    where?: ObservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Observations to fetch.
     */
    orderBy?: ObservationOrderByWithRelationInput | ObservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Observations.
     */
    cursor?: ObservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Observations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Observations.
     */
    skip?: number
    distinct?: ObservationScalarFieldEnum | ObservationScalarFieldEnum[]
  }

  /**
   * Observation create
   */
  export type ObservationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * The data needed to create a Observation.
     */
    data: XOR<ObservationCreateInput, ObservationUncheckedCreateInput>
  }

  /**
   * Observation createMany
   */
  export type ObservationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Observations.
     */
    data: ObservationCreateManyInput | ObservationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Observation update
   */
  export type ObservationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * The data needed to update a Observation.
     */
    data: XOR<ObservationUpdateInput, ObservationUncheckedUpdateInput>
    /**
     * Choose, which Observation to update.
     */
    where: ObservationWhereUniqueInput
  }

  /**
   * Observation updateMany
   */
  export type ObservationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Observations.
     */
    data: XOR<ObservationUpdateManyMutationInput, ObservationUncheckedUpdateManyInput>
    /**
     * Filter which Observations to update
     */
    where?: ObservationWhereInput
  }

  /**
   * Observation upsert
   */
  export type ObservationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * The filter to search for the Observation to update in case it exists.
     */
    where: ObservationWhereUniqueInput
    /**
     * In case the Observation found by the `where` argument doesn't exist, create a new Observation with this data.
     */
    create: XOR<ObservationCreateInput, ObservationUncheckedCreateInput>
    /**
     * In case the Observation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObservationUpdateInput, ObservationUncheckedUpdateInput>
  }

  /**
   * Observation delete
   */
  export type ObservationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
    /**
     * Filter which Observation to delete.
     */
    where: ObservationWhereUniqueInput
  }

  /**
   * Observation deleteMany
   */
  export type ObservationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Observations to delete
     */
    where?: ObservationWhereInput
  }

  /**
   * Observation without action
   */
  export type ObservationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Observation
     */
    select?: ObservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObservationInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    type: string | null
    reportScope: $Enums.ReportScope | null
    number: string | null
    period: string | null
    submissionDate: Date | null
    summary: string | null
    status: $Enums.ReportStatus | null
    authorId: string | null
    requiredSignatoriesJson: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    type: string | null
    reportScope: $Enums.ReportScope | null
    number: string | null
    period: string | null
    submissionDate: Date | null
    summary: string | null
    status: $Enums.ReportStatus | null
    authorId: string | null
    requiredSignatoriesJson: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    type: number
    reportScope: number
    number: number
    period: number
    submissionDate: number
    summary: number
    status: number
    authorId: number
    requiredSignatoriesJson: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    type?: true
    reportScope?: true
    number?: true
    period?: true
    submissionDate?: true
    summary?: true
    status?: true
    authorId?: true
    requiredSignatoriesJson?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    type?: true
    reportScope?: true
    number?: true
    period?: true
    submissionDate?: true
    summary?: true
    status?: true
    authorId?: true
    requiredSignatoriesJson?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    type?: true
    reportScope?: true
    number?: true
    period?: true
    submissionDate?: true
    summary?: true
    status?: true
    authorId?: true
    requiredSignatoriesJson?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    type: string
    reportScope: $Enums.ReportScope
    number: string
    period: string
    submissionDate: Date
    summary: string
    status: $Enums.ReportStatus
    authorId: string
    requiredSignatoriesJson: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    reportScope?: boolean
    number?: boolean
    period?: boolean
    submissionDate?: boolean
    summary?: boolean
    status?: boolean
    authorId?: boolean
    requiredSignatoriesJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Report$attachmentsArgs<ExtArgs>
    signatures?: boolean | Report$signaturesArgs<ExtArgs>
    _count?: boolean | ReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>


  export type ReportSelectScalar = {
    id?: boolean
    type?: boolean
    reportScope?: boolean
    number?: boolean
    period?: boolean
    submissionDate?: boolean
    summary?: boolean
    status?: boolean
    authorId?: boolean
    requiredSignatoriesJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Report$attachmentsArgs<ExtArgs>
    signatures?: boolean | Report$signaturesArgs<ExtArgs>
    _count?: boolean | ReportCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
      signatures: Prisma.$SignaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      reportScope: $Enums.ReportScope
      number: string
      period: string
      submissionDate: Date
      summary: string
      status: $Enums.ReportStatus
      authorId: string
      requiredSignatoriesJson: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    attachments<T extends Report$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Report$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    signatures<T extends Report$signaturesArgs<ExtArgs> = {}>(args?: Subset<T, Report$signaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SignaturePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */ 
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly type: FieldRef<"Report", 'String'>
    readonly reportScope: FieldRef<"Report", 'ReportScope'>
    readonly number: FieldRef<"Report", 'String'>
    readonly period: FieldRef<"Report", 'String'>
    readonly submissionDate: FieldRef<"Report", 'DateTime'>
    readonly summary: FieldRef<"Report", 'String'>
    readonly status: FieldRef<"Report", 'ReportStatus'>
    readonly authorId: FieldRef<"Report", 'String'>
    readonly requiredSignatoriesJson: FieldRef<"Report", 'String'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
    readonly updatedAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }

  /**
   * Report.attachments
   */
  export type Report$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * Report.signatures
   */
  export type Report$signaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Signature
     */
    select?: SignatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SignatureInclude<ExtArgs> | null
    where?: SignatureWhereInput
    orderBy?: SignatureOrderByWithRelationInput | SignatureOrderByWithRelationInput[]
    cursor?: SignatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SignatureScalarFieldEnum | SignatureScalarFieldEnum[]
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model Drawing
   */

  export type AggregateDrawing = {
    _count: DrawingCountAggregateOutputType | null
    _min: DrawingMinAggregateOutputType | null
    _max: DrawingMaxAggregateOutputType | null
  }

  export type DrawingMinAggregateOutputType = {
    id: string | null
    code: string | null
    title: string | null
    discipline: $Enums.DrawingDiscipline | null
    status: $Enums.DrawingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DrawingMaxAggregateOutputType = {
    id: string | null
    code: string | null
    title: string | null
    discipline: $Enums.DrawingDiscipline | null
    status: $Enums.DrawingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DrawingCountAggregateOutputType = {
    id: number
    code: number
    title: number
    discipline: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DrawingMinAggregateInputType = {
    id?: true
    code?: true
    title?: true
    discipline?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DrawingMaxAggregateInputType = {
    id?: true
    code?: true
    title?: true
    discipline?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DrawingCountAggregateInputType = {
    id?: true
    code?: true
    title?: true
    discipline?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DrawingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Drawing to aggregate.
     */
    where?: DrawingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drawings to fetch.
     */
    orderBy?: DrawingOrderByWithRelationInput | DrawingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DrawingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drawings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drawings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Drawings
    **/
    _count?: true | DrawingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DrawingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DrawingMaxAggregateInputType
  }

  export type GetDrawingAggregateType<T extends DrawingAggregateArgs> = {
        [P in keyof T & keyof AggregateDrawing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDrawing[P]>
      : GetScalarType<T[P], AggregateDrawing[P]>
  }




  export type DrawingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DrawingWhereInput
    orderBy?: DrawingOrderByWithAggregationInput | DrawingOrderByWithAggregationInput[]
    by: DrawingScalarFieldEnum[] | DrawingScalarFieldEnum
    having?: DrawingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DrawingCountAggregateInputType | true
    _min?: DrawingMinAggregateInputType
    _max?: DrawingMaxAggregateInputType
  }

  export type DrawingGroupByOutputType = {
    id: string
    code: string
    title: string
    discipline: $Enums.DrawingDiscipline
    status: $Enums.DrawingStatus
    createdAt: Date
    updatedAt: Date
    _count: DrawingCountAggregateOutputType | null
    _min: DrawingMinAggregateOutputType | null
    _max: DrawingMaxAggregateOutputType | null
  }

  type GetDrawingGroupByPayload<T extends DrawingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DrawingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DrawingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DrawingGroupByOutputType[P]>
            : GetScalarType<T[P], DrawingGroupByOutputType[P]>
        }
      >
    >


  export type DrawingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    title?: boolean
    discipline?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    versions?: boolean | Drawing$versionsArgs<ExtArgs>
    comments?: boolean | Drawing$commentsArgs<ExtArgs>
    _count?: boolean | DrawingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["drawing"]>


  export type DrawingSelectScalar = {
    id?: boolean
    code?: boolean
    title?: boolean
    discipline?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DrawingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    versions?: boolean | Drawing$versionsArgs<ExtArgs>
    comments?: boolean | Drawing$commentsArgs<ExtArgs>
    _count?: boolean | DrawingCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DrawingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Drawing"
    objects: {
      versions: Prisma.$DrawingVersionPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      title: string
      discipline: $Enums.DrawingDiscipline
      status: $Enums.DrawingStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["drawing"]>
    composites: {}
  }

  type DrawingGetPayload<S extends boolean | null | undefined | DrawingDefaultArgs> = $Result.GetResult<Prisma.$DrawingPayload, S>

  type DrawingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DrawingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DrawingCountAggregateInputType | true
    }

  export interface DrawingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Drawing'], meta: { name: 'Drawing' } }
    /**
     * Find zero or one Drawing that matches the filter.
     * @param {DrawingFindUniqueArgs} args - Arguments to find a Drawing
     * @example
     * // Get one Drawing
     * const drawing = await prisma.drawing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DrawingFindUniqueArgs>(args: SelectSubset<T, DrawingFindUniqueArgs<ExtArgs>>): Prisma__DrawingClient<$Result.GetResult<Prisma.$DrawingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Drawing that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DrawingFindUniqueOrThrowArgs} args - Arguments to find a Drawing
     * @example
     * // Get one Drawing
     * const drawing = await prisma.drawing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DrawingFindUniqueOrThrowArgs>(args: SelectSubset<T, DrawingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DrawingClient<$Result.GetResult<Prisma.$DrawingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Drawing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrawingFindFirstArgs} args - Arguments to find a Drawing
     * @example
     * // Get one Drawing
     * const drawing = await prisma.drawing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DrawingFindFirstArgs>(args?: SelectSubset<T, DrawingFindFirstArgs<ExtArgs>>): Prisma__DrawingClient<$Result.GetResult<Prisma.$DrawingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Drawing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrawingFindFirstOrThrowArgs} args - Arguments to find a Drawing
     * @example
     * // Get one Drawing
     * const drawing = await prisma.drawing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DrawingFindFirstOrThrowArgs>(args?: SelectSubset<T, DrawingFindFirstOrThrowArgs<ExtArgs>>): Prisma__DrawingClient<$Result.GetResult<Prisma.$DrawingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Drawings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrawingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drawings
     * const drawings = await prisma.drawing.findMany()
     * 
     * // Get first 10 Drawings
     * const drawings = await prisma.drawing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const drawingWithIdOnly = await prisma.drawing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DrawingFindManyArgs>(args?: SelectSubset<T, DrawingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DrawingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Drawing.
     * @param {DrawingCreateArgs} args - Arguments to create a Drawing.
     * @example
     * // Create one Drawing
     * const Drawing = await prisma.drawing.create({
     *   data: {
     *     // ... data to create a Drawing
     *   }
     * })
     * 
     */
    create<T extends DrawingCreateArgs>(args: SelectSubset<T, DrawingCreateArgs<ExtArgs>>): Prisma__DrawingClient<$Result.GetResult<Prisma.$DrawingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Drawings.
     * @param {DrawingCreateManyArgs} args - Arguments to create many Drawings.
     * @example
     * // Create many Drawings
     * const drawing = await prisma.drawing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DrawingCreateManyArgs>(args?: SelectSubset<T, DrawingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Drawing.
     * @param {DrawingDeleteArgs} args - Arguments to delete one Drawing.
     * @example
     * // Delete one Drawing
     * const Drawing = await prisma.drawing.delete({
     *   where: {
     *     // ... filter to delete one Drawing
     *   }
     * })
     * 
     */
    delete<T extends DrawingDeleteArgs>(args: SelectSubset<T, DrawingDeleteArgs<ExtArgs>>): Prisma__DrawingClient<$Result.GetResult<Prisma.$DrawingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Drawing.
     * @param {DrawingUpdateArgs} args - Arguments to update one Drawing.
     * @example
     * // Update one Drawing
     * const drawing = await prisma.drawing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DrawingUpdateArgs>(args: SelectSubset<T, DrawingUpdateArgs<ExtArgs>>): Prisma__DrawingClient<$Result.GetResult<Prisma.$DrawingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Drawings.
     * @param {DrawingDeleteManyArgs} args - Arguments to filter Drawings to delete.
     * @example
     * // Delete a few Drawings
     * const { count } = await prisma.drawing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DrawingDeleteManyArgs>(args?: SelectSubset<T, DrawingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drawings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrawingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drawings
     * const drawing = await prisma.drawing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DrawingUpdateManyArgs>(args: SelectSubset<T, DrawingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Drawing.
     * @param {DrawingUpsertArgs} args - Arguments to update or create a Drawing.
     * @example
     * // Update or create a Drawing
     * const drawing = await prisma.drawing.upsert({
     *   create: {
     *     // ... data to create a Drawing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Drawing we want to update
     *   }
     * })
     */
    upsert<T extends DrawingUpsertArgs>(args: SelectSubset<T, DrawingUpsertArgs<ExtArgs>>): Prisma__DrawingClient<$Result.GetResult<Prisma.$DrawingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Drawings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrawingCountArgs} args - Arguments to filter Drawings to count.
     * @example
     * // Count the number of Drawings
     * const count = await prisma.drawing.count({
     *   where: {
     *     // ... the filter for the Drawings we want to count
     *   }
     * })
    **/
    count<T extends DrawingCountArgs>(
      args?: Subset<T, DrawingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DrawingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Drawing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrawingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DrawingAggregateArgs>(args: Subset<T, DrawingAggregateArgs>): Prisma.PrismaPromise<GetDrawingAggregateType<T>>

    /**
     * Group by Drawing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrawingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DrawingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DrawingGroupByArgs['orderBy'] }
        : { orderBy?: DrawingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DrawingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDrawingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Drawing model
   */
  readonly fields: DrawingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Drawing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DrawingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    versions<T extends Drawing$versionsArgs<ExtArgs> = {}>(args?: Subset<T, Drawing$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DrawingVersionPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends Drawing$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Drawing$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Drawing model
   */ 
  interface DrawingFieldRefs {
    readonly id: FieldRef<"Drawing", 'String'>
    readonly code: FieldRef<"Drawing", 'String'>
    readonly title: FieldRef<"Drawing", 'String'>
    readonly discipline: FieldRef<"Drawing", 'DrawingDiscipline'>
    readonly status: FieldRef<"Drawing", 'DrawingStatus'>
    readonly createdAt: FieldRef<"Drawing", 'DateTime'>
    readonly updatedAt: FieldRef<"Drawing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Drawing findUnique
   */
  export type DrawingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drawing
     */
    select?: DrawingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingInclude<ExtArgs> | null
    /**
     * Filter, which Drawing to fetch.
     */
    where: DrawingWhereUniqueInput
  }

  /**
   * Drawing findUniqueOrThrow
   */
  export type DrawingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drawing
     */
    select?: DrawingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingInclude<ExtArgs> | null
    /**
     * Filter, which Drawing to fetch.
     */
    where: DrawingWhereUniqueInput
  }

  /**
   * Drawing findFirst
   */
  export type DrawingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drawing
     */
    select?: DrawingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingInclude<ExtArgs> | null
    /**
     * Filter, which Drawing to fetch.
     */
    where?: DrawingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drawings to fetch.
     */
    orderBy?: DrawingOrderByWithRelationInput | DrawingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drawings.
     */
    cursor?: DrawingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drawings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drawings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drawings.
     */
    distinct?: DrawingScalarFieldEnum | DrawingScalarFieldEnum[]
  }

  /**
   * Drawing findFirstOrThrow
   */
  export type DrawingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drawing
     */
    select?: DrawingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingInclude<ExtArgs> | null
    /**
     * Filter, which Drawing to fetch.
     */
    where?: DrawingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drawings to fetch.
     */
    orderBy?: DrawingOrderByWithRelationInput | DrawingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drawings.
     */
    cursor?: DrawingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drawings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drawings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drawings.
     */
    distinct?: DrawingScalarFieldEnum | DrawingScalarFieldEnum[]
  }

  /**
   * Drawing findMany
   */
  export type DrawingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drawing
     */
    select?: DrawingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingInclude<ExtArgs> | null
    /**
     * Filter, which Drawings to fetch.
     */
    where?: DrawingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drawings to fetch.
     */
    orderBy?: DrawingOrderByWithRelationInput | DrawingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Drawings.
     */
    cursor?: DrawingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drawings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drawings.
     */
    skip?: number
    distinct?: DrawingScalarFieldEnum | DrawingScalarFieldEnum[]
  }

  /**
   * Drawing create
   */
  export type DrawingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drawing
     */
    select?: DrawingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingInclude<ExtArgs> | null
    /**
     * The data needed to create a Drawing.
     */
    data: XOR<DrawingCreateInput, DrawingUncheckedCreateInput>
  }

  /**
   * Drawing createMany
   */
  export type DrawingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Drawings.
     */
    data: DrawingCreateManyInput | DrawingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Drawing update
   */
  export type DrawingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drawing
     */
    select?: DrawingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingInclude<ExtArgs> | null
    /**
     * The data needed to update a Drawing.
     */
    data: XOR<DrawingUpdateInput, DrawingUncheckedUpdateInput>
    /**
     * Choose, which Drawing to update.
     */
    where: DrawingWhereUniqueInput
  }

  /**
   * Drawing updateMany
   */
  export type DrawingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Drawings.
     */
    data: XOR<DrawingUpdateManyMutationInput, DrawingUncheckedUpdateManyInput>
    /**
     * Filter which Drawings to update
     */
    where?: DrawingWhereInput
  }

  /**
   * Drawing upsert
   */
  export type DrawingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drawing
     */
    select?: DrawingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingInclude<ExtArgs> | null
    /**
     * The filter to search for the Drawing to update in case it exists.
     */
    where: DrawingWhereUniqueInput
    /**
     * In case the Drawing found by the `where` argument doesn't exist, create a new Drawing with this data.
     */
    create: XOR<DrawingCreateInput, DrawingUncheckedCreateInput>
    /**
     * In case the Drawing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DrawingUpdateInput, DrawingUncheckedUpdateInput>
  }

  /**
   * Drawing delete
   */
  export type DrawingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drawing
     */
    select?: DrawingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingInclude<ExtArgs> | null
    /**
     * Filter which Drawing to delete.
     */
    where: DrawingWhereUniqueInput
  }

  /**
   * Drawing deleteMany
   */
  export type DrawingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Drawings to delete
     */
    where?: DrawingWhereInput
  }

  /**
   * Drawing.versions
   */
  export type Drawing$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrawingVersion
     */
    select?: DrawingVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingVersionInclude<ExtArgs> | null
    where?: DrawingVersionWhereInput
    orderBy?: DrawingVersionOrderByWithRelationInput | DrawingVersionOrderByWithRelationInput[]
    cursor?: DrawingVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DrawingVersionScalarFieldEnum | DrawingVersionScalarFieldEnum[]
  }

  /**
   * Drawing.comments
   */
  export type Drawing$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Drawing without action
   */
  export type DrawingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Drawing
     */
    select?: DrawingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingInclude<ExtArgs> | null
  }


  /**
   * Model DrawingVersion
   */

  export type AggregateDrawingVersion = {
    _count: DrawingVersionCountAggregateOutputType | null
    _avg: DrawingVersionAvgAggregateOutputType | null
    _sum: DrawingVersionSumAggregateOutputType | null
    _min: DrawingVersionMinAggregateOutputType | null
    _max: DrawingVersionMaxAggregateOutputType | null
  }

  export type DrawingVersionAvgAggregateOutputType = {
    versionNumber: number | null
    size: number | null
  }

  export type DrawingVersionSumAggregateOutputType = {
    versionNumber: number | null
    size: number | null
  }

  export type DrawingVersionMinAggregateOutputType = {
    id: string | null
    versionNumber: number | null
    fileName: string | null
    url: string | null
    size: number | null
    uploadDate: Date | null
    uploaderId: string | null
    drawingId: string | null
  }

  export type DrawingVersionMaxAggregateOutputType = {
    id: string | null
    versionNumber: number | null
    fileName: string | null
    url: string | null
    size: number | null
    uploadDate: Date | null
    uploaderId: string | null
    drawingId: string | null
  }

  export type DrawingVersionCountAggregateOutputType = {
    id: number
    versionNumber: number
    fileName: number
    url: number
    size: number
    uploadDate: number
    uploaderId: number
    drawingId: number
    _all: number
  }


  export type DrawingVersionAvgAggregateInputType = {
    versionNumber?: true
    size?: true
  }

  export type DrawingVersionSumAggregateInputType = {
    versionNumber?: true
    size?: true
  }

  export type DrawingVersionMinAggregateInputType = {
    id?: true
    versionNumber?: true
    fileName?: true
    url?: true
    size?: true
    uploadDate?: true
    uploaderId?: true
    drawingId?: true
  }

  export type DrawingVersionMaxAggregateInputType = {
    id?: true
    versionNumber?: true
    fileName?: true
    url?: true
    size?: true
    uploadDate?: true
    uploaderId?: true
    drawingId?: true
  }

  export type DrawingVersionCountAggregateInputType = {
    id?: true
    versionNumber?: true
    fileName?: true
    url?: true
    size?: true
    uploadDate?: true
    uploaderId?: true
    drawingId?: true
    _all?: true
  }

  export type DrawingVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DrawingVersion to aggregate.
     */
    where?: DrawingVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrawingVersions to fetch.
     */
    orderBy?: DrawingVersionOrderByWithRelationInput | DrawingVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DrawingVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrawingVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrawingVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DrawingVersions
    **/
    _count?: true | DrawingVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DrawingVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DrawingVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DrawingVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DrawingVersionMaxAggregateInputType
  }

  export type GetDrawingVersionAggregateType<T extends DrawingVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateDrawingVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDrawingVersion[P]>
      : GetScalarType<T[P], AggregateDrawingVersion[P]>
  }




  export type DrawingVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DrawingVersionWhereInput
    orderBy?: DrawingVersionOrderByWithAggregationInput | DrawingVersionOrderByWithAggregationInput[]
    by: DrawingVersionScalarFieldEnum[] | DrawingVersionScalarFieldEnum
    having?: DrawingVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DrawingVersionCountAggregateInputType | true
    _avg?: DrawingVersionAvgAggregateInputType
    _sum?: DrawingVersionSumAggregateInputType
    _min?: DrawingVersionMinAggregateInputType
    _max?: DrawingVersionMaxAggregateInputType
  }

  export type DrawingVersionGroupByOutputType = {
    id: string
    versionNumber: number
    fileName: string
    url: string
    size: number
    uploadDate: Date
    uploaderId: string
    drawingId: string
    _count: DrawingVersionCountAggregateOutputType | null
    _avg: DrawingVersionAvgAggregateOutputType | null
    _sum: DrawingVersionSumAggregateOutputType | null
    _min: DrawingVersionMinAggregateOutputType | null
    _max: DrawingVersionMaxAggregateOutputType | null
  }

  type GetDrawingVersionGroupByPayload<T extends DrawingVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DrawingVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DrawingVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DrawingVersionGroupByOutputType[P]>
            : GetScalarType<T[P], DrawingVersionGroupByOutputType[P]>
        }
      >
    >


  export type DrawingVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    versionNumber?: boolean
    fileName?: boolean
    url?: boolean
    size?: boolean
    uploadDate?: boolean
    uploaderId?: boolean
    drawingId?: boolean
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    drawing?: boolean | DrawingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["drawingVersion"]>


  export type DrawingVersionSelectScalar = {
    id?: boolean
    versionNumber?: boolean
    fileName?: boolean
    url?: boolean
    size?: boolean
    uploadDate?: boolean
    uploaderId?: boolean
    drawingId?: boolean
  }

  export type DrawingVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | UserDefaultArgs<ExtArgs>
    drawing?: boolean | DrawingDefaultArgs<ExtArgs>
  }

  export type $DrawingVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DrawingVersion"
    objects: {
      uploader: Prisma.$UserPayload<ExtArgs>
      drawing: Prisma.$DrawingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      versionNumber: number
      fileName: string
      url: string
      size: number
      uploadDate: Date
      uploaderId: string
      drawingId: string
    }, ExtArgs["result"]["drawingVersion"]>
    composites: {}
  }

  type DrawingVersionGetPayload<S extends boolean | null | undefined | DrawingVersionDefaultArgs> = $Result.GetResult<Prisma.$DrawingVersionPayload, S>

  type DrawingVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DrawingVersionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DrawingVersionCountAggregateInputType | true
    }

  export interface DrawingVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DrawingVersion'], meta: { name: 'DrawingVersion' } }
    /**
     * Find zero or one DrawingVersion that matches the filter.
     * @param {DrawingVersionFindUniqueArgs} args - Arguments to find a DrawingVersion
     * @example
     * // Get one DrawingVersion
     * const drawingVersion = await prisma.drawingVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DrawingVersionFindUniqueArgs>(args: SelectSubset<T, DrawingVersionFindUniqueArgs<ExtArgs>>): Prisma__DrawingVersionClient<$Result.GetResult<Prisma.$DrawingVersionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DrawingVersion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DrawingVersionFindUniqueOrThrowArgs} args - Arguments to find a DrawingVersion
     * @example
     * // Get one DrawingVersion
     * const drawingVersion = await prisma.drawingVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DrawingVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, DrawingVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DrawingVersionClient<$Result.GetResult<Prisma.$DrawingVersionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DrawingVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrawingVersionFindFirstArgs} args - Arguments to find a DrawingVersion
     * @example
     * // Get one DrawingVersion
     * const drawingVersion = await prisma.drawingVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DrawingVersionFindFirstArgs>(args?: SelectSubset<T, DrawingVersionFindFirstArgs<ExtArgs>>): Prisma__DrawingVersionClient<$Result.GetResult<Prisma.$DrawingVersionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DrawingVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrawingVersionFindFirstOrThrowArgs} args - Arguments to find a DrawingVersion
     * @example
     * // Get one DrawingVersion
     * const drawingVersion = await prisma.drawingVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DrawingVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, DrawingVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DrawingVersionClient<$Result.GetResult<Prisma.$DrawingVersionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DrawingVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrawingVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DrawingVersions
     * const drawingVersions = await prisma.drawingVersion.findMany()
     * 
     * // Get first 10 DrawingVersions
     * const drawingVersions = await prisma.drawingVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const drawingVersionWithIdOnly = await prisma.drawingVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DrawingVersionFindManyArgs>(args?: SelectSubset<T, DrawingVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DrawingVersionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DrawingVersion.
     * @param {DrawingVersionCreateArgs} args - Arguments to create a DrawingVersion.
     * @example
     * // Create one DrawingVersion
     * const DrawingVersion = await prisma.drawingVersion.create({
     *   data: {
     *     // ... data to create a DrawingVersion
     *   }
     * })
     * 
     */
    create<T extends DrawingVersionCreateArgs>(args: SelectSubset<T, DrawingVersionCreateArgs<ExtArgs>>): Prisma__DrawingVersionClient<$Result.GetResult<Prisma.$DrawingVersionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DrawingVersions.
     * @param {DrawingVersionCreateManyArgs} args - Arguments to create many DrawingVersions.
     * @example
     * // Create many DrawingVersions
     * const drawingVersion = await prisma.drawingVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DrawingVersionCreateManyArgs>(args?: SelectSubset<T, DrawingVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DrawingVersion.
     * @param {DrawingVersionDeleteArgs} args - Arguments to delete one DrawingVersion.
     * @example
     * // Delete one DrawingVersion
     * const DrawingVersion = await prisma.drawingVersion.delete({
     *   where: {
     *     // ... filter to delete one DrawingVersion
     *   }
     * })
     * 
     */
    delete<T extends DrawingVersionDeleteArgs>(args: SelectSubset<T, DrawingVersionDeleteArgs<ExtArgs>>): Prisma__DrawingVersionClient<$Result.GetResult<Prisma.$DrawingVersionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DrawingVersion.
     * @param {DrawingVersionUpdateArgs} args - Arguments to update one DrawingVersion.
     * @example
     * // Update one DrawingVersion
     * const drawingVersion = await prisma.drawingVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DrawingVersionUpdateArgs>(args: SelectSubset<T, DrawingVersionUpdateArgs<ExtArgs>>): Prisma__DrawingVersionClient<$Result.GetResult<Prisma.$DrawingVersionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DrawingVersions.
     * @param {DrawingVersionDeleteManyArgs} args - Arguments to filter DrawingVersions to delete.
     * @example
     * // Delete a few DrawingVersions
     * const { count } = await prisma.drawingVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DrawingVersionDeleteManyArgs>(args?: SelectSubset<T, DrawingVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DrawingVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrawingVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DrawingVersions
     * const drawingVersion = await prisma.drawingVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DrawingVersionUpdateManyArgs>(args: SelectSubset<T, DrawingVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DrawingVersion.
     * @param {DrawingVersionUpsertArgs} args - Arguments to update or create a DrawingVersion.
     * @example
     * // Update or create a DrawingVersion
     * const drawingVersion = await prisma.drawingVersion.upsert({
     *   create: {
     *     // ... data to create a DrawingVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DrawingVersion we want to update
     *   }
     * })
     */
    upsert<T extends DrawingVersionUpsertArgs>(args: SelectSubset<T, DrawingVersionUpsertArgs<ExtArgs>>): Prisma__DrawingVersionClient<$Result.GetResult<Prisma.$DrawingVersionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DrawingVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrawingVersionCountArgs} args - Arguments to filter DrawingVersions to count.
     * @example
     * // Count the number of DrawingVersions
     * const count = await prisma.drawingVersion.count({
     *   where: {
     *     // ... the filter for the DrawingVersions we want to count
     *   }
     * })
    **/
    count<T extends DrawingVersionCountArgs>(
      args?: Subset<T, DrawingVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DrawingVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DrawingVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrawingVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DrawingVersionAggregateArgs>(args: Subset<T, DrawingVersionAggregateArgs>): Prisma.PrismaPromise<GetDrawingVersionAggregateType<T>>

    /**
     * Group by DrawingVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DrawingVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DrawingVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DrawingVersionGroupByArgs['orderBy'] }
        : { orderBy?: DrawingVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DrawingVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDrawingVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DrawingVersion model
   */
  readonly fields: DrawingVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DrawingVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DrawingVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    drawing<T extends DrawingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DrawingDefaultArgs<ExtArgs>>): Prisma__DrawingClient<$Result.GetResult<Prisma.$DrawingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DrawingVersion model
   */ 
  interface DrawingVersionFieldRefs {
    readonly id: FieldRef<"DrawingVersion", 'String'>
    readonly versionNumber: FieldRef<"DrawingVersion", 'Int'>
    readonly fileName: FieldRef<"DrawingVersion", 'String'>
    readonly url: FieldRef<"DrawingVersion", 'String'>
    readonly size: FieldRef<"DrawingVersion", 'Int'>
    readonly uploadDate: FieldRef<"DrawingVersion", 'DateTime'>
    readonly uploaderId: FieldRef<"DrawingVersion", 'String'>
    readonly drawingId: FieldRef<"DrawingVersion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DrawingVersion findUnique
   */
  export type DrawingVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrawingVersion
     */
    select?: DrawingVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingVersionInclude<ExtArgs> | null
    /**
     * Filter, which DrawingVersion to fetch.
     */
    where: DrawingVersionWhereUniqueInput
  }

  /**
   * DrawingVersion findUniqueOrThrow
   */
  export type DrawingVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrawingVersion
     */
    select?: DrawingVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingVersionInclude<ExtArgs> | null
    /**
     * Filter, which DrawingVersion to fetch.
     */
    where: DrawingVersionWhereUniqueInput
  }

  /**
   * DrawingVersion findFirst
   */
  export type DrawingVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrawingVersion
     */
    select?: DrawingVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingVersionInclude<ExtArgs> | null
    /**
     * Filter, which DrawingVersion to fetch.
     */
    where?: DrawingVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrawingVersions to fetch.
     */
    orderBy?: DrawingVersionOrderByWithRelationInput | DrawingVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DrawingVersions.
     */
    cursor?: DrawingVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrawingVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrawingVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DrawingVersions.
     */
    distinct?: DrawingVersionScalarFieldEnum | DrawingVersionScalarFieldEnum[]
  }

  /**
   * DrawingVersion findFirstOrThrow
   */
  export type DrawingVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrawingVersion
     */
    select?: DrawingVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingVersionInclude<ExtArgs> | null
    /**
     * Filter, which DrawingVersion to fetch.
     */
    where?: DrawingVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrawingVersions to fetch.
     */
    orderBy?: DrawingVersionOrderByWithRelationInput | DrawingVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DrawingVersions.
     */
    cursor?: DrawingVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrawingVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrawingVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DrawingVersions.
     */
    distinct?: DrawingVersionScalarFieldEnum | DrawingVersionScalarFieldEnum[]
  }

  /**
   * DrawingVersion findMany
   */
  export type DrawingVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrawingVersion
     */
    select?: DrawingVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingVersionInclude<ExtArgs> | null
    /**
     * Filter, which DrawingVersions to fetch.
     */
    where?: DrawingVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DrawingVersions to fetch.
     */
    orderBy?: DrawingVersionOrderByWithRelationInput | DrawingVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DrawingVersions.
     */
    cursor?: DrawingVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DrawingVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DrawingVersions.
     */
    skip?: number
    distinct?: DrawingVersionScalarFieldEnum | DrawingVersionScalarFieldEnum[]
  }

  /**
   * DrawingVersion create
   */
  export type DrawingVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrawingVersion
     */
    select?: DrawingVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a DrawingVersion.
     */
    data: XOR<DrawingVersionCreateInput, DrawingVersionUncheckedCreateInput>
  }

  /**
   * DrawingVersion createMany
   */
  export type DrawingVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DrawingVersions.
     */
    data: DrawingVersionCreateManyInput | DrawingVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DrawingVersion update
   */
  export type DrawingVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrawingVersion
     */
    select?: DrawingVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a DrawingVersion.
     */
    data: XOR<DrawingVersionUpdateInput, DrawingVersionUncheckedUpdateInput>
    /**
     * Choose, which DrawingVersion to update.
     */
    where: DrawingVersionWhereUniqueInput
  }

  /**
   * DrawingVersion updateMany
   */
  export type DrawingVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DrawingVersions.
     */
    data: XOR<DrawingVersionUpdateManyMutationInput, DrawingVersionUncheckedUpdateManyInput>
    /**
     * Filter which DrawingVersions to update
     */
    where?: DrawingVersionWhereInput
  }

  /**
   * DrawingVersion upsert
   */
  export type DrawingVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrawingVersion
     */
    select?: DrawingVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the DrawingVersion to update in case it exists.
     */
    where: DrawingVersionWhereUniqueInput
    /**
     * In case the DrawingVersion found by the `where` argument doesn't exist, create a new DrawingVersion with this data.
     */
    create: XOR<DrawingVersionCreateInput, DrawingVersionUncheckedCreateInput>
    /**
     * In case the DrawingVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DrawingVersionUpdateInput, DrawingVersionUncheckedUpdateInput>
  }

  /**
   * DrawingVersion delete
   */
  export type DrawingVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrawingVersion
     */
    select?: DrawingVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingVersionInclude<ExtArgs> | null
    /**
     * Filter which DrawingVersion to delete.
     */
    where: DrawingVersionWhereUniqueInput
  }

  /**
   * DrawingVersion deleteMany
   */
  export type DrawingVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DrawingVersions to delete
     */
    where?: DrawingVersionWhereInput
  }

  /**
   * DrawingVersion without action
   */
  export type DrawingVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DrawingVersion
     */
    select?: DrawingVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DrawingVersionInclude<ExtArgs> | null
  }


  /**
   * Model PhotoEntry
   */

  export type AggregatePhotoEntry = {
    _count: PhotoEntryCountAggregateOutputType | null
    _min: PhotoEntryMinAggregateOutputType | null
    _max: PhotoEntryMaxAggregateOutputType | null
  }

  export type PhotoEntryMinAggregateOutputType = {
    id: string | null
    url: string | null
    date: Date | null
    notes: string | null
    authorId: string | null
    controlPointId: string | null
    attachmentId: string | null
  }

  export type PhotoEntryMaxAggregateOutputType = {
    id: string | null
    url: string | null
    date: Date | null
    notes: string | null
    authorId: string | null
    controlPointId: string | null
    attachmentId: string | null
  }

  export type PhotoEntryCountAggregateOutputType = {
    id: number
    url: number
    date: number
    notes: number
    authorId: number
    controlPointId: number
    attachmentId: number
    _all: number
  }


  export type PhotoEntryMinAggregateInputType = {
    id?: true
    url?: true
    date?: true
    notes?: true
    authorId?: true
    controlPointId?: true
    attachmentId?: true
  }

  export type PhotoEntryMaxAggregateInputType = {
    id?: true
    url?: true
    date?: true
    notes?: true
    authorId?: true
    controlPointId?: true
    attachmentId?: true
  }

  export type PhotoEntryCountAggregateInputType = {
    id?: true
    url?: true
    date?: true
    notes?: true
    authorId?: true
    controlPointId?: true
    attachmentId?: true
    _all?: true
  }

  export type PhotoEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhotoEntry to aggregate.
     */
    where?: PhotoEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotoEntries to fetch.
     */
    orderBy?: PhotoEntryOrderByWithRelationInput | PhotoEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhotoEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotoEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotoEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhotoEntries
    **/
    _count?: true | PhotoEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhotoEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhotoEntryMaxAggregateInputType
  }

  export type GetPhotoEntryAggregateType<T extends PhotoEntryAggregateArgs> = {
        [P in keyof T & keyof AggregatePhotoEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhotoEntry[P]>
      : GetScalarType<T[P], AggregatePhotoEntry[P]>
  }




  export type PhotoEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhotoEntryWhereInput
    orderBy?: PhotoEntryOrderByWithAggregationInput | PhotoEntryOrderByWithAggregationInput[]
    by: PhotoEntryScalarFieldEnum[] | PhotoEntryScalarFieldEnum
    having?: PhotoEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhotoEntryCountAggregateInputType | true
    _min?: PhotoEntryMinAggregateInputType
    _max?: PhotoEntryMaxAggregateInputType
  }

  export type PhotoEntryGroupByOutputType = {
    id: string
    url: string
    date: Date
    notes: string | null
    authorId: string
    controlPointId: string
    attachmentId: string | null
    _count: PhotoEntryCountAggregateOutputType | null
    _min: PhotoEntryMinAggregateOutputType | null
    _max: PhotoEntryMaxAggregateOutputType | null
  }

  type GetPhotoEntryGroupByPayload<T extends PhotoEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhotoEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhotoEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhotoEntryGroupByOutputType[P]>
            : GetScalarType<T[P], PhotoEntryGroupByOutputType[P]>
        }
      >
    >


  export type PhotoEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    date?: boolean
    notes?: boolean
    authorId?: boolean
    controlPointId?: boolean
    attachmentId?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    controlPoint?: boolean | ControlPointDefaultArgs<ExtArgs>
    attachment?: boolean | PhotoEntry$attachmentArgs<ExtArgs>
  }, ExtArgs["result"]["photoEntry"]>


  export type PhotoEntrySelectScalar = {
    id?: boolean
    url?: boolean
    date?: boolean
    notes?: boolean
    authorId?: boolean
    controlPointId?: boolean
    attachmentId?: boolean
  }

  export type PhotoEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    controlPoint?: boolean | ControlPointDefaultArgs<ExtArgs>
    attachment?: boolean | PhotoEntry$attachmentArgs<ExtArgs>
  }

  export type $PhotoEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PhotoEntry"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      controlPoint: Prisma.$ControlPointPayload<ExtArgs>
      attachment: Prisma.$AttachmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      date: Date
      notes: string | null
      authorId: string
      controlPointId: string
      attachmentId: string | null
    }, ExtArgs["result"]["photoEntry"]>
    composites: {}
  }

  type PhotoEntryGetPayload<S extends boolean | null | undefined | PhotoEntryDefaultArgs> = $Result.GetResult<Prisma.$PhotoEntryPayload, S>

  type PhotoEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PhotoEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PhotoEntryCountAggregateInputType | true
    }

  export interface PhotoEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PhotoEntry'], meta: { name: 'PhotoEntry' } }
    /**
     * Find zero or one PhotoEntry that matches the filter.
     * @param {PhotoEntryFindUniqueArgs} args - Arguments to find a PhotoEntry
     * @example
     * // Get one PhotoEntry
     * const photoEntry = await prisma.photoEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhotoEntryFindUniqueArgs>(args: SelectSubset<T, PhotoEntryFindUniqueArgs<ExtArgs>>): Prisma__PhotoEntryClient<$Result.GetResult<Prisma.$PhotoEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PhotoEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PhotoEntryFindUniqueOrThrowArgs} args - Arguments to find a PhotoEntry
     * @example
     * // Get one PhotoEntry
     * const photoEntry = await prisma.photoEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhotoEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, PhotoEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhotoEntryClient<$Result.GetResult<Prisma.$PhotoEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PhotoEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoEntryFindFirstArgs} args - Arguments to find a PhotoEntry
     * @example
     * // Get one PhotoEntry
     * const photoEntry = await prisma.photoEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhotoEntryFindFirstArgs>(args?: SelectSubset<T, PhotoEntryFindFirstArgs<ExtArgs>>): Prisma__PhotoEntryClient<$Result.GetResult<Prisma.$PhotoEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PhotoEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoEntryFindFirstOrThrowArgs} args - Arguments to find a PhotoEntry
     * @example
     * // Get one PhotoEntry
     * const photoEntry = await prisma.photoEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhotoEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, PhotoEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhotoEntryClient<$Result.GetResult<Prisma.$PhotoEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PhotoEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhotoEntries
     * const photoEntries = await prisma.photoEntry.findMany()
     * 
     * // Get first 10 PhotoEntries
     * const photoEntries = await prisma.photoEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const photoEntryWithIdOnly = await prisma.photoEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhotoEntryFindManyArgs>(args?: SelectSubset<T, PhotoEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotoEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PhotoEntry.
     * @param {PhotoEntryCreateArgs} args - Arguments to create a PhotoEntry.
     * @example
     * // Create one PhotoEntry
     * const PhotoEntry = await prisma.photoEntry.create({
     *   data: {
     *     // ... data to create a PhotoEntry
     *   }
     * })
     * 
     */
    create<T extends PhotoEntryCreateArgs>(args: SelectSubset<T, PhotoEntryCreateArgs<ExtArgs>>): Prisma__PhotoEntryClient<$Result.GetResult<Prisma.$PhotoEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PhotoEntries.
     * @param {PhotoEntryCreateManyArgs} args - Arguments to create many PhotoEntries.
     * @example
     * // Create many PhotoEntries
     * const photoEntry = await prisma.photoEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhotoEntryCreateManyArgs>(args?: SelectSubset<T, PhotoEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PhotoEntry.
     * @param {PhotoEntryDeleteArgs} args - Arguments to delete one PhotoEntry.
     * @example
     * // Delete one PhotoEntry
     * const PhotoEntry = await prisma.photoEntry.delete({
     *   where: {
     *     // ... filter to delete one PhotoEntry
     *   }
     * })
     * 
     */
    delete<T extends PhotoEntryDeleteArgs>(args: SelectSubset<T, PhotoEntryDeleteArgs<ExtArgs>>): Prisma__PhotoEntryClient<$Result.GetResult<Prisma.$PhotoEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PhotoEntry.
     * @param {PhotoEntryUpdateArgs} args - Arguments to update one PhotoEntry.
     * @example
     * // Update one PhotoEntry
     * const photoEntry = await prisma.photoEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhotoEntryUpdateArgs>(args: SelectSubset<T, PhotoEntryUpdateArgs<ExtArgs>>): Prisma__PhotoEntryClient<$Result.GetResult<Prisma.$PhotoEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PhotoEntries.
     * @param {PhotoEntryDeleteManyArgs} args - Arguments to filter PhotoEntries to delete.
     * @example
     * // Delete a few PhotoEntries
     * const { count } = await prisma.photoEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhotoEntryDeleteManyArgs>(args?: SelectSubset<T, PhotoEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhotoEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhotoEntries
     * const photoEntry = await prisma.photoEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhotoEntryUpdateManyArgs>(args: SelectSubset<T, PhotoEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PhotoEntry.
     * @param {PhotoEntryUpsertArgs} args - Arguments to update or create a PhotoEntry.
     * @example
     * // Update or create a PhotoEntry
     * const photoEntry = await prisma.photoEntry.upsert({
     *   create: {
     *     // ... data to create a PhotoEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhotoEntry we want to update
     *   }
     * })
     */
    upsert<T extends PhotoEntryUpsertArgs>(args: SelectSubset<T, PhotoEntryUpsertArgs<ExtArgs>>): Prisma__PhotoEntryClient<$Result.GetResult<Prisma.$PhotoEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PhotoEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoEntryCountArgs} args - Arguments to filter PhotoEntries to count.
     * @example
     * // Count the number of PhotoEntries
     * const count = await prisma.photoEntry.count({
     *   where: {
     *     // ... the filter for the PhotoEntries we want to count
     *   }
     * })
    **/
    count<T extends PhotoEntryCountArgs>(
      args?: Subset<T, PhotoEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhotoEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhotoEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhotoEntryAggregateArgs>(args: Subset<T, PhotoEntryAggregateArgs>): Prisma.PrismaPromise<GetPhotoEntryAggregateType<T>>

    /**
     * Group by PhotoEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhotoEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhotoEntryGroupByArgs['orderBy'] }
        : { orderBy?: PhotoEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhotoEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotoEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PhotoEntry model
   */
  readonly fields: PhotoEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PhotoEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhotoEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    controlPoint<T extends ControlPointDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ControlPointDefaultArgs<ExtArgs>>): Prisma__ControlPointClient<$Result.GetResult<Prisma.$ControlPointPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    attachment<T extends PhotoEntry$attachmentArgs<ExtArgs> = {}>(args?: Subset<T, PhotoEntry$attachmentArgs<ExtArgs>>): Prisma__AttachmentClient<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PhotoEntry model
   */ 
  interface PhotoEntryFieldRefs {
    readonly id: FieldRef<"PhotoEntry", 'String'>
    readonly url: FieldRef<"PhotoEntry", 'String'>
    readonly date: FieldRef<"PhotoEntry", 'DateTime'>
    readonly notes: FieldRef<"PhotoEntry", 'String'>
    readonly authorId: FieldRef<"PhotoEntry", 'String'>
    readonly controlPointId: FieldRef<"PhotoEntry", 'String'>
    readonly attachmentId: FieldRef<"PhotoEntry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PhotoEntry findUnique
   */
  export type PhotoEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoEntry
     */
    select?: PhotoEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoEntryInclude<ExtArgs> | null
    /**
     * Filter, which PhotoEntry to fetch.
     */
    where: PhotoEntryWhereUniqueInput
  }

  /**
   * PhotoEntry findUniqueOrThrow
   */
  export type PhotoEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoEntry
     */
    select?: PhotoEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoEntryInclude<ExtArgs> | null
    /**
     * Filter, which PhotoEntry to fetch.
     */
    where: PhotoEntryWhereUniqueInput
  }

  /**
   * PhotoEntry findFirst
   */
  export type PhotoEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoEntry
     */
    select?: PhotoEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoEntryInclude<ExtArgs> | null
    /**
     * Filter, which PhotoEntry to fetch.
     */
    where?: PhotoEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotoEntries to fetch.
     */
    orderBy?: PhotoEntryOrderByWithRelationInput | PhotoEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhotoEntries.
     */
    cursor?: PhotoEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotoEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotoEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhotoEntries.
     */
    distinct?: PhotoEntryScalarFieldEnum | PhotoEntryScalarFieldEnum[]
  }

  /**
   * PhotoEntry findFirstOrThrow
   */
  export type PhotoEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoEntry
     */
    select?: PhotoEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoEntryInclude<ExtArgs> | null
    /**
     * Filter, which PhotoEntry to fetch.
     */
    where?: PhotoEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotoEntries to fetch.
     */
    orderBy?: PhotoEntryOrderByWithRelationInput | PhotoEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhotoEntries.
     */
    cursor?: PhotoEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotoEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotoEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhotoEntries.
     */
    distinct?: PhotoEntryScalarFieldEnum | PhotoEntryScalarFieldEnum[]
  }

  /**
   * PhotoEntry findMany
   */
  export type PhotoEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoEntry
     */
    select?: PhotoEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoEntryInclude<ExtArgs> | null
    /**
     * Filter, which PhotoEntries to fetch.
     */
    where?: PhotoEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhotoEntries to fetch.
     */
    orderBy?: PhotoEntryOrderByWithRelationInput | PhotoEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhotoEntries.
     */
    cursor?: PhotoEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhotoEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhotoEntries.
     */
    skip?: number
    distinct?: PhotoEntryScalarFieldEnum | PhotoEntryScalarFieldEnum[]
  }

  /**
   * PhotoEntry create
   */
  export type PhotoEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoEntry
     */
    select?: PhotoEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a PhotoEntry.
     */
    data: XOR<PhotoEntryCreateInput, PhotoEntryUncheckedCreateInput>
  }

  /**
   * PhotoEntry createMany
   */
  export type PhotoEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PhotoEntries.
     */
    data: PhotoEntryCreateManyInput | PhotoEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PhotoEntry update
   */
  export type PhotoEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoEntry
     */
    select?: PhotoEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a PhotoEntry.
     */
    data: XOR<PhotoEntryUpdateInput, PhotoEntryUncheckedUpdateInput>
    /**
     * Choose, which PhotoEntry to update.
     */
    where: PhotoEntryWhereUniqueInput
  }

  /**
   * PhotoEntry updateMany
   */
  export type PhotoEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PhotoEntries.
     */
    data: XOR<PhotoEntryUpdateManyMutationInput, PhotoEntryUncheckedUpdateManyInput>
    /**
     * Filter which PhotoEntries to update
     */
    where?: PhotoEntryWhereInput
  }

  /**
   * PhotoEntry upsert
   */
  export type PhotoEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoEntry
     */
    select?: PhotoEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the PhotoEntry to update in case it exists.
     */
    where: PhotoEntryWhereUniqueInput
    /**
     * In case the PhotoEntry found by the `where` argument doesn't exist, create a new PhotoEntry with this data.
     */
    create: XOR<PhotoEntryCreateInput, PhotoEntryUncheckedCreateInput>
    /**
     * In case the PhotoEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhotoEntryUpdateInput, PhotoEntryUncheckedUpdateInput>
  }

  /**
   * PhotoEntry delete
   */
  export type PhotoEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoEntry
     */
    select?: PhotoEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoEntryInclude<ExtArgs> | null
    /**
     * Filter which PhotoEntry to delete.
     */
    where: PhotoEntryWhereUniqueInput
  }

  /**
   * PhotoEntry deleteMany
   */
  export type PhotoEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhotoEntries to delete
     */
    where?: PhotoEntryWhereInput
  }

  /**
   * PhotoEntry.attachment
   */
  export type PhotoEntry$attachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
  }

  /**
   * PhotoEntry without action
   */
  export type PhotoEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoEntry
     */
    select?: PhotoEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoEntryInclude<ExtArgs> | null
  }


  /**
   * Model ControlPoint
   */

  export type AggregateControlPoint = {
    _count: ControlPointCountAggregateOutputType | null
    _min: ControlPointMinAggregateOutputType | null
    _max: ControlPointMaxAggregateOutputType | null
  }

  export type ControlPointMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ControlPointMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ControlPointCountAggregateOutputType = {
    id: number
    name: number
    description: number
    location: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ControlPointMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ControlPointMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ControlPointCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    location?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ControlPointAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ControlPoint to aggregate.
     */
    where?: ControlPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ControlPoints to fetch.
     */
    orderBy?: ControlPointOrderByWithRelationInput | ControlPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ControlPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ControlPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ControlPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ControlPoints
    **/
    _count?: true | ControlPointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ControlPointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ControlPointMaxAggregateInputType
  }

  export type GetControlPointAggregateType<T extends ControlPointAggregateArgs> = {
        [P in keyof T & keyof AggregateControlPoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateControlPoint[P]>
      : GetScalarType<T[P], AggregateControlPoint[P]>
  }




  export type ControlPointGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ControlPointWhereInput
    orderBy?: ControlPointOrderByWithAggregationInput | ControlPointOrderByWithAggregationInput[]
    by: ControlPointScalarFieldEnum[] | ControlPointScalarFieldEnum
    having?: ControlPointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ControlPointCountAggregateInputType | true
    _min?: ControlPointMinAggregateInputType
    _max?: ControlPointMaxAggregateInputType
  }

  export type ControlPointGroupByOutputType = {
    id: string
    name: string
    description: string | null
    location: string | null
    createdAt: Date
    updatedAt: Date
    _count: ControlPointCountAggregateOutputType | null
    _min: ControlPointMinAggregateOutputType | null
    _max: ControlPointMaxAggregateOutputType | null
  }

  type GetControlPointGroupByPayload<T extends ControlPointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ControlPointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ControlPointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ControlPointGroupByOutputType[P]>
            : GetScalarType<T[P], ControlPointGroupByOutputType[P]>
        }
      >
    >


  export type ControlPointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    photos?: boolean | ControlPoint$photosArgs<ExtArgs>
    _count?: boolean | ControlPointCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["controlPoint"]>


  export type ControlPointSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ControlPointInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | ControlPoint$photosArgs<ExtArgs>
    _count?: boolean | ControlPointCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ControlPointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ControlPoint"
    objects: {
      photos: Prisma.$PhotoEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      location: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["controlPoint"]>
    composites: {}
  }

  type ControlPointGetPayload<S extends boolean | null | undefined | ControlPointDefaultArgs> = $Result.GetResult<Prisma.$ControlPointPayload, S>

  type ControlPointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ControlPointFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ControlPointCountAggregateInputType | true
    }

  export interface ControlPointDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ControlPoint'], meta: { name: 'ControlPoint' } }
    /**
     * Find zero or one ControlPoint that matches the filter.
     * @param {ControlPointFindUniqueArgs} args - Arguments to find a ControlPoint
     * @example
     * // Get one ControlPoint
     * const controlPoint = await prisma.controlPoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ControlPointFindUniqueArgs>(args: SelectSubset<T, ControlPointFindUniqueArgs<ExtArgs>>): Prisma__ControlPointClient<$Result.GetResult<Prisma.$ControlPointPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ControlPoint that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ControlPointFindUniqueOrThrowArgs} args - Arguments to find a ControlPoint
     * @example
     * // Get one ControlPoint
     * const controlPoint = await prisma.controlPoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ControlPointFindUniqueOrThrowArgs>(args: SelectSubset<T, ControlPointFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ControlPointClient<$Result.GetResult<Prisma.$ControlPointPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ControlPoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlPointFindFirstArgs} args - Arguments to find a ControlPoint
     * @example
     * // Get one ControlPoint
     * const controlPoint = await prisma.controlPoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ControlPointFindFirstArgs>(args?: SelectSubset<T, ControlPointFindFirstArgs<ExtArgs>>): Prisma__ControlPointClient<$Result.GetResult<Prisma.$ControlPointPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ControlPoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlPointFindFirstOrThrowArgs} args - Arguments to find a ControlPoint
     * @example
     * // Get one ControlPoint
     * const controlPoint = await prisma.controlPoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ControlPointFindFirstOrThrowArgs>(args?: SelectSubset<T, ControlPointFindFirstOrThrowArgs<ExtArgs>>): Prisma__ControlPointClient<$Result.GetResult<Prisma.$ControlPointPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ControlPoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlPointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ControlPoints
     * const controlPoints = await prisma.controlPoint.findMany()
     * 
     * // Get first 10 ControlPoints
     * const controlPoints = await prisma.controlPoint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const controlPointWithIdOnly = await prisma.controlPoint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ControlPointFindManyArgs>(args?: SelectSubset<T, ControlPointFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ControlPointPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ControlPoint.
     * @param {ControlPointCreateArgs} args - Arguments to create a ControlPoint.
     * @example
     * // Create one ControlPoint
     * const ControlPoint = await prisma.controlPoint.create({
     *   data: {
     *     // ... data to create a ControlPoint
     *   }
     * })
     * 
     */
    create<T extends ControlPointCreateArgs>(args: SelectSubset<T, ControlPointCreateArgs<ExtArgs>>): Prisma__ControlPointClient<$Result.GetResult<Prisma.$ControlPointPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ControlPoints.
     * @param {ControlPointCreateManyArgs} args - Arguments to create many ControlPoints.
     * @example
     * // Create many ControlPoints
     * const controlPoint = await prisma.controlPoint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ControlPointCreateManyArgs>(args?: SelectSubset<T, ControlPointCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ControlPoint.
     * @param {ControlPointDeleteArgs} args - Arguments to delete one ControlPoint.
     * @example
     * // Delete one ControlPoint
     * const ControlPoint = await prisma.controlPoint.delete({
     *   where: {
     *     // ... filter to delete one ControlPoint
     *   }
     * })
     * 
     */
    delete<T extends ControlPointDeleteArgs>(args: SelectSubset<T, ControlPointDeleteArgs<ExtArgs>>): Prisma__ControlPointClient<$Result.GetResult<Prisma.$ControlPointPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ControlPoint.
     * @param {ControlPointUpdateArgs} args - Arguments to update one ControlPoint.
     * @example
     * // Update one ControlPoint
     * const controlPoint = await prisma.controlPoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ControlPointUpdateArgs>(args: SelectSubset<T, ControlPointUpdateArgs<ExtArgs>>): Prisma__ControlPointClient<$Result.GetResult<Prisma.$ControlPointPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ControlPoints.
     * @param {ControlPointDeleteManyArgs} args - Arguments to filter ControlPoints to delete.
     * @example
     * // Delete a few ControlPoints
     * const { count } = await prisma.controlPoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ControlPointDeleteManyArgs>(args?: SelectSubset<T, ControlPointDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ControlPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlPointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ControlPoints
     * const controlPoint = await prisma.controlPoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ControlPointUpdateManyArgs>(args: SelectSubset<T, ControlPointUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ControlPoint.
     * @param {ControlPointUpsertArgs} args - Arguments to update or create a ControlPoint.
     * @example
     * // Update or create a ControlPoint
     * const controlPoint = await prisma.controlPoint.upsert({
     *   create: {
     *     // ... data to create a ControlPoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ControlPoint we want to update
     *   }
     * })
     */
    upsert<T extends ControlPointUpsertArgs>(args: SelectSubset<T, ControlPointUpsertArgs<ExtArgs>>): Prisma__ControlPointClient<$Result.GetResult<Prisma.$ControlPointPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ControlPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlPointCountArgs} args - Arguments to filter ControlPoints to count.
     * @example
     * // Count the number of ControlPoints
     * const count = await prisma.controlPoint.count({
     *   where: {
     *     // ... the filter for the ControlPoints we want to count
     *   }
     * })
    **/
    count<T extends ControlPointCountArgs>(
      args?: Subset<T, ControlPointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ControlPointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ControlPoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlPointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ControlPointAggregateArgs>(args: Subset<T, ControlPointAggregateArgs>): Prisma.PrismaPromise<GetControlPointAggregateType<T>>

    /**
     * Group by ControlPoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlPointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ControlPointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ControlPointGroupByArgs['orderBy'] }
        : { orderBy?: ControlPointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ControlPointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetControlPointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ControlPoint model
   */
  readonly fields: ControlPointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ControlPoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ControlPointClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photos<T extends ControlPoint$photosArgs<ExtArgs> = {}>(args?: Subset<T, ControlPoint$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotoEntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ControlPoint model
   */ 
  interface ControlPointFieldRefs {
    readonly id: FieldRef<"ControlPoint", 'String'>
    readonly name: FieldRef<"ControlPoint", 'String'>
    readonly description: FieldRef<"ControlPoint", 'String'>
    readonly location: FieldRef<"ControlPoint", 'String'>
    readonly createdAt: FieldRef<"ControlPoint", 'DateTime'>
    readonly updatedAt: FieldRef<"ControlPoint", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ControlPoint findUnique
   */
  export type ControlPointFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlPoint
     */
    select?: ControlPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlPointInclude<ExtArgs> | null
    /**
     * Filter, which ControlPoint to fetch.
     */
    where: ControlPointWhereUniqueInput
  }

  /**
   * ControlPoint findUniqueOrThrow
   */
  export type ControlPointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlPoint
     */
    select?: ControlPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlPointInclude<ExtArgs> | null
    /**
     * Filter, which ControlPoint to fetch.
     */
    where: ControlPointWhereUniqueInput
  }

  /**
   * ControlPoint findFirst
   */
  export type ControlPointFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlPoint
     */
    select?: ControlPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlPointInclude<ExtArgs> | null
    /**
     * Filter, which ControlPoint to fetch.
     */
    where?: ControlPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ControlPoints to fetch.
     */
    orderBy?: ControlPointOrderByWithRelationInput | ControlPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ControlPoints.
     */
    cursor?: ControlPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ControlPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ControlPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ControlPoints.
     */
    distinct?: ControlPointScalarFieldEnum | ControlPointScalarFieldEnum[]
  }

  /**
   * ControlPoint findFirstOrThrow
   */
  export type ControlPointFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlPoint
     */
    select?: ControlPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlPointInclude<ExtArgs> | null
    /**
     * Filter, which ControlPoint to fetch.
     */
    where?: ControlPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ControlPoints to fetch.
     */
    orderBy?: ControlPointOrderByWithRelationInput | ControlPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ControlPoints.
     */
    cursor?: ControlPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ControlPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ControlPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ControlPoints.
     */
    distinct?: ControlPointScalarFieldEnum | ControlPointScalarFieldEnum[]
  }

  /**
   * ControlPoint findMany
   */
  export type ControlPointFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlPoint
     */
    select?: ControlPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlPointInclude<ExtArgs> | null
    /**
     * Filter, which ControlPoints to fetch.
     */
    where?: ControlPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ControlPoints to fetch.
     */
    orderBy?: ControlPointOrderByWithRelationInput | ControlPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ControlPoints.
     */
    cursor?: ControlPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ControlPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ControlPoints.
     */
    skip?: number
    distinct?: ControlPointScalarFieldEnum | ControlPointScalarFieldEnum[]
  }

  /**
   * ControlPoint create
   */
  export type ControlPointCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlPoint
     */
    select?: ControlPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlPointInclude<ExtArgs> | null
    /**
     * The data needed to create a ControlPoint.
     */
    data: XOR<ControlPointCreateInput, ControlPointUncheckedCreateInput>
  }

  /**
   * ControlPoint createMany
   */
  export type ControlPointCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ControlPoints.
     */
    data: ControlPointCreateManyInput | ControlPointCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ControlPoint update
   */
  export type ControlPointUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlPoint
     */
    select?: ControlPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlPointInclude<ExtArgs> | null
    /**
     * The data needed to update a ControlPoint.
     */
    data: XOR<ControlPointUpdateInput, ControlPointUncheckedUpdateInput>
    /**
     * Choose, which ControlPoint to update.
     */
    where: ControlPointWhereUniqueInput
  }

  /**
   * ControlPoint updateMany
   */
  export type ControlPointUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ControlPoints.
     */
    data: XOR<ControlPointUpdateManyMutationInput, ControlPointUncheckedUpdateManyInput>
    /**
     * Filter which ControlPoints to update
     */
    where?: ControlPointWhereInput
  }

  /**
   * ControlPoint upsert
   */
  export type ControlPointUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlPoint
     */
    select?: ControlPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlPointInclude<ExtArgs> | null
    /**
     * The filter to search for the ControlPoint to update in case it exists.
     */
    where: ControlPointWhereUniqueInput
    /**
     * In case the ControlPoint found by the `where` argument doesn't exist, create a new ControlPoint with this data.
     */
    create: XOR<ControlPointCreateInput, ControlPointUncheckedCreateInput>
    /**
     * In case the ControlPoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ControlPointUpdateInput, ControlPointUncheckedUpdateInput>
  }

  /**
   * ControlPoint delete
   */
  export type ControlPointDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlPoint
     */
    select?: ControlPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlPointInclude<ExtArgs> | null
    /**
     * Filter which ControlPoint to delete.
     */
    where: ControlPointWhereUniqueInput
  }

  /**
   * ControlPoint deleteMany
   */
  export type ControlPointDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ControlPoints to delete
     */
    where?: ControlPointWhereInput
  }

  /**
   * ControlPoint.photos
   */
  export type ControlPoint$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhotoEntry
     */
    select?: PhotoEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhotoEntryInclude<ExtArgs> | null
    where?: PhotoEntryWhereInput
    orderBy?: PhotoEntryOrderByWithRelationInput | PhotoEntryOrderByWithRelationInput[]
    cursor?: PhotoEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhotoEntryScalarFieldEnum | PhotoEntryScalarFieldEnum[]
  }

  /**
   * ControlPoint without action
   */
  export type ControlPointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlPoint
     */
    select?: ControlPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlPointInclude<ExtArgs> | null
  }


  /**
   * Model ProjectTask
   */

  export type AggregateProjectTask = {
    _count: ProjectTaskCountAggregateOutputType | null
    _avg: ProjectTaskAvgAggregateOutputType | null
    _sum: ProjectTaskSumAggregateOutputType | null
    _min: ProjectTaskMinAggregateOutputType | null
    _max: ProjectTaskMaxAggregateOutputType | null
  }

  export type ProjectTaskAvgAggregateOutputType = {
    progress: number | null
    duration: number | null
    outlineLevel: number | null
  }

  export type ProjectTaskSumAggregateOutputType = {
    progress: number | null
    duration: number | null
    outlineLevel: number | null
  }

  export type ProjectTaskMinAggregateOutputType = {
    id: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    progress: number | null
    duration: number | null
    isSummary: boolean | null
    outlineLevel: number | null
    dependencies: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectTaskMaxAggregateOutputType = {
    id: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    progress: number | null
    duration: number | null
    isSummary: boolean | null
    outlineLevel: number | null
    dependencies: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectTaskCountAggregateOutputType = {
    id: number
    name: number
    startDate: number
    endDate: number
    progress: number
    duration: number
    isSummary: number
    outlineLevel: number
    dependencies: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectTaskAvgAggregateInputType = {
    progress?: true
    duration?: true
    outlineLevel?: true
  }

  export type ProjectTaskSumAggregateInputType = {
    progress?: true
    duration?: true
    outlineLevel?: true
  }

  export type ProjectTaskMinAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    progress?: true
    duration?: true
    isSummary?: true
    outlineLevel?: true
    dependencies?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectTaskMaxAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    progress?: true
    duration?: true
    isSummary?: true
    outlineLevel?: true
    dependencies?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectTaskCountAggregateInputType = {
    id?: true
    name?: true
    startDate?: true
    endDate?: true
    progress?: true
    duration?: true
    isSummary?: true
    outlineLevel?: true
    dependencies?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectTask to aggregate.
     */
    where?: ProjectTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTasks to fetch.
     */
    orderBy?: ProjectTaskOrderByWithRelationInput | ProjectTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectTasks
    **/
    _count?: true | ProjectTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectTaskMaxAggregateInputType
  }

  export type GetProjectTaskAggregateType<T extends ProjectTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectTask[P]>
      : GetScalarType<T[P], AggregateProjectTask[P]>
  }




  export type ProjectTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTaskWhereInput
    orderBy?: ProjectTaskOrderByWithAggregationInput | ProjectTaskOrderByWithAggregationInput[]
    by: ProjectTaskScalarFieldEnum[] | ProjectTaskScalarFieldEnum
    having?: ProjectTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectTaskCountAggregateInputType | true
    _avg?: ProjectTaskAvgAggregateInputType
    _sum?: ProjectTaskSumAggregateInputType
    _min?: ProjectTaskMinAggregateInputType
    _max?: ProjectTaskMaxAggregateInputType
  }

  export type ProjectTaskGroupByOutputType = {
    id: string
    name: string
    startDate: Date
    endDate: Date
    progress: number
    duration: number
    isSummary: boolean
    outlineLevel: number
    dependencies: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectTaskCountAggregateOutputType | null
    _avg: ProjectTaskAvgAggregateOutputType | null
    _sum: ProjectTaskSumAggregateOutputType | null
    _min: ProjectTaskMinAggregateOutputType | null
    _max: ProjectTaskMaxAggregateOutputType | null
  }

  type GetProjectTaskGroupByPayload<T extends ProjectTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectTaskGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectTaskGroupByOutputType[P]>
        }
      >
    >


  export type ProjectTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    progress?: boolean
    duration?: boolean
    isSummary?: boolean
    outlineLevel?: boolean
    dependencies?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["projectTask"]>


  export type ProjectTaskSelectScalar = {
    id?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    progress?: boolean
    duration?: boolean
    isSummary?: boolean
    outlineLevel?: boolean
    dependencies?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $ProjectTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectTask"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      startDate: Date
      endDate: Date
      progress: number
      duration: number
      isSummary: boolean
      outlineLevel: number
      dependencies: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projectTask"]>
    composites: {}
  }

  type ProjectTaskGetPayload<S extends boolean | null | undefined | ProjectTaskDefaultArgs> = $Result.GetResult<Prisma.$ProjectTaskPayload, S>

  type ProjectTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProjectTaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjectTaskCountAggregateInputType | true
    }

  export interface ProjectTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectTask'], meta: { name: 'ProjectTask' } }
    /**
     * Find zero or one ProjectTask that matches the filter.
     * @param {ProjectTaskFindUniqueArgs} args - Arguments to find a ProjectTask
     * @example
     * // Get one ProjectTask
     * const projectTask = await prisma.projectTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectTaskFindUniqueArgs>(args: SelectSubset<T, ProjectTaskFindUniqueArgs<ExtArgs>>): Prisma__ProjectTaskClient<$Result.GetResult<Prisma.$ProjectTaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProjectTask that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProjectTaskFindUniqueOrThrowArgs} args - Arguments to find a ProjectTask
     * @example
     * // Get one ProjectTask
     * const projectTask = await prisma.projectTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectTaskClient<$Result.GetResult<Prisma.$ProjectTaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProjectTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskFindFirstArgs} args - Arguments to find a ProjectTask
     * @example
     * // Get one ProjectTask
     * const projectTask = await prisma.projectTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectTaskFindFirstArgs>(args?: SelectSubset<T, ProjectTaskFindFirstArgs<ExtArgs>>): Prisma__ProjectTaskClient<$Result.GetResult<Prisma.$ProjectTaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProjectTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskFindFirstOrThrowArgs} args - Arguments to find a ProjectTask
     * @example
     * // Get one ProjectTask
     * const projectTask = await prisma.projectTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectTaskClient<$Result.GetResult<Prisma.$ProjectTaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProjectTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectTasks
     * const projectTasks = await prisma.projectTask.findMany()
     * 
     * // Get first 10 ProjectTasks
     * const projectTasks = await prisma.projectTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectTaskWithIdOnly = await prisma.projectTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectTaskFindManyArgs>(args?: SelectSubset<T, ProjectTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProjectTask.
     * @param {ProjectTaskCreateArgs} args - Arguments to create a ProjectTask.
     * @example
     * // Create one ProjectTask
     * const ProjectTask = await prisma.projectTask.create({
     *   data: {
     *     // ... data to create a ProjectTask
     *   }
     * })
     * 
     */
    create<T extends ProjectTaskCreateArgs>(args: SelectSubset<T, ProjectTaskCreateArgs<ExtArgs>>): Prisma__ProjectTaskClient<$Result.GetResult<Prisma.$ProjectTaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProjectTasks.
     * @param {ProjectTaskCreateManyArgs} args - Arguments to create many ProjectTasks.
     * @example
     * // Create many ProjectTasks
     * const projectTask = await prisma.projectTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectTaskCreateManyArgs>(args?: SelectSubset<T, ProjectTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProjectTask.
     * @param {ProjectTaskDeleteArgs} args - Arguments to delete one ProjectTask.
     * @example
     * // Delete one ProjectTask
     * const ProjectTask = await prisma.projectTask.delete({
     *   where: {
     *     // ... filter to delete one ProjectTask
     *   }
     * })
     * 
     */
    delete<T extends ProjectTaskDeleteArgs>(args: SelectSubset<T, ProjectTaskDeleteArgs<ExtArgs>>): Prisma__ProjectTaskClient<$Result.GetResult<Prisma.$ProjectTaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProjectTask.
     * @param {ProjectTaskUpdateArgs} args - Arguments to update one ProjectTask.
     * @example
     * // Update one ProjectTask
     * const projectTask = await prisma.projectTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectTaskUpdateArgs>(args: SelectSubset<T, ProjectTaskUpdateArgs<ExtArgs>>): Prisma__ProjectTaskClient<$Result.GetResult<Prisma.$ProjectTaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProjectTasks.
     * @param {ProjectTaskDeleteManyArgs} args - Arguments to filter ProjectTasks to delete.
     * @example
     * // Delete a few ProjectTasks
     * const { count } = await prisma.projectTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectTaskDeleteManyArgs>(args?: SelectSubset<T, ProjectTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectTasks
     * const projectTask = await prisma.projectTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectTaskUpdateManyArgs>(args: SelectSubset<T, ProjectTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProjectTask.
     * @param {ProjectTaskUpsertArgs} args - Arguments to update or create a ProjectTask.
     * @example
     * // Update or create a ProjectTask
     * const projectTask = await prisma.projectTask.upsert({
     *   create: {
     *     // ... data to create a ProjectTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectTask we want to update
     *   }
     * })
     */
    upsert<T extends ProjectTaskUpsertArgs>(args: SelectSubset<T, ProjectTaskUpsertArgs<ExtArgs>>): Prisma__ProjectTaskClient<$Result.GetResult<Prisma.$ProjectTaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProjectTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskCountArgs} args - Arguments to filter ProjectTasks to count.
     * @example
     * // Count the number of ProjectTasks
     * const count = await prisma.projectTask.count({
     *   where: {
     *     // ... the filter for the ProjectTasks we want to count
     *   }
     * })
    **/
    count<T extends ProjectTaskCountArgs>(
      args?: Subset<T, ProjectTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectTaskAggregateArgs>(args: Subset<T, ProjectTaskAggregateArgs>): Prisma.PrismaPromise<GetProjectTaskAggregateType<T>>

    /**
     * Group by ProjectTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectTaskGroupByArgs['orderBy'] }
        : { orderBy?: ProjectTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectTask model
   */
  readonly fields: ProjectTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectTask model
   */ 
  interface ProjectTaskFieldRefs {
    readonly id: FieldRef<"ProjectTask", 'String'>
    readonly name: FieldRef<"ProjectTask", 'String'>
    readonly startDate: FieldRef<"ProjectTask", 'DateTime'>
    readonly endDate: FieldRef<"ProjectTask", 'DateTime'>
    readonly progress: FieldRef<"ProjectTask", 'Int'>
    readonly duration: FieldRef<"ProjectTask", 'Int'>
    readonly isSummary: FieldRef<"ProjectTask", 'Boolean'>
    readonly outlineLevel: FieldRef<"ProjectTask", 'Int'>
    readonly dependencies: FieldRef<"ProjectTask", 'String'>
    readonly createdAt: FieldRef<"ProjectTask", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectTask findUnique
   */
  export type ProjectTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelect<ExtArgs> | null
    /**
     * Filter, which ProjectTask to fetch.
     */
    where: ProjectTaskWhereUniqueInput
  }

  /**
   * ProjectTask findUniqueOrThrow
   */
  export type ProjectTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelect<ExtArgs> | null
    /**
     * Filter, which ProjectTask to fetch.
     */
    where: ProjectTaskWhereUniqueInput
  }

  /**
   * ProjectTask findFirst
   */
  export type ProjectTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelect<ExtArgs> | null
    /**
     * Filter, which ProjectTask to fetch.
     */
    where?: ProjectTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTasks to fetch.
     */
    orderBy?: ProjectTaskOrderByWithRelationInput | ProjectTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTasks.
     */
    cursor?: ProjectTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTasks.
     */
    distinct?: ProjectTaskScalarFieldEnum | ProjectTaskScalarFieldEnum[]
  }

  /**
   * ProjectTask findFirstOrThrow
   */
  export type ProjectTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelect<ExtArgs> | null
    /**
     * Filter, which ProjectTask to fetch.
     */
    where?: ProjectTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTasks to fetch.
     */
    orderBy?: ProjectTaskOrderByWithRelationInput | ProjectTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTasks.
     */
    cursor?: ProjectTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTasks.
     */
    distinct?: ProjectTaskScalarFieldEnum | ProjectTaskScalarFieldEnum[]
  }

  /**
   * ProjectTask findMany
   */
  export type ProjectTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelect<ExtArgs> | null
    /**
     * Filter, which ProjectTasks to fetch.
     */
    where?: ProjectTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTasks to fetch.
     */
    orderBy?: ProjectTaskOrderByWithRelationInput | ProjectTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectTasks.
     */
    cursor?: ProjectTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTasks.
     */
    skip?: number
    distinct?: ProjectTaskScalarFieldEnum | ProjectTaskScalarFieldEnum[]
  }

  /**
   * ProjectTask create
   */
  export type ProjectTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelect<ExtArgs> | null
    /**
     * The data needed to create a ProjectTask.
     */
    data: XOR<ProjectTaskCreateInput, ProjectTaskUncheckedCreateInput>
  }

  /**
   * ProjectTask createMany
   */
  export type ProjectTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectTasks.
     */
    data: ProjectTaskCreateManyInput | ProjectTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectTask update
   */
  export type ProjectTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelect<ExtArgs> | null
    /**
     * The data needed to update a ProjectTask.
     */
    data: XOR<ProjectTaskUpdateInput, ProjectTaskUncheckedUpdateInput>
    /**
     * Choose, which ProjectTask to update.
     */
    where: ProjectTaskWhereUniqueInput
  }

  /**
   * ProjectTask updateMany
   */
  export type ProjectTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectTasks.
     */
    data: XOR<ProjectTaskUpdateManyMutationInput, ProjectTaskUncheckedUpdateManyInput>
    /**
     * Filter which ProjectTasks to update
     */
    where?: ProjectTaskWhereInput
  }

  /**
   * ProjectTask upsert
   */
  export type ProjectTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelect<ExtArgs> | null
    /**
     * The filter to search for the ProjectTask to update in case it exists.
     */
    where: ProjectTaskWhereUniqueInput
    /**
     * In case the ProjectTask found by the `where` argument doesn't exist, create a new ProjectTask with this data.
     */
    create: XOR<ProjectTaskCreateInput, ProjectTaskUncheckedCreateInput>
    /**
     * In case the ProjectTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectTaskUpdateInput, ProjectTaskUncheckedUpdateInput>
  }

  /**
   * ProjectTask delete
   */
  export type ProjectTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelect<ExtArgs> | null
    /**
     * Filter which ProjectTask to delete.
     */
    where: ProjectTaskWhereUniqueInput
  }

  /**
   * ProjectTask deleteMany
   */
  export type ProjectTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectTasks to delete
     */
    where?: ProjectTaskWhereInput
  }

  /**
   * ProjectTask without action
   */
  export type ProjectTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTask
     */
    select?: ProjectTaskSelect<ExtArgs> | null
  }


  /**
   * Model ContractItem
   */

  export type AggregateContractItem = {
    _count: ContractItemCountAggregateOutputType | null
    _avg: ContractItemAvgAggregateOutputType | null
    _sum: ContractItemSumAggregateOutputType | null
    _min: ContractItemMinAggregateOutputType | null
    _max: ContractItemMaxAggregateOutputType | null
  }

  export type ContractItemAvgAggregateOutputType = {
    unitPrice: number | null
    contractQuantity: number | null
  }

  export type ContractItemSumAggregateOutputType = {
    unitPrice: number | null
    contractQuantity: number | null
  }

  export type ContractItemMinAggregateOutputType = {
    id: string | null
    itemCode: string | null
    description: string | null
    unit: string | null
    unitPrice: number | null
    contractQuantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractItemMaxAggregateOutputType = {
    id: string | null
    itemCode: string | null
    description: string | null
    unit: string | null
    unitPrice: number | null
    contractQuantity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractItemCountAggregateOutputType = {
    id: number
    itemCode: number
    description: number
    unit: number
    unitPrice: number
    contractQuantity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContractItemAvgAggregateInputType = {
    unitPrice?: true
    contractQuantity?: true
  }

  export type ContractItemSumAggregateInputType = {
    unitPrice?: true
    contractQuantity?: true
  }

  export type ContractItemMinAggregateInputType = {
    id?: true
    itemCode?: true
    description?: true
    unit?: true
    unitPrice?: true
    contractQuantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractItemMaxAggregateInputType = {
    id?: true
    itemCode?: true
    description?: true
    unit?: true
    unitPrice?: true
    contractQuantity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractItemCountAggregateInputType = {
    id?: true
    itemCode?: true
    description?: true
    unit?: true
    unitPrice?: true
    contractQuantity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContractItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractItem to aggregate.
     */
    where?: ContractItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractItems to fetch.
     */
    orderBy?: ContractItemOrderByWithRelationInput | ContractItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContractItems
    **/
    _count?: true | ContractItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractItemMaxAggregateInputType
  }

  export type GetContractItemAggregateType<T extends ContractItemAggregateArgs> = {
        [P in keyof T & keyof AggregateContractItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContractItem[P]>
      : GetScalarType<T[P], AggregateContractItem[P]>
  }




  export type ContractItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractItemWhereInput
    orderBy?: ContractItemOrderByWithAggregationInput | ContractItemOrderByWithAggregationInput[]
    by: ContractItemScalarFieldEnum[] | ContractItemScalarFieldEnum
    having?: ContractItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractItemCountAggregateInputType | true
    _avg?: ContractItemAvgAggregateInputType
    _sum?: ContractItemSumAggregateInputType
    _min?: ContractItemMinAggregateInputType
    _max?: ContractItemMaxAggregateInputType
  }

  export type ContractItemGroupByOutputType = {
    id: string
    itemCode: string
    description: string
    unit: string
    unitPrice: number
    contractQuantity: number
    createdAt: Date
    updatedAt: Date
    _count: ContractItemCountAggregateOutputType | null
    _avg: ContractItemAvgAggregateOutputType | null
    _sum: ContractItemSumAggregateOutputType | null
    _min: ContractItemMinAggregateOutputType | null
    _max: ContractItemMaxAggregateOutputType | null
  }

  type GetContractItemGroupByPayload<T extends ContractItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractItemGroupByOutputType[P]>
            : GetScalarType<T[P], ContractItemGroupByOutputType[P]>
        }
      >
    >


  export type ContractItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemCode?: boolean
    description?: boolean
    unit?: boolean
    unitPrice?: boolean
    contractQuantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workActaItems?: boolean | ContractItem$workActaItemsArgs<ExtArgs>
    _count?: boolean | ContractItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractItem"]>


  export type ContractItemSelectScalar = {
    id?: boolean
    itemCode?: boolean
    description?: boolean
    unit?: boolean
    unitPrice?: boolean
    contractQuantity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContractItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workActaItems?: boolean | ContractItem$workActaItemsArgs<ExtArgs>
    _count?: boolean | ContractItemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ContractItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContractItem"
    objects: {
      workActaItems: Prisma.$WorkActaItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      itemCode: string
      description: string
      unit: string
      unitPrice: number
      contractQuantity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contractItem"]>
    composites: {}
  }

  type ContractItemGetPayload<S extends boolean | null | undefined | ContractItemDefaultArgs> = $Result.GetResult<Prisma.$ContractItemPayload, S>

  type ContractItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContractItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContractItemCountAggregateInputType | true
    }

  export interface ContractItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContractItem'], meta: { name: 'ContractItem' } }
    /**
     * Find zero or one ContractItem that matches the filter.
     * @param {ContractItemFindUniqueArgs} args - Arguments to find a ContractItem
     * @example
     * // Get one ContractItem
     * const contractItem = await prisma.contractItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractItemFindUniqueArgs>(args: SelectSubset<T, ContractItemFindUniqueArgs<ExtArgs>>): Prisma__ContractItemClient<$Result.GetResult<Prisma.$ContractItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContractItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContractItemFindUniqueOrThrowArgs} args - Arguments to find a ContractItem
     * @example
     * // Get one ContractItem
     * const contractItem = await prisma.contractItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractItemClient<$Result.GetResult<Prisma.$ContractItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContractItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractItemFindFirstArgs} args - Arguments to find a ContractItem
     * @example
     * // Get one ContractItem
     * const contractItem = await prisma.contractItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractItemFindFirstArgs>(args?: SelectSubset<T, ContractItemFindFirstArgs<ExtArgs>>): Prisma__ContractItemClient<$Result.GetResult<Prisma.$ContractItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContractItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractItemFindFirstOrThrowArgs} args - Arguments to find a ContractItem
     * @example
     * // Get one ContractItem
     * const contractItem = await prisma.contractItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractItemClient<$Result.GetResult<Prisma.$ContractItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContractItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContractItems
     * const contractItems = await prisma.contractItem.findMany()
     * 
     * // Get first 10 ContractItems
     * const contractItems = await prisma.contractItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractItemWithIdOnly = await prisma.contractItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractItemFindManyArgs>(args?: SelectSubset<T, ContractItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContractItem.
     * @param {ContractItemCreateArgs} args - Arguments to create a ContractItem.
     * @example
     * // Create one ContractItem
     * const ContractItem = await prisma.contractItem.create({
     *   data: {
     *     // ... data to create a ContractItem
     *   }
     * })
     * 
     */
    create<T extends ContractItemCreateArgs>(args: SelectSubset<T, ContractItemCreateArgs<ExtArgs>>): Prisma__ContractItemClient<$Result.GetResult<Prisma.$ContractItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContractItems.
     * @param {ContractItemCreateManyArgs} args - Arguments to create many ContractItems.
     * @example
     * // Create many ContractItems
     * const contractItem = await prisma.contractItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractItemCreateManyArgs>(args?: SelectSubset<T, ContractItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContractItem.
     * @param {ContractItemDeleteArgs} args - Arguments to delete one ContractItem.
     * @example
     * // Delete one ContractItem
     * const ContractItem = await prisma.contractItem.delete({
     *   where: {
     *     // ... filter to delete one ContractItem
     *   }
     * })
     * 
     */
    delete<T extends ContractItemDeleteArgs>(args: SelectSubset<T, ContractItemDeleteArgs<ExtArgs>>): Prisma__ContractItemClient<$Result.GetResult<Prisma.$ContractItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContractItem.
     * @param {ContractItemUpdateArgs} args - Arguments to update one ContractItem.
     * @example
     * // Update one ContractItem
     * const contractItem = await prisma.contractItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractItemUpdateArgs>(args: SelectSubset<T, ContractItemUpdateArgs<ExtArgs>>): Prisma__ContractItemClient<$Result.GetResult<Prisma.$ContractItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContractItems.
     * @param {ContractItemDeleteManyArgs} args - Arguments to filter ContractItems to delete.
     * @example
     * // Delete a few ContractItems
     * const { count } = await prisma.contractItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractItemDeleteManyArgs>(args?: SelectSubset<T, ContractItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContractItems
     * const contractItem = await prisma.contractItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractItemUpdateManyArgs>(args: SelectSubset<T, ContractItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContractItem.
     * @param {ContractItemUpsertArgs} args - Arguments to update or create a ContractItem.
     * @example
     * // Update or create a ContractItem
     * const contractItem = await prisma.contractItem.upsert({
     *   create: {
     *     // ... data to create a ContractItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContractItem we want to update
     *   }
     * })
     */
    upsert<T extends ContractItemUpsertArgs>(args: SelectSubset<T, ContractItemUpsertArgs<ExtArgs>>): Prisma__ContractItemClient<$Result.GetResult<Prisma.$ContractItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContractItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractItemCountArgs} args - Arguments to filter ContractItems to count.
     * @example
     * // Count the number of ContractItems
     * const count = await prisma.contractItem.count({
     *   where: {
     *     // ... the filter for the ContractItems we want to count
     *   }
     * })
    **/
    count<T extends ContractItemCountArgs>(
      args?: Subset<T, ContractItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContractItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractItemAggregateArgs>(args: Subset<T, ContractItemAggregateArgs>): Prisma.PrismaPromise<GetContractItemAggregateType<T>>

    /**
     * Group by ContractItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractItemGroupByArgs['orderBy'] }
        : { orderBy?: ContractItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContractItem model
   */
  readonly fields: ContractItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContractItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workActaItems<T extends ContractItem$workActaItemsArgs<ExtArgs> = {}>(args?: Subset<T, ContractItem$workActaItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkActaItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContractItem model
   */ 
  interface ContractItemFieldRefs {
    readonly id: FieldRef<"ContractItem", 'String'>
    readonly itemCode: FieldRef<"ContractItem", 'String'>
    readonly description: FieldRef<"ContractItem", 'String'>
    readonly unit: FieldRef<"ContractItem", 'String'>
    readonly unitPrice: FieldRef<"ContractItem", 'Float'>
    readonly contractQuantity: FieldRef<"ContractItem", 'Float'>
    readonly createdAt: FieldRef<"ContractItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ContractItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContractItem findUnique
   */
  export type ContractItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemInclude<ExtArgs> | null
    /**
     * Filter, which ContractItem to fetch.
     */
    where: ContractItemWhereUniqueInput
  }

  /**
   * ContractItem findUniqueOrThrow
   */
  export type ContractItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemInclude<ExtArgs> | null
    /**
     * Filter, which ContractItem to fetch.
     */
    where: ContractItemWhereUniqueInput
  }

  /**
   * ContractItem findFirst
   */
  export type ContractItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemInclude<ExtArgs> | null
    /**
     * Filter, which ContractItem to fetch.
     */
    where?: ContractItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractItems to fetch.
     */
    orderBy?: ContractItemOrderByWithRelationInput | ContractItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractItems.
     */
    cursor?: ContractItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractItems.
     */
    distinct?: ContractItemScalarFieldEnum | ContractItemScalarFieldEnum[]
  }

  /**
   * ContractItem findFirstOrThrow
   */
  export type ContractItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemInclude<ExtArgs> | null
    /**
     * Filter, which ContractItem to fetch.
     */
    where?: ContractItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractItems to fetch.
     */
    orderBy?: ContractItemOrderByWithRelationInput | ContractItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractItems.
     */
    cursor?: ContractItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractItems.
     */
    distinct?: ContractItemScalarFieldEnum | ContractItemScalarFieldEnum[]
  }

  /**
   * ContractItem findMany
   */
  export type ContractItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemInclude<ExtArgs> | null
    /**
     * Filter, which ContractItems to fetch.
     */
    where?: ContractItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractItems to fetch.
     */
    orderBy?: ContractItemOrderByWithRelationInput | ContractItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContractItems.
     */
    cursor?: ContractItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractItems.
     */
    skip?: number
    distinct?: ContractItemScalarFieldEnum | ContractItemScalarFieldEnum[]
  }

  /**
   * ContractItem create
   */
  export type ContractItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ContractItem.
     */
    data: XOR<ContractItemCreateInput, ContractItemUncheckedCreateInput>
  }

  /**
   * ContractItem createMany
   */
  export type ContractItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContractItems.
     */
    data: ContractItemCreateManyInput | ContractItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContractItem update
   */
  export type ContractItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ContractItem.
     */
    data: XOR<ContractItemUpdateInput, ContractItemUncheckedUpdateInput>
    /**
     * Choose, which ContractItem to update.
     */
    where: ContractItemWhereUniqueInput
  }

  /**
   * ContractItem updateMany
   */
  export type ContractItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContractItems.
     */
    data: XOR<ContractItemUpdateManyMutationInput, ContractItemUncheckedUpdateManyInput>
    /**
     * Filter which ContractItems to update
     */
    where?: ContractItemWhereInput
  }

  /**
   * ContractItem upsert
   */
  export type ContractItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ContractItem to update in case it exists.
     */
    where: ContractItemWhereUniqueInput
    /**
     * In case the ContractItem found by the `where` argument doesn't exist, create a new ContractItem with this data.
     */
    create: XOR<ContractItemCreateInput, ContractItemUncheckedCreateInput>
    /**
     * In case the ContractItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractItemUpdateInput, ContractItemUncheckedUpdateInput>
  }

  /**
   * ContractItem delete
   */
  export type ContractItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemInclude<ExtArgs> | null
    /**
     * Filter which ContractItem to delete.
     */
    where: ContractItemWhereUniqueInput
  }

  /**
   * ContractItem deleteMany
   */
  export type ContractItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractItems to delete
     */
    where?: ContractItemWhereInput
  }

  /**
   * ContractItem.workActaItems
   */
  export type ContractItem$workActaItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActaItem
     */
    select?: WorkActaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaItemInclude<ExtArgs> | null
    where?: WorkActaItemWhereInput
    orderBy?: WorkActaItemOrderByWithRelationInput | WorkActaItemOrderByWithRelationInput[]
    cursor?: WorkActaItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkActaItemScalarFieldEnum | WorkActaItemScalarFieldEnum[]
  }

  /**
   * ContractItem without action
   */
  export type ContractItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemInclude<ExtArgs> | null
  }


  /**
   * Model WorkActa
   */

  export type AggregateWorkActa = {
    _count: WorkActaCountAggregateOutputType | null
    _min: WorkActaMinAggregateOutputType | null
    _max: WorkActaMaxAggregateOutputType | null
  }

  export type WorkActaMinAggregateOutputType = {
    id: string | null
    number: string | null
    period: string | null
    date: Date | null
    status: $Enums.WorkActaStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkActaMaxAggregateOutputType = {
    id: string | null
    number: string | null
    period: string | null
    date: Date | null
    status: $Enums.WorkActaStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkActaCountAggregateOutputType = {
    id: number
    number: number
    period: number
    date: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkActaMinAggregateInputType = {
    id?: true
    number?: true
    period?: true
    date?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkActaMaxAggregateInputType = {
    id?: true
    number?: true
    period?: true
    date?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkActaCountAggregateInputType = {
    id?: true
    number?: true
    period?: true
    date?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkActaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkActa to aggregate.
     */
    where?: WorkActaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkActas to fetch.
     */
    orderBy?: WorkActaOrderByWithRelationInput | WorkActaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkActaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkActas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkActas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkActas
    **/
    _count?: true | WorkActaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkActaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkActaMaxAggregateInputType
  }

  export type GetWorkActaAggregateType<T extends WorkActaAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkActa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkActa[P]>
      : GetScalarType<T[P], AggregateWorkActa[P]>
  }




  export type WorkActaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkActaWhereInput
    orderBy?: WorkActaOrderByWithAggregationInput | WorkActaOrderByWithAggregationInput[]
    by: WorkActaScalarFieldEnum[] | WorkActaScalarFieldEnum
    having?: WorkActaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkActaCountAggregateInputType | true
    _min?: WorkActaMinAggregateInputType
    _max?: WorkActaMaxAggregateInputType
  }

  export type WorkActaGroupByOutputType = {
    id: string
    number: string
    period: string
    date: Date
    status: $Enums.WorkActaStatus
    createdAt: Date
    updatedAt: Date
    _count: WorkActaCountAggregateOutputType | null
    _min: WorkActaMinAggregateOutputType | null
    _max: WorkActaMaxAggregateOutputType | null
  }

  type GetWorkActaGroupByPayload<T extends WorkActaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkActaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkActaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkActaGroupByOutputType[P]>
            : GetScalarType<T[P], WorkActaGroupByOutputType[P]>
        }
      >
    >


  export type WorkActaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    number?: boolean
    period?: boolean
    date?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | WorkActa$itemsArgs<ExtArgs>
    attachments?: boolean | WorkActa$attachmentsArgs<ExtArgs>
    _count?: boolean | WorkActaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workActa"]>


  export type WorkActaSelectScalar = {
    id?: boolean
    number?: boolean
    period?: boolean
    date?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkActaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | WorkActa$itemsArgs<ExtArgs>
    attachments?: boolean | WorkActa$attachmentsArgs<ExtArgs>
    _count?: boolean | WorkActaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WorkActaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkActa"
    objects: {
      items: Prisma.$WorkActaItemPayload<ExtArgs>[]
      attachments: Prisma.$AttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      number: string
      period: string
      date: Date
      status: $Enums.WorkActaStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workActa"]>
    composites: {}
  }

  type WorkActaGetPayload<S extends boolean | null | undefined | WorkActaDefaultArgs> = $Result.GetResult<Prisma.$WorkActaPayload, S>

  type WorkActaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkActaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkActaCountAggregateInputType | true
    }

  export interface WorkActaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkActa'], meta: { name: 'WorkActa' } }
    /**
     * Find zero or one WorkActa that matches the filter.
     * @param {WorkActaFindUniqueArgs} args - Arguments to find a WorkActa
     * @example
     * // Get one WorkActa
     * const workActa = await prisma.workActa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkActaFindUniqueArgs>(args: SelectSubset<T, WorkActaFindUniqueArgs<ExtArgs>>): Prisma__WorkActaClient<$Result.GetResult<Prisma.$WorkActaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkActa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkActaFindUniqueOrThrowArgs} args - Arguments to find a WorkActa
     * @example
     * // Get one WorkActa
     * const workActa = await prisma.workActa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkActaFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkActaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkActaClient<$Result.GetResult<Prisma.$WorkActaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkActa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkActaFindFirstArgs} args - Arguments to find a WorkActa
     * @example
     * // Get one WorkActa
     * const workActa = await prisma.workActa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkActaFindFirstArgs>(args?: SelectSubset<T, WorkActaFindFirstArgs<ExtArgs>>): Prisma__WorkActaClient<$Result.GetResult<Prisma.$WorkActaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkActa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkActaFindFirstOrThrowArgs} args - Arguments to find a WorkActa
     * @example
     * // Get one WorkActa
     * const workActa = await prisma.workActa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkActaFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkActaFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkActaClient<$Result.GetResult<Prisma.$WorkActaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkActas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkActaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkActas
     * const workActas = await prisma.workActa.findMany()
     * 
     * // Get first 10 WorkActas
     * const workActas = await prisma.workActa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workActaWithIdOnly = await prisma.workActa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkActaFindManyArgs>(args?: SelectSubset<T, WorkActaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkActaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkActa.
     * @param {WorkActaCreateArgs} args - Arguments to create a WorkActa.
     * @example
     * // Create one WorkActa
     * const WorkActa = await prisma.workActa.create({
     *   data: {
     *     // ... data to create a WorkActa
     *   }
     * })
     * 
     */
    create<T extends WorkActaCreateArgs>(args: SelectSubset<T, WorkActaCreateArgs<ExtArgs>>): Prisma__WorkActaClient<$Result.GetResult<Prisma.$WorkActaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkActas.
     * @param {WorkActaCreateManyArgs} args - Arguments to create many WorkActas.
     * @example
     * // Create many WorkActas
     * const workActa = await prisma.workActa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkActaCreateManyArgs>(args?: SelectSubset<T, WorkActaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WorkActa.
     * @param {WorkActaDeleteArgs} args - Arguments to delete one WorkActa.
     * @example
     * // Delete one WorkActa
     * const WorkActa = await prisma.workActa.delete({
     *   where: {
     *     // ... filter to delete one WorkActa
     *   }
     * })
     * 
     */
    delete<T extends WorkActaDeleteArgs>(args: SelectSubset<T, WorkActaDeleteArgs<ExtArgs>>): Prisma__WorkActaClient<$Result.GetResult<Prisma.$WorkActaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkActa.
     * @param {WorkActaUpdateArgs} args - Arguments to update one WorkActa.
     * @example
     * // Update one WorkActa
     * const workActa = await prisma.workActa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkActaUpdateArgs>(args: SelectSubset<T, WorkActaUpdateArgs<ExtArgs>>): Prisma__WorkActaClient<$Result.GetResult<Prisma.$WorkActaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkActas.
     * @param {WorkActaDeleteManyArgs} args - Arguments to filter WorkActas to delete.
     * @example
     * // Delete a few WorkActas
     * const { count } = await prisma.workActa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkActaDeleteManyArgs>(args?: SelectSubset<T, WorkActaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkActas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkActaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkActas
     * const workActa = await prisma.workActa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkActaUpdateManyArgs>(args: SelectSubset<T, WorkActaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkActa.
     * @param {WorkActaUpsertArgs} args - Arguments to update or create a WorkActa.
     * @example
     * // Update or create a WorkActa
     * const workActa = await prisma.workActa.upsert({
     *   create: {
     *     // ... data to create a WorkActa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkActa we want to update
     *   }
     * })
     */
    upsert<T extends WorkActaUpsertArgs>(args: SelectSubset<T, WorkActaUpsertArgs<ExtArgs>>): Prisma__WorkActaClient<$Result.GetResult<Prisma.$WorkActaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkActas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkActaCountArgs} args - Arguments to filter WorkActas to count.
     * @example
     * // Count the number of WorkActas
     * const count = await prisma.workActa.count({
     *   where: {
     *     // ... the filter for the WorkActas we want to count
     *   }
     * })
    **/
    count<T extends WorkActaCountArgs>(
      args?: Subset<T, WorkActaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkActaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkActa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkActaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkActaAggregateArgs>(args: Subset<T, WorkActaAggregateArgs>): Prisma.PrismaPromise<GetWorkActaAggregateType<T>>

    /**
     * Group by WorkActa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkActaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkActaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkActaGroupByArgs['orderBy'] }
        : { orderBy?: WorkActaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkActaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkActaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkActa model
   */
  readonly fields: WorkActaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkActa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkActaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends WorkActa$itemsArgs<ExtArgs> = {}>(args?: Subset<T, WorkActa$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkActaItemPayload<ExtArgs>, T, "findMany"> | Null>
    attachments<T extends WorkActa$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, WorkActa$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkActa model
   */ 
  interface WorkActaFieldRefs {
    readonly id: FieldRef<"WorkActa", 'String'>
    readonly number: FieldRef<"WorkActa", 'String'>
    readonly period: FieldRef<"WorkActa", 'String'>
    readonly date: FieldRef<"WorkActa", 'DateTime'>
    readonly status: FieldRef<"WorkActa", 'WorkActaStatus'>
    readonly createdAt: FieldRef<"WorkActa", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkActa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkActa findUnique
   */
  export type WorkActaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActa
     */
    select?: WorkActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaInclude<ExtArgs> | null
    /**
     * Filter, which WorkActa to fetch.
     */
    where: WorkActaWhereUniqueInput
  }

  /**
   * WorkActa findUniqueOrThrow
   */
  export type WorkActaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActa
     */
    select?: WorkActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaInclude<ExtArgs> | null
    /**
     * Filter, which WorkActa to fetch.
     */
    where: WorkActaWhereUniqueInput
  }

  /**
   * WorkActa findFirst
   */
  export type WorkActaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActa
     */
    select?: WorkActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaInclude<ExtArgs> | null
    /**
     * Filter, which WorkActa to fetch.
     */
    where?: WorkActaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkActas to fetch.
     */
    orderBy?: WorkActaOrderByWithRelationInput | WorkActaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkActas.
     */
    cursor?: WorkActaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkActas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkActas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkActas.
     */
    distinct?: WorkActaScalarFieldEnum | WorkActaScalarFieldEnum[]
  }

  /**
   * WorkActa findFirstOrThrow
   */
  export type WorkActaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActa
     */
    select?: WorkActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaInclude<ExtArgs> | null
    /**
     * Filter, which WorkActa to fetch.
     */
    where?: WorkActaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkActas to fetch.
     */
    orderBy?: WorkActaOrderByWithRelationInput | WorkActaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkActas.
     */
    cursor?: WorkActaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkActas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkActas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkActas.
     */
    distinct?: WorkActaScalarFieldEnum | WorkActaScalarFieldEnum[]
  }

  /**
   * WorkActa findMany
   */
  export type WorkActaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActa
     */
    select?: WorkActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaInclude<ExtArgs> | null
    /**
     * Filter, which WorkActas to fetch.
     */
    where?: WorkActaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkActas to fetch.
     */
    orderBy?: WorkActaOrderByWithRelationInput | WorkActaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkActas.
     */
    cursor?: WorkActaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkActas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkActas.
     */
    skip?: number
    distinct?: WorkActaScalarFieldEnum | WorkActaScalarFieldEnum[]
  }

  /**
   * WorkActa create
   */
  export type WorkActaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActa
     */
    select?: WorkActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkActa.
     */
    data: XOR<WorkActaCreateInput, WorkActaUncheckedCreateInput>
  }

  /**
   * WorkActa createMany
   */
  export type WorkActaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkActas.
     */
    data: WorkActaCreateManyInput | WorkActaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkActa update
   */
  export type WorkActaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActa
     */
    select?: WorkActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkActa.
     */
    data: XOR<WorkActaUpdateInput, WorkActaUncheckedUpdateInput>
    /**
     * Choose, which WorkActa to update.
     */
    where: WorkActaWhereUniqueInput
  }

  /**
   * WorkActa updateMany
   */
  export type WorkActaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkActas.
     */
    data: XOR<WorkActaUpdateManyMutationInput, WorkActaUncheckedUpdateManyInput>
    /**
     * Filter which WorkActas to update
     */
    where?: WorkActaWhereInput
  }

  /**
   * WorkActa upsert
   */
  export type WorkActaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActa
     */
    select?: WorkActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkActa to update in case it exists.
     */
    where: WorkActaWhereUniqueInput
    /**
     * In case the WorkActa found by the `where` argument doesn't exist, create a new WorkActa with this data.
     */
    create: XOR<WorkActaCreateInput, WorkActaUncheckedCreateInput>
    /**
     * In case the WorkActa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkActaUpdateInput, WorkActaUncheckedUpdateInput>
  }

  /**
   * WorkActa delete
   */
  export type WorkActaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActa
     */
    select?: WorkActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaInclude<ExtArgs> | null
    /**
     * Filter which WorkActa to delete.
     */
    where: WorkActaWhereUniqueInput
  }

  /**
   * WorkActa deleteMany
   */
  export type WorkActaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkActas to delete
     */
    where?: WorkActaWhereInput
  }

  /**
   * WorkActa.items
   */
  export type WorkActa$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActaItem
     */
    select?: WorkActaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaItemInclude<ExtArgs> | null
    where?: WorkActaItemWhereInput
    orderBy?: WorkActaItemOrderByWithRelationInput | WorkActaItemOrderByWithRelationInput[]
    cursor?: WorkActaItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkActaItemScalarFieldEnum | WorkActaItemScalarFieldEnum[]
  }

  /**
   * WorkActa.attachments
   */
  export type WorkActa$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attachment
     */
    select?: AttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttachmentInclude<ExtArgs> | null
    where?: AttachmentWhereInput
    orderBy?: AttachmentOrderByWithRelationInput | AttachmentOrderByWithRelationInput[]
    cursor?: AttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttachmentScalarFieldEnum | AttachmentScalarFieldEnum[]
  }

  /**
   * WorkActa without action
   */
  export type WorkActaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActa
     */
    select?: WorkActaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaInclude<ExtArgs> | null
  }


  /**
   * Model WorkActaItem
   */

  export type AggregateWorkActaItem = {
    _count: WorkActaItemCountAggregateOutputType | null
    _avg: WorkActaItemAvgAggregateOutputType | null
    _sum: WorkActaItemSumAggregateOutputType | null
    _min: WorkActaItemMinAggregateOutputType | null
    _max: WorkActaItemMaxAggregateOutputType | null
  }

  export type WorkActaItemAvgAggregateOutputType = {
    quantity: number | null
  }

  export type WorkActaItemSumAggregateOutputType = {
    quantity: number | null
  }

  export type WorkActaItemMinAggregateOutputType = {
    id: string | null
    quantity: number | null
    workActaId: string | null
    contractItemId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkActaItemMaxAggregateOutputType = {
    id: string | null
    quantity: number | null
    workActaId: string | null
    contractItemId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkActaItemCountAggregateOutputType = {
    id: number
    quantity: number
    workActaId: number
    contractItemId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkActaItemAvgAggregateInputType = {
    quantity?: true
  }

  export type WorkActaItemSumAggregateInputType = {
    quantity?: true
  }

  export type WorkActaItemMinAggregateInputType = {
    id?: true
    quantity?: true
    workActaId?: true
    contractItemId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkActaItemMaxAggregateInputType = {
    id?: true
    quantity?: true
    workActaId?: true
    contractItemId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkActaItemCountAggregateInputType = {
    id?: true
    quantity?: true
    workActaId?: true
    contractItemId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkActaItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkActaItem to aggregate.
     */
    where?: WorkActaItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkActaItems to fetch.
     */
    orderBy?: WorkActaItemOrderByWithRelationInput | WorkActaItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkActaItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkActaItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkActaItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkActaItems
    **/
    _count?: true | WorkActaItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkActaItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkActaItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkActaItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkActaItemMaxAggregateInputType
  }

  export type GetWorkActaItemAggregateType<T extends WorkActaItemAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkActaItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkActaItem[P]>
      : GetScalarType<T[P], AggregateWorkActaItem[P]>
  }




  export type WorkActaItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkActaItemWhereInput
    orderBy?: WorkActaItemOrderByWithAggregationInput | WorkActaItemOrderByWithAggregationInput[]
    by: WorkActaItemScalarFieldEnum[] | WorkActaItemScalarFieldEnum
    having?: WorkActaItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkActaItemCountAggregateInputType | true
    _avg?: WorkActaItemAvgAggregateInputType
    _sum?: WorkActaItemSumAggregateInputType
    _min?: WorkActaItemMinAggregateInputType
    _max?: WorkActaItemMaxAggregateInputType
  }

  export type WorkActaItemGroupByOutputType = {
    id: string
    quantity: number
    workActaId: string
    contractItemId: string
    createdAt: Date
    updatedAt: Date
    _count: WorkActaItemCountAggregateOutputType | null
    _avg: WorkActaItemAvgAggregateOutputType | null
    _sum: WorkActaItemSumAggregateOutputType | null
    _min: WorkActaItemMinAggregateOutputType | null
    _max: WorkActaItemMaxAggregateOutputType | null
  }

  type GetWorkActaItemGroupByPayload<T extends WorkActaItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkActaItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkActaItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkActaItemGroupByOutputType[P]>
            : GetScalarType<T[P], WorkActaItemGroupByOutputType[P]>
        }
      >
    >


  export type WorkActaItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    workActaId?: boolean
    contractItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workActa?: boolean | WorkActaDefaultArgs<ExtArgs>
    contractItem?: boolean | ContractItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workActaItem"]>


  export type WorkActaItemSelectScalar = {
    id?: boolean
    quantity?: boolean
    workActaId?: boolean
    contractItemId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkActaItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workActa?: boolean | WorkActaDefaultArgs<ExtArgs>
    contractItem?: boolean | ContractItemDefaultArgs<ExtArgs>
  }

  export type $WorkActaItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkActaItem"
    objects: {
      workActa: Prisma.$WorkActaPayload<ExtArgs>
      contractItem: Prisma.$ContractItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quantity: number
      workActaId: string
      contractItemId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workActaItem"]>
    composites: {}
  }

  type WorkActaItemGetPayload<S extends boolean | null | undefined | WorkActaItemDefaultArgs> = $Result.GetResult<Prisma.$WorkActaItemPayload, S>

  type WorkActaItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkActaItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkActaItemCountAggregateInputType | true
    }

  export interface WorkActaItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkActaItem'], meta: { name: 'WorkActaItem' } }
    /**
     * Find zero or one WorkActaItem that matches the filter.
     * @param {WorkActaItemFindUniqueArgs} args - Arguments to find a WorkActaItem
     * @example
     * // Get one WorkActaItem
     * const workActaItem = await prisma.workActaItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkActaItemFindUniqueArgs>(args: SelectSubset<T, WorkActaItemFindUniqueArgs<ExtArgs>>): Prisma__WorkActaItemClient<$Result.GetResult<Prisma.$WorkActaItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkActaItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkActaItemFindUniqueOrThrowArgs} args - Arguments to find a WorkActaItem
     * @example
     * // Get one WorkActaItem
     * const workActaItem = await prisma.workActaItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkActaItemFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkActaItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkActaItemClient<$Result.GetResult<Prisma.$WorkActaItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkActaItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkActaItemFindFirstArgs} args - Arguments to find a WorkActaItem
     * @example
     * // Get one WorkActaItem
     * const workActaItem = await prisma.workActaItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkActaItemFindFirstArgs>(args?: SelectSubset<T, WorkActaItemFindFirstArgs<ExtArgs>>): Prisma__WorkActaItemClient<$Result.GetResult<Prisma.$WorkActaItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkActaItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkActaItemFindFirstOrThrowArgs} args - Arguments to find a WorkActaItem
     * @example
     * // Get one WorkActaItem
     * const workActaItem = await prisma.workActaItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkActaItemFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkActaItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkActaItemClient<$Result.GetResult<Prisma.$WorkActaItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkActaItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkActaItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkActaItems
     * const workActaItems = await prisma.workActaItem.findMany()
     * 
     * // Get first 10 WorkActaItems
     * const workActaItems = await prisma.workActaItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workActaItemWithIdOnly = await prisma.workActaItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkActaItemFindManyArgs>(args?: SelectSubset<T, WorkActaItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkActaItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkActaItem.
     * @param {WorkActaItemCreateArgs} args - Arguments to create a WorkActaItem.
     * @example
     * // Create one WorkActaItem
     * const WorkActaItem = await prisma.workActaItem.create({
     *   data: {
     *     // ... data to create a WorkActaItem
     *   }
     * })
     * 
     */
    create<T extends WorkActaItemCreateArgs>(args: SelectSubset<T, WorkActaItemCreateArgs<ExtArgs>>): Prisma__WorkActaItemClient<$Result.GetResult<Prisma.$WorkActaItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkActaItems.
     * @param {WorkActaItemCreateManyArgs} args - Arguments to create many WorkActaItems.
     * @example
     * // Create many WorkActaItems
     * const workActaItem = await prisma.workActaItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkActaItemCreateManyArgs>(args?: SelectSubset<T, WorkActaItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WorkActaItem.
     * @param {WorkActaItemDeleteArgs} args - Arguments to delete one WorkActaItem.
     * @example
     * // Delete one WorkActaItem
     * const WorkActaItem = await prisma.workActaItem.delete({
     *   where: {
     *     // ... filter to delete one WorkActaItem
     *   }
     * })
     * 
     */
    delete<T extends WorkActaItemDeleteArgs>(args: SelectSubset<T, WorkActaItemDeleteArgs<ExtArgs>>): Prisma__WorkActaItemClient<$Result.GetResult<Prisma.$WorkActaItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkActaItem.
     * @param {WorkActaItemUpdateArgs} args - Arguments to update one WorkActaItem.
     * @example
     * // Update one WorkActaItem
     * const workActaItem = await prisma.workActaItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkActaItemUpdateArgs>(args: SelectSubset<T, WorkActaItemUpdateArgs<ExtArgs>>): Prisma__WorkActaItemClient<$Result.GetResult<Prisma.$WorkActaItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkActaItems.
     * @param {WorkActaItemDeleteManyArgs} args - Arguments to filter WorkActaItems to delete.
     * @example
     * // Delete a few WorkActaItems
     * const { count } = await prisma.workActaItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkActaItemDeleteManyArgs>(args?: SelectSubset<T, WorkActaItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkActaItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkActaItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkActaItems
     * const workActaItem = await prisma.workActaItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkActaItemUpdateManyArgs>(args: SelectSubset<T, WorkActaItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkActaItem.
     * @param {WorkActaItemUpsertArgs} args - Arguments to update or create a WorkActaItem.
     * @example
     * // Update or create a WorkActaItem
     * const workActaItem = await prisma.workActaItem.upsert({
     *   create: {
     *     // ... data to create a WorkActaItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkActaItem we want to update
     *   }
     * })
     */
    upsert<T extends WorkActaItemUpsertArgs>(args: SelectSubset<T, WorkActaItemUpsertArgs<ExtArgs>>): Prisma__WorkActaItemClient<$Result.GetResult<Prisma.$WorkActaItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WorkActaItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkActaItemCountArgs} args - Arguments to filter WorkActaItems to count.
     * @example
     * // Count the number of WorkActaItems
     * const count = await prisma.workActaItem.count({
     *   where: {
     *     // ... the filter for the WorkActaItems we want to count
     *   }
     * })
    **/
    count<T extends WorkActaItemCountArgs>(
      args?: Subset<T, WorkActaItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkActaItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkActaItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkActaItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkActaItemAggregateArgs>(args: Subset<T, WorkActaItemAggregateArgs>): Prisma.PrismaPromise<GetWorkActaItemAggregateType<T>>

    /**
     * Group by WorkActaItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkActaItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkActaItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkActaItemGroupByArgs['orderBy'] }
        : { orderBy?: WorkActaItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkActaItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkActaItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkActaItem model
   */
  readonly fields: WorkActaItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkActaItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkActaItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workActa<T extends WorkActaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkActaDefaultArgs<ExtArgs>>): Prisma__WorkActaClient<$Result.GetResult<Prisma.$WorkActaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    contractItem<T extends ContractItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractItemDefaultArgs<ExtArgs>>): Prisma__ContractItemClient<$Result.GetResult<Prisma.$ContractItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkActaItem model
   */ 
  interface WorkActaItemFieldRefs {
    readonly id: FieldRef<"WorkActaItem", 'String'>
    readonly quantity: FieldRef<"WorkActaItem", 'Float'>
    readonly workActaId: FieldRef<"WorkActaItem", 'String'>
    readonly contractItemId: FieldRef<"WorkActaItem", 'String'>
    readonly createdAt: FieldRef<"WorkActaItem", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkActaItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkActaItem findUnique
   */
  export type WorkActaItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActaItem
     */
    select?: WorkActaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaItemInclude<ExtArgs> | null
    /**
     * Filter, which WorkActaItem to fetch.
     */
    where: WorkActaItemWhereUniqueInput
  }

  /**
   * WorkActaItem findUniqueOrThrow
   */
  export type WorkActaItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActaItem
     */
    select?: WorkActaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaItemInclude<ExtArgs> | null
    /**
     * Filter, which WorkActaItem to fetch.
     */
    where: WorkActaItemWhereUniqueInput
  }

  /**
   * WorkActaItem findFirst
   */
  export type WorkActaItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActaItem
     */
    select?: WorkActaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaItemInclude<ExtArgs> | null
    /**
     * Filter, which WorkActaItem to fetch.
     */
    where?: WorkActaItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkActaItems to fetch.
     */
    orderBy?: WorkActaItemOrderByWithRelationInput | WorkActaItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkActaItems.
     */
    cursor?: WorkActaItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkActaItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkActaItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkActaItems.
     */
    distinct?: WorkActaItemScalarFieldEnum | WorkActaItemScalarFieldEnum[]
  }

  /**
   * WorkActaItem findFirstOrThrow
   */
  export type WorkActaItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActaItem
     */
    select?: WorkActaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaItemInclude<ExtArgs> | null
    /**
     * Filter, which WorkActaItem to fetch.
     */
    where?: WorkActaItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkActaItems to fetch.
     */
    orderBy?: WorkActaItemOrderByWithRelationInput | WorkActaItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkActaItems.
     */
    cursor?: WorkActaItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkActaItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkActaItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkActaItems.
     */
    distinct?: WorkActaItemScalarFieldEnum | WorkActaItemScalarFieldEnum[]
  }

  /**
   * WorkActaItem findMany
   */
  export type WorkActaItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActaItem
     */
    select?: WorkActaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaItemInclude<ExtArgs> | null
    /**
     * Filter, which WorkActaItems to fetch.
     */
    where?: WorkActaItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkActaItems to fetch.
     */
    orderBy?: WorkActaItemOrderByWithRelationInput | WorkActaItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkActaItems.
     */
    cursor?: WorkActaItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkActaItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkActaItems.
     */
    skip?: number
    distinct?: WorkActaItemScalarFieldEnum | WorkActaItemScalarFieldEnum[]
  }

  /**
   * WorkActaItem create
   */
  export type WorkActaItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActaItem
     */
    select?: WorkActaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaItemInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkActaItem.
     */
    data: XOR<WorkActaItemCreateInput, WorkActaItemUncheckedCreateInput>
  }

  /**
   * WorkActaItem createMany
   */
  export type WorkActaItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkActaItems.
     */
    data: WorkActaItemCreateManyInput | WorkActaItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkActaItem update
   */
  export type WorkActaItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActaItem
     */
    select?: WorkActaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaItemInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkActaItem.
     */
    data: XOR<WorkActaItemUpdateInput, WorkActaItemUncheckedUpdateInput>
    /**
     * Choose, which WorkActaItem to update.
     */
    where: WorkActaItemWhereUniqueInput
  }

  /**
   * WorkActaItem updateMany
   */
  export type WorkActaItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkActaItems.
     */
    data: XOR<WorkActaItemUpdateManyMutationInput, WorkActaItemUncheckedUpdateManyInput>
    /**
     * Filter which WorkActaItems to update
     */
    where?: WorkActaItemWhereInput
  }

  /**
   * WorkActaItem upsert
   */
  export type WorkActaItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActaItem
     */
    select?: WorkActaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaItemInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkActaItem to update in case it exists.
     */
    where: WorkActaItemWhereUniqueInput
    /**
     * In case the WorkActaItem found by the `where` argument doesn't exist, create a new WorkActaItem with this data.
     */
    create: XOR<WorkActaItemCreateInput, WorkActaItemUncheckedCreateInput>
    /**
     * In case the WorkActaItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkActaItemUpdateInput, WorkActaItemUncheckedUpdateInput>
  }

  /**
   * WorkActaItem delete
   */
  export type WorkActaItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActaItem
     */
    select?: WorkActaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaItemInclude<ExtArgs> | null
    /**
     * Filter which WorkActaItem to delete.
     */
    where: WorkActaItemWhereUniqueInput
  }

  /**
   * WorkActaItem deleteMany
   */
  export type WorkActaItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkActaItems to delete
     */
    where?: WorkActaItemWhereInput
  }

  /**
   * WorkActaItem without action
   */
  export type WorkActaItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkActaItem
     */
    select?: WorkActaItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkActaItemInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    fullName: 'fullName',
    projectRole: 'projectRole',
    appRole: 'appRole',
    avatarUrl: 'avatarUrl',
    status: 'status',
    lastLoginAt: 'lastLoginAt',
    tokenVersion: 'tokenVersion',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contractId: 'contractId',
    object: 'object',
    contractorName: 'contractorName',
    supervisorName: 'supervisorName',
    initialValue: 'initialValue',
    startDate: 'startDate',
    initialEndDate: 'initialEndDate',
    interventoriaContractId: 'interventoriaContractId',
    interventoriaInitialValue: 'interventoriaInitialValue',
    technicalSupervisorName: 'technicalSupervisorName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const KeyPersonnelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    role: 'role',
    company: 'company',
    email: 'email',
    phone: 'phone',
    projectId: 'projectId'
  };

  export type KeyPersonnelScalarFieldEnum = (typeof KeyPersonnelScalarFieldEnum)[keyof typeof KeyPersonnelScalarFieldEnum]


  export const CommunicationScalarFieldEnum: {
    id: 'id',
    radicado: 'radicado',
    subject: 'subject',
    description: 'description',
    senderEntity: 'senderEntity',
    senderName: 'senderName',
    senderTitle: 'senderTitle',
    recipientEntity: 'recipientEntity',
    recipientName: 'recipientName',
    recipientTitle: 'recipientTitle',
    signerName: 'signerName',
    sentDate: 'sentDate',
    dueDate: 'dueDate',
    deliveryMethod: 'deliveryMethod',
    notes: 'notes',
    status: 'status',
    uploaderId: 'uploaderId',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommunicationScalarFieldEnum = (typeof CommunicationScalarFieldEnum)[keyof typeof CommunicationScalarFieldEnum]


  export const CommunicationStatusHistoryScalarFieldEnum: {
    id: 'id',
    status: 'status',
    timestamp: 'timestamp',
    communicationId: 'communicationId',
    userId: 'userId'
  };

  export type CommunicationStatusHistoryScalarFieldEnum = (typeof CommunicationStatusHistoryScalarFieldEnum)[keyof typeof CommunicationStatusHistoryScalarFieldEnum]


  export const ContractModificationScalarFieldEnum: {
    id: 'id',
    number: 'number',
    type: 'type',
    date: 'date',
    value: 'value',
    days: 'days',
    justification: 'justification',
    attachmentId: 'attachmentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContractModificationScalarFieldEnum = (typeof ContractModificationScalarFieldEnum)[keyof typeof ContractModificationScalarFieldEnum]


  export const WeeklyReportScalarFieldEnum: {
    id: 'id',
    number: 'number',
    startDate: 'startDate',
    endDate: 'endDate',
    summary: 'summary',
    progressSummary: 'progressSummary',
    nextWeekPlan: 'nextWeekPlan',
    issues: 'issues',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WeeklyReportScalarFieldEnum = (typeof WeeklyReportScalarFieldEnum)[keyof typeof WeeklyReportScalarFieldEnum]


  export const LogEntryScalarFieldEnum: {
    id: 'id',
    folioNumber: 'folioNumber',
    title: 'title',
    description: 'description',
    type: 'type',
    subject: 'subject',
    location: 'location',
    activityStartDate: 'activityStartDate',
    activityEndDate: 'activityEndDate',
    isConfidential: 'isConfidential',
    status: 'status',
    authorId: 'authorId',
    projectId: 'projectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LogEntryScalarFieldEnum = (typeof LogEntryScalarFieldEnum)[keyof typeof LogEntryScalarFieldEnum]


  export const LogEntryHistoryScalarFieldEnum: {
    id: 'id',
    fieldName: 'fieldName',
    oldValue: 'oldValue',
    newValue: 'newValue',
    timestamp: 'timestamp',
    logEntryId: 'logEntryId',
    userId: 'userId'
  };

  export type LogEntryHistoryScalarFieldEnum = (typeof LogEntryHistoryScalarFieldEnum)[keyof typeof LogEntryHistoryScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    timestamp: 'timestamp',
    authorId: 'authorId',
    logEntryId: 'logEntryId',
    drawingId: 'drawingId'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const SignatureScalarFieldEnum: {
    id: 'id',
    signedAt: 'signedAt',
    signerId: 'signerId',
    logEntryId: 'logEntryId',
    actaId: 'actaId',
    reportId: 'reportId'
  };

  export type SignatureScalarFieldEnum = (typeof SignatureScalarFieldEnum)[keyof typeof SignatureScalarFieldEnum]


  export const AttachmentScalarFieldEnum: {
    id: 'id',
    fileName: 'fileName',
    url: 'url',
    size: 'size',
    type: 'type',
    logEntryId: 'logEntryId',
    communicationId: 'communicationId',
    actaId: 'actaId',
    costActaId: 'costActaId',
    reportId: 'reportId',
    commentId: 'commentId',
    workActaId: 'workActaId',
    weeklyReportId: 'weeklyReportId',
    createdAt: 'createdAt'
  };

  export type AttachmentScalarFieldEnum = (typeof AttachmentScalarFieldEnum)[keyof typeof AttachmentScalarFieldEnum]


  export const ActaScalarFieldEnum: {
    id: 'id',
    number: 'number',
    title: 'title',
    date: 'date',
    area: 'area',
    status: 'status',
    summary: 'summary',
    requiredSignatoriesJson: 'requiredSignatoriesJson',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActaScalarFieldEnum = (typeof ActaScalarFieldEnum)[keyof typeof ActaScalarFieldEnum]


  export const CommitmentScalarFieldEnum: {
    id: 'id',
    description: 'description',
    dueDate: 'dueDate',
    status: 'status',
    responsibleId: 'responsibleId',
    actaId: 'actaId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommitmentScalarFieldEnum = (typeof CommitmentScalarFieldEnum)[keyof typeof CommitmentScalarFieldEnum]


  export const CostActaScalarFieldEnum: {
    id: 'id',
    number: 'number',
    period: 'period',
    submissionDate: 'submissionDate',
    approvalDate: 'approvalDate',
    paymentDueDate: 'paymentDueDate',
    billedAmount: 'billedAmount',
    totalContractValue: 'totalContractValue',
    status: 'status',
    relatedProgress: 'relatedProgress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CostActaScalarFieldEnum = (typeof CostActaScalarFieldEnum)[keyof typeof CostActaScalarFieldEnum]


  export const ObservationScalarFieldEnum: {
    id: 'id',
    text: 'text',
    timestamp: 'timestamp',
    authorId: 'authorId',
    costActaId: 'costActaId'
  };

  export type ObservationScalarFieldEnum = (typeof ObservationScalarFieldEnum)[keyof typeof ObservationScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    type: 'type',
    reportScope: 'reportScope',
    number: 'number',
    period: 'period',
    submissionDate: 'submissionDate',
    summary: 'summary',
    status: 'status',
    authorId: 'authorId',
    requiredSignatoriesJson: 'requiredSignatoriesJson',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const DrawingScalarFieldEnum: {
    id: 'id',
    code: 'code',
    title: 'title',
    discipline: 'discipline',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DrawingScalarFieldEnum = (typeof DrawingScalarFieldEnum)[keyof typeof DrawingScalarFieldEnum]


  export const DrawingVersionScalarFieldEnum: {
    id: 'id',
    versionNumber: 'versionNumber',
    fileName: 'fileName',
    url: 'url',
    size: 'size',
    uploadDate: 'uploadDate',
    uploaderId: 'uploaderId',
    drawingId: 'drawingId'
  };

  export type DrawingVersionScalarFieldEnum = (typeof DrawingVersionScalarFieldEnum)[keyof typeof DrawingVersionScalarFieldEnum]


  export const PhotoEntryScalarFieldEnum: {
    id: 'id',
    url: 'url',
    date: 'date',
    notes: 'notes',
    authorId: 'authorId',
    controlPointId: 'controlPointId',
    attachmentId: 'attachmentId'
  };

  export type PhotoEntryScalarFieldEnum = (typeof PhotoEntryScalarFieldEnum)[keyof typeof PhotoEntryScalarFieldEnum]


  export const ControlPointScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    location: 'location',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ControlPointScalarFieldEnum = (typeof ControlPointScalarFieldEnum)[keyof typeof ControlPointScalarFieldEnum]


  export const ProjectTaskScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    progress: 'progress',
    duration: 'duration',
    isSummary: 'isSummary',
    outlineLevel: 'outlineLevel',
    dependencies: 'dependencies',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectTaskScalarFieldEnum = (typeof ProjectTaskScalarFieldEnum)[keyof typeof ProjectTaskScalarFieldEnum]


  export const ContractItemScalarFieldEnum: {
    id: 'id',
    itemCode: 'itemCode',
    description: 'description',
    unit: 'unit',
    unitPrice: 'unitPrice',
    contractQuantity: 'contractQuantity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContractItemScalarFieldEnum = (typeof ContractItemScalarFieldEnum)[keyof typeof ContractItemScalarFieldEnum]


  export const WorkActaScalarFieldEnum: {
    id: 'id',
    number: 'number',
    period: 'period',
    date: 'date',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkActaScalarFieldEnum = (typeof WorkActaScalarFieldEnum)[keyof typeof WorkActaScalarFieldEnum]


  export const WorkActaItemScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    workActaId: 'workActaId',
    contractItemId: 'contractItemId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkActaItemScalarFieldEnum = (typeof WorkActaItemScalarFieldEnum)[keyof typeof WorkActaItemScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'AppRole'
   */
  export type EnumAppRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppRole'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'DeliveryMethod'
   */
  export type EnumDeliveryMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryMethod'>
    


  /**
   * Reference to a field of type 'CommunicationStatus'
   */
  export type EnumCommunicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommunicationStatus'>
    


  /**
   * Reference to a field of type 'ModificationType'
   */
  export type EnumModificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModificationType'>
    


  /**
   * Reference to a field of type 'EntryType'
   */
  export type EnumEntryTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntryType'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'EntryStatus'
   */
  export type EnumEntryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntryStatus'>
    


  /**
   * Reference to a field of type 'ActaArea'
   */
  export type EnumActaAreaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActaArea'>
    


  /**
   * Reference to a field of type 'ActaStatus'
   */
  export type EnumActaStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActaStatus'>
    


  /**
   * Reference to a field of type 'CommitmentStatus'
   */
  export type EnumCommitmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommitmentStatus'>
    


  /**
   * Reference to a field of type 'CostActaStatus'
   */
  export type EnumCostActaStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CostActaStatus'>
    


  /**
   * Reference to a field of type 'ReportScope'
   */
  export type EnumReportScopeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportScope'>
    


  /**
   * Reference to a field of type 'ReportStatus'
   */
  export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus'>
    


  /**
   * Reference to a field of type 'DrawingDiscipline'
   */
  export type EnumDrawingDisciplineFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DrawingDiscipline'>
    


  /**
   * Reference to a field of type 'DrawingStatus'
   */
  export type EnumDrawingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DrawingStatus'>
    


  /**
   * Reference to a field of type 'WorkActaStatus'
   */
  export type EnumWorkActaStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkActaStatus'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    projectRole?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    appRole?: EnumAppRoleFilter<"User"> | $Enums.AppRole
    avatarUrl?: StringNullableFilter<"User"> | string | null
    status?: StringFilter<"User"> | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    tokenVersion?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    logEntries?: LogEntryListRelationFilter
    assignedTo?: LogEntryListRelationFilter
    comments?: CommentListRelationFilter
    signatures?: SignatureListRelationFilter
    communications?: CommunicationListRelationFilter
    statusChanges?: CommunicationStatusHistoryListRelationFilter
    photoEntries?: PhotoEntryListRelationFilter
    responsibleFor?: CommitmentListRelationFilter
    observations?: ObservationListRelationFilter
    reports?: ReportListRelationFilter
    drawingVersions?: DrawingVersionListRelationFilter
    logEntryHistory?: LogEntryHistoryListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    projectRole?: SortOrder
    appRole?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    tokenVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    logEntries?: LogEntryOrderByRelationAggregateInput
    assignedTo?: LogEntryOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    signatures?: SignatureOrderByRelationAggregateInput
    communications?: CommunicationOrderByRelationAggregateInput
    statusChanges?: CommunicationStatusHistoryOrderByRelationAggregateInput
    photoEntries?: PhotoEntryOrderByRelationAggregateInput
    responsibleFor?: CommitmentOrderByRelationAggregateInput
    observations?: ObservationOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    drawingVersions?: DrawingVersionOrderByRelationAggregateInput
    logEntryHistory?: LogEntryHistoryOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    projectRole?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    appRole?: EnumAppRoleFilter<"User"> | $Enums.AppRole
    avatarUrl?: StringNullableFilter<"User"> | string | null
    status?: StringFilter<"User"> | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    tokenVersion?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    logEntries?: LogEntryListRelationFilter
    assignedTo?: LogEntryListRelationFilter
    comments?: CommentListRelationFilter
    signatures?: SignatureListRelationFilter
    communications?: CommunicationListRelationFilter
    statusChanges?: CommunicationStatusHistoryListRelationFilter
    photoEntries?: PhotoEntryListRelationFilter
    responsibleFor?: CommitmentListRelationFilter
    observations?: ObservationListRelationFilter
    reports?: ReportListRelationFilter
    drawingVersions?: DrawingVersionListRelationFilter
    logEntryHistory?: LogEntryHistoryListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    projectRole?: SortOrder
    appRole?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    tokenVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    fullName?: StringWithAggregatesFilter<"User"> | string
    projectRole?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    appRole?: EnumAppRoleWithAggregatesFilter<"User"> | $Enums.AppRole
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    status?: StringWithAggregatesFilter<"User"> | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    tokenVersion?: IntWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    contractId?: StringFilter<"Project"> | string
    object?: StringFilter<"Project"> | string
    contractorName?: StringFilter<"Project"> | string
    supervisorName?: StringFilter<"Project"> | string
    initialValue?: FloatFilter<"Project"> | number
    startDate?: DateTimeFilter<"Project"> | Date | string
    initialEndDate?: DateTimeFilter<"Project"> | Date | string
    interventoriaContractId?: StringFilter<"Project"> | string
    interventoriaInitialValue?: FloatFilter<"Project"> | number
    technicalSupervisorName?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    keyPersonnel?: KeyPersonnelListRelationFilter
    logEntries?: LogEntryListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contractId?: SortOrder
    object?: SortOrder
    contractorName?: SortOrder
    supervisorName?: SortOrder
    initialValue?: SortOrder
    startDate?: SortOrder
    initialEndDate?: SortOrder
    interventoriaContractId?: SortOrder
    interventoriaInitialValue?: SortOrder
    technicalSupervisorName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    keyPersonnel?: KeyPersonnelOrderByRelationAggregateInput
    logEntries?: LogEntryOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contractId?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    object?: StringFilter<"Project"> | string
    contractorName?: StringFilter<"Project"> | string
    supervisorName?: StringFilter<"Project"> | string
    initialValue?: FloatFilter<"Project"> | number
    startDate?: DateTimeFilter<"Project"> | Date | string
    initialEndDate?: DateTimeFilter<"Project"> | Date | string
    interventoriaContractId?: StringFilter<"Project"> | string
    interventoriaInitialValue?: FloatFilter<"Project"> | number
    technicalSupervisorName?: StringFilter<"Project"> | string
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    keyPersonnel?: KeyPersonnelListRelationFilter
    logEntries?: LogEntryListRelationFilter
  }, "id" | "contractId">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contractId?: SortOrder
    object?: SortOrder
    contractorName?: SortOrder
    supervisorName?: SortOrder
    initialValue?: SortOrder
    startDate?: SortOrder
    initialEndDate?: SortOrder
    interventoriaContractId?: SortOrder
    interventoriaInitialValue?: SortOrder
    technicalSupervisorName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    contractId?: StringWithAggregatesFilter<"Project"> | string
    object?: StringWithAggregatesFilter<"Project"> | string
    contractorName?: StringWithAggregatesFilter<"Project"> | string
    supervisorName?: StringWithAggregatesFilter<"Project"> | string
    initialValue?: FloatWithAggregatesFilter<"Project"> | number
    startDate?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    initialEndDate?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    interventoriaContractId?: StringWithAggregatesFilter<"Project"> | string
    interventoriaInitialValue?: FloatWithAggregatesFilter<"Project"> | number
    technicalSupervisorName?: StringWithAggregatesFilter<"Project"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type KeyPersonnelWhereInput = {
    AND?: KeyPersonnelWhereInput | KeyPersonnelWhereInput[]
    OR?: KeyPersonnelWhereInput[]
    NOT?: KeyPersonnelWhereInput | KeyPersonnelWhereInput[]
    id?: StringFilter<"KeyPersonnel"> | string
    name?: StringFilter<"KeyPersonnel"> | string
    role?: StringFilter<"KeyPersonnel"> | string
    company?: StringFilter<"KeyPersonnel"> | string
    email?: StringFilter<"KeyPersonnel"> | string
    phone?: StringFilter<"KeyPersonnel"> | string
    projectId?: StringFilter<"KeyPersonnel"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }

  export type KeyPersonnelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    company?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type KeyPersonnelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KeyPersonnelWhereInput | KeyPersonnelWhereInput[]
    OR?: KeyPersonnelWhereInput[]
    NOT?: KeyPersonnelWhereInput | KeyPersonnelWhereInput[]
    name?: StringFilter<"KeyPersonnel"> | string
    role?: StringFilter<"KeyPersonnel"> | string
    company?: StringFilter<"KeyPersonnel"> | string
    email?: StringFilter<"KeyPersonnel"> | string
    phone?: StringFilter<"KeyPersonnel"> | string
    projectId?: StringFilter<"KeyPersonnel"> | string
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
  }, "id">

  export type KeyPersonnelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    company?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    projectId?: SortOrder
    _count?: KeyPersonnelCountOrderByAggregateInput
    _max?: KeyPersonnelMaxOrderByAggregateInput
    _min?: KeyPersonnelMinOrderByAggregateInput
  }

  export type KeyPersonnelScalarWhereWithAggregatesInput = {
    AND?: KeyPersonnelScalarWhereWithAggregatesInput | KeyPersonnelScalarWhereWithAggregatesInput[]
    OR?: KeyPersonnelScalarWhereWithAggregatesInput[]
    NOT?: KeyPersonnelScalarWhereWithAggregatesInput | KeyPersonnelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KeyPersonnel"> | string
    name?: StringWithAggregatesFilter<"KeyPersonnel"> | string
    role?: StringWithAggregatesFilter<"KeyPersonnel"> | string
    company?: StringWithAggregatesFilter<"KeyPersonnel"> | string
    email?: StringWithAggregatesFilter<"KeyPersonnel"> | string
    phone?: StringWithAggregatesFilter<"KeyPersonnel"> | string
    projectId?: StringWithAggregatesFilter<"KeyPersonnel"> | string
  }

  export type CommunicationWhereInput = {
    AND?: CommunicationWhereInput | CommunicationWhereInput[]
    OR?: CommunicationWhereInput[]
    NOT?: CommunicationWhereInput | CommunicationWhereInput[]
    id?: StringFilter<"Communication"> | string
    radicado?: StringFilter<"Communication"> | string
    subject?: StringFilter<"Communication"> | string
    description?: StringFilter<"Communication"> | string
    senderEntity?: StringFilter<"Communication"> | string
    senderName?: StringFilter<"Communication"> | string
    senderTitle?: StringFilter<"Communication"> | string
    recipientEntity?: StringFilter<"Communication"> | string
    recipientName?: StringFilter<"Communication"> | string
    recipientTitle?: StringFilter<"Communication"> | string
    signerName?: StringFilter<"Communication"> | string
    sentDate?: DateTimeFilter<"Communication"> | Date | string
    dueDate?: DateTimeNullableFilter<"Communication"> | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFilter<"Communication"> | $Enums.DeliveryMethod
    notes?: StringNullableFilter<"Communication"> | string | null
    status?: EnumCommunicationStatusFilter<"Communication"> | $Enums.CommunicationStatus
    uploaderId?: StringFilter<"Communication"> | string
    parentId?: StringNullableFilter<"Communication"> | string | null
    createdAt?: DateTimeFilter<"Communication"> | Date | string
    updatedAt?: DateTimeFilter<"Communication"> | Date | string
    uploader?: XOR<UserRelationFilter, UserWhereInput>
    parent?: XOR<CommunicationNullableRelationFilter, CommunicationWhereInput> | null
    replies?: CommunicationListRelationFilter
    statusHistory?: CommunicationStatusHistoryListRelationFilter
    attachments?: AttachmentListRelationFilter
  }

  export type CommunicationOrderByWithRelationInput = {
    id?: SortOrder
    radicado?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    senderEntity?: SortOrder
    senderName?: SortOrder
    senderTitle?: SortOrder
    recipientEntity?: SortOrder
    recipientName?: SortOrder
    recipientTitle?: SortOrder
    signerName?: SortOrder
    sentDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    deliveryMethod?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    uploaderId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uploader?: UserOrderByWithRelationInput
    parent?: CommunicationOrderByWithRelationInput
    replies?: CommunicationOrderByRelationAggregateInput
    statusHistory?: CommunicationStatusHistoryOrderByRelationAggregateInput
    attachments?: AttachmentOrderByRelationAggregateInput
  }

  export type CommunicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    radicado?: string
    AND?: CommunicationWhereInput | CommunicationWhereInput[]
    OR?: CommunicationWhereInput[]
    NOT?: CommunicationWhereInput | CommunicationWhereInput[]
    subject?: StringFilter<"Communication"> | string
    description?: StringFilter<"Communication"> | string
    senderEntity?: StringFilter<"Communication"> | string
    senderName?: StringFilter<"Communication"> | string
    senderTitle?: StringFilter<"Communication"> | string
    recipientEntity?: StringFilter<"Communication"> | string
    recipientName?: StringFilter<"Communication"> | string
    recipientTitle?: StringFilter<"Communication"> | string
    signerName?: StringFilter<"Communication"> | string
    sentDate?: DateTimeFilter<"Communication"> | Date | string
    dueDate?: DateTimeNullableFilter<"Communication"> | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFilter<"Communication"> | $Enums.DeliveryMethod
    notes?: StringNullableFilter<"Communication"> | string | null
    status?: EnumCommunicationStatusFilter<"Communication"> | $Enums.CommunicationStatus
    uploaderId?: StringFilter<"Communication"> | string
    parentId?: StringNullableFilter<"Communication"> | string | null
    createdAt?: DateTimeFilter<"Communication"> | Date | string
    updatedAt?: DateTimeFilter<"Communication"> | Date | string
    uploader?: XOR<UserRelationFilter, UserWhereInput>
    parent?: XOR<CommunicationNullableRelationFilter, CommunicationWhereInput> | null
    replies?: CommunicationListRelationFilter
    statusHistory?: CommunicationStatusHistoryListRelationFilter
    attachments?: AttachmentListRelationFilter
  }, "id" | "radicado">

  export type CommunicationOrderByWithAggregationInput = {
    id?: SortOrder
    radicado?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    senderEntity?: SortOrder
    senderName?: SortOrder
    senderTitle?: SortOrder
    recipientEntity?: SortOrder
    recipientName?: SortOrder
    recipientTitle?: SortOrder
    signerName?: SortOrder
    sentDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    deliveryMethod?: SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    uploaderId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommunicationCountOrderByAggregateInput
    _max?: CommunicationMaxOrderByAggregateInput
    _min?: CommunicationMinOrderByAggregateInput
  }

  export type CommunicationScalarWhereWithAggregatesInput = {
    AND?: CommunicationScalarWhereWithAggregatesInput | CommunicationScalarWhereWithAggregatesInput[]
    OR?: CommunicationScalarWhereWithAggregatesInput[]
    NOT?: CommunicationScalarWhereWithAggregatesInput | CommunicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Communication"> | string
    radicado?: StringWithAggregatesFilter<"Communication"> | string
    subject?: StringWithAggregatesFilter<"Communication"> | string
    description?: StringWithAggregatesFilter<"Communication"> | string
    senderEntity?: StringWithAggregatesFilter<"Communication"> | string
    senderName?: StringWithAggregatesFilter<"Communication"> | string
    senderTitle?: StringWithAggregatesFilter<"Communication"> | string
    recipientEntity?: StringWithAggregatesFilter<"Communication"> | string
    recipientName?: StringWithAggregatesFilter<"Communication"> | string
    recipientTitle?: StringWithAggregatesFilter<"Communication"> | string
    signerName?: StringWithAggregatesFilter<"Communication"> | string
    sentDate?: DateTimeWithAggregatesFilter<"Communication"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Communication"> | Date | string | null
    deliveryMethod?: EnumDeliveryMethodWithAggregatesFilter<"Communication"> | $Enums.DeliveryMethod
    notes?: StringNullableWithAggregatesFilter<"Communication"> | string | null
    status?: EnumCommunicationStatusWithAggregatesFilter<"Communication"> | $Enums.CommunicationStatus
    uploaderId?: StringWithAggregatesFilter<"Communication"> | string
    parentId?: StringNullableWithAggregatesFilter<"Communication"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Communication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Communication"> | Date | string
  }

  export type CommunicationStatusHistoryWhereInput = {
    AND?: CommunicationStatusHistoryWhereInput | CommunicationStatusHistoryWhereInput[]
    OR?: CommunicationStatusHistoryWhereInput[]
    NOT?: CommunicationStatusHistoryWhereInput | CommunicationStatusHistoryWhereInput[]
    id?: StringFilter<"CommunicationStatusHistory"> | string
    status?: StringFilter<"CommunicationStatusHistory"> | string
    timestamp?: DateTimeFilter<"CommunicationStatusHistory"> | Date | string
    communicationId?: StringFilter<"CommunicationStatusHistory"> | string
    userId?: StringFilter<"CommunicationStatusHistory"> | string
    communication?: XOR<CommunicationRelationFilter, CommunicationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CommunicationStatusHistoryOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    communicationId?: SortOrder
    userId?: SortOrder
    communication?: CommunicationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CommunicationStatusHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommunicationStatusHistoryWhereInput | CommunicationStatusHistoryWhereInput[]
    OR?: CommunicationStatusHistoryWhereInput[]
    NOT?: CommunicationStatusHistoryWhereInput | CommunicationStatusHistoryWhereInput[]
    status?: StringFilter<"CommunicationStatusHistory"> | string
    timestamp?: DateTimeFilter<"CommunicationStatusHistory"> | Date | string
    communicationId?: StringFilter<"CommunicationStatusHistory"> | string
    userId?: StringFilter<"CommunicationStatusHistory"> | string
    communication?: XOR<CommunicationRelationFilter, CommunicationWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type CommunicationStatusHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    communicationId?: SortOrder
    userId?: SortOrder
    _count?: CommunicationStatusHistoryCountOrderByAggregateInput
    _max?: CommunicationStatusHistoryMaxOrderByAggregateInput
    _min?: CommunicationStatusHistoryMinOrderByAggregateInput
  }

  export type CommunicationStatusHistoryScalarWhereWithAggregatesInput = {
    AND?: CommunicationStatusHistoryScalarWhereWithAggregatesInput | CommunicationStatusHistoryScalarWhereWithAggregatesInput[]
    OR?: CommunicationStatusHistoryScalarWhereWithAggregatesInput[]
    NOT?: CommunicationStatusHistoryScalarWhereWithAggregatesInput | CommunicationStatusHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommunicationStatusHistory"> | string
    status?: StringWithAggregatesFilter<"CommunicationStatusHistory"> | string
    timestamp?: DateTimeWithAggregatesFilter<"CommunicationStatusHistory"> | Date | string
    communicationId?: StringWithAggregatesFilter<"CommunicationStatusHistory"> | string
    userId?: StringWithAggregatesFilter<"CommunicationStatusHistory"> | string
  }

  export type ContractModificationWhereInput = {
    AND?: ContractModificationWhereInput | ContractModificationWhereInput[]
    OR?: ContractModificationWhereInput[]
    NOT?: ContractModificationWhereInput | ContractModificationWhereInput[]
    id?: StringFilter<"ContractModification"> | string
    number?: StringFilter<"ContractModification"> | string
    type?: EnumModificationTypeFilter<"ContractModification"> | $Enums.ModificationType
    date?: DateTimeFilter<"ContractModification"> | Date | string
    value?: FloatNullableFilter<"ContractModification"> | number | null
    days?: IntNullableFilter<"ContractModification"> | number | null
    justification?: StringFilter<"ContractModification"> | string
    attachmentId?: StringNullableFilter<"ContractModification"> | string | null
    createdAt?: DateTimeFilter<"ContractModification"> | Date | string
    updatedAt?: DateTimeFilter<"ContractModification"> | Date | string
    attachment?: XOR<AttachmentNullableRelationFilter, AttachmentWhereInput> | null
  }

  export type ContractModificationOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    date?: SortOrder
    value?: SortOrderInput | SortOrder
    days?: SortOrderInput | SortOrder
    justification?: SortOrder
    attachmentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    attachment?: AttachmentOrderByWithRelationInput
  }

  export type ContractModificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    number?: string
    attachmentId?: string
    AND?: ContractModificationWhereInput | ContractModificationWhereInput[]
    OR?: ContractModificationWhereInput[]
    NOT?: ContractModificationWhereInput | ContractModificationWhereInput[]
    type?: EnumModificationTypeFilter<"ContractModification"> | $Enums.ModificationType
    date?: DateTimeFilter<"ContractModification"> | Date | string
    value?: FloatNullableFilter<"ContractModification"> | number | null
    days?: IntNullableFilter<"ContractModification"> | number | null
    justification?: StringFilter<"ContractModification"> | string
    createdAt?: DateTimeFilter<"ContractModification"> | Date | string
    updatedAt?: DateTimeFilter<"ContractModification"> | Date | string
    attachment?: XOR<AttachmentNullableRelationFilter, AttachmentWhereInput> | null
  }, "id" | "number" | "attachmentId">

  export type ContractModificationOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    date?: SortOrder
    value?: SortOrderInput | SortOrder
    days?: SortOrderInput | SortOrder
    justification?: SortOrder
    attachmentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContractModificationCountOrderByAggregateInput
    _avg?: ContractModificationAvgOrderByAggregateInput
    _max?: ContractModificationMaxOrderByAggregateInput
    _min?: ContractModificationMinOrderByAggregateInput
    _sum?: ContractModificationSumOrderByAggregateInput
  }

  export type ContractModificationScalarWhereWithAggregatesInput = {
    AND?: ContractModificationScalarWhereWithAggregatesInput | ContractModificationScalarWhereWithAggregatesInput[]
    OR?: ContractModificationScalarWhereWithAggregatesInput[]
    NOT?: ContractModificationScalarWhereWithAggregatesInput | ContractModificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContractModification"> | string
    number?: StringWithAggregatesFilter<"ContractModification"> | string
    type?: EnumModificationTypeWithAggregatesFilter<"ContractModification"> | $Enums.ModificationType
    date?: DateTimeWithAggregatesFilter<"ContractModification"> | Date | string
    value?: FloatNullableWithAggregatesFilter<"ContractModification"> | number | null
    days?: IntNullableWithAggregatesFilter<"ContractModification"> | number | null
    justification?: StringWithAggregatesFilter<"ContractModification"> | string
    attachmentId?: StringNullableWithAggregatesFilter<"ContractModification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContractModification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContractModification"> | Date | string
  }

  export type WeeklyReportWhereInput = {
    AND?: WeeklyReportWhereInput | WeeklyReportWhereInput[]
    OR?: WeeklyReportWhereInput[]
    NOT?: WeeklyReportWhereInput | WeeklyReportWhereInput[]
    id?: StringFilter<"WeeklyReport"> | string
    number?: StringFilter<"WeeklyReport"> | string
    startDate?: DateTimeFilter<"WeeklyReport"> | Date | string
    endDate?: DateTimeFilter<"WeeklyReport"> | Date | string
    summary?: StringFilter<"WeeklyReport"> | string
    progressSummary?: StringNullableFilter<"WeeklyReport"> | string | null
    nextWeekPlan?: StringNullableFilter<"WeeklyReport"> | string | null
    issues?: StringNullableFilter<"WeeklyReport"> | string | null
    createdAt?: DateTimeFilter<"WeeklyReport"> | Date | string
    updatedAt?: DateTimeFilter<"WeeklyReport"> | Date | string
    attachments?: AttachmentListRelationFilter
  }

  export type WeeklyReportOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    summary?: SortOrder
    progressSummary?: SortOrderInput | SortOrder
    nextWeekPlan?: SortOrderInput | SortOrder
    issues?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    attachments?: AttachmentOrderByRelationAggregateInput
  }

  export type WeeklyReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    number?: string
    AND?: WeeklyReportWhereInput | WeeklyReportWhereInput[]
    OR?: WeeklyReportWhereInput[]
    NOT?: WeeklyReportWhereInput | WeeklyReportWhereInput[]
    startDate?: DateTimeFilter<"WeeklyReport"> | Date | string
    endDate?: DateTimeFilter<"WeeklyReport"> | Date | string
    summary?: StringFilter<"WeeklyReport"> | string
    progressSummary?: StringNullableFilter<"WeeklyReport"> | string | null
    nextWeekPlan?: StringNullableFilter<"WeeklyReport"> | string | null
    issues?: StringNullableFilter<"WeeklyReport"> | string | null
    createdAt?: DateTimeFilter<"WeeklyReport"> | Date | string
    updatedAt?: DateTimeFilter<"WeeklyReport"> | Date | string
    attachments?: AttachmentListRelationFilter
  }, "id" | "number">

  export type WeeklyReportOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    summary?: SortOrder
    progressSummary?: SortOrderInput | SortOrder
    nextWeekPlan?: SortOrderInput | SortOrder
    issues?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WeeklyReportCountOrderByAggregateInput
    _max?: WeeklyReportMaxOrderByAggregateInput
    _min?: WeeklyReportMinOrderByAggregateInput
  }

  export type WeeklyReportScalarWhereWithAggregatesInput = {
    AND?: WeeklyReportScalarWhereWithAggregatesInput | WeeklyReportScalarWhereWithAggregatesInput[]
    OR?: WeeklyReportScalarWhereWithAggregatesInput[]
    NOT?: WeeklyReportScalarWhereWithAggregatesInput | WeeklyReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WeeklyReport"> | string
    number?: StringWithAggregatesFilter<"WeeklyReport"> | string
    startDate?: DateTimeWithAggregatesFilter<"WeeklyReport"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"WeeklyReport"> | Date | string
    summary?: StringWithAggregatesFilter<"WeeklyReport"> | string
    progressSummary?: StringNullableWithAggregatesFilter<"WeeklyReport"> | string | null
    nextWeekPlan?: StringNullableWithAggregatesFilter<"WeeklyReport"> | string | null
    issues?: StringNullableWithAggregatesFilter<"WeeklyReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WeeklyReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WeeklyReport"> | Date | string
  }

  export type LogEntryWhereInput = {
    AND?: LogEntryWhereInput | LogEntryWhereInput[]
    OR?: LogEntryWhereInput[]
    NOT?: LogEntryWhereInput | LogEntryWhereInput[]
    id?: StringFilter<"LogEntry"> | string
    folioNumber?: IntFilter<"LogEntry"> | number
    title?: StringFilter<"LogEntry"> | string
    description?: StringFilter<"LogEntry"> | string
    type?: EnumEntryTypeFilter<"LogEntry"> | $Enums.EntryType
    subject?: StringFilter<"LogEntry"> | string
    location?: StringFilter<"LogEntry"> | string
    activityStartDate?: DateTimeFilter<"LogEntry"> | Date | string
    activityEndDate?: DateTimeFilter<"LogEntry"> | Date | string
    isConfidential?: BoolFilter<"LogEntry"> | boolean
    status?: EnumEntryStatusFilter<"LogEntry"> | $Enums.EntryStatus
    authorId?: StringFilter<"LogEntry"> | string
    projectId?: StringFilter<"LogEntry"> | string
    createdAt?: DateTimeFilter<"LogEntry"> | Date | string
    updatedAt?: DateTimeFilter<"LogEntry"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    assignees?: UserListRelationFilter
    comments?: CommentListRelationFilter
    attachments?: AttachmentListRelationFilter
    signatures?: SignatureListRelationFilter
    history?: LogEntryHistoryListRelationFilter
  }

  export type LogEntryOrderByWithRelationInput = {
    id?: SortOrder
    folioNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    location?: SortOrder
    activityStartDate?: SortOrder
    activityEndDate?: SortOrder
    isConfidential?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    assignees?: UserOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    attachments?: AttachmentOrderByRelationAggregateInput
    signatures?: SignatureOrderByRelationAggregateInput
    history?: LogEntryHistoryOrderByRelationAggregateInput
  }

  export type LogEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    folioNumber?: number
    AND?: LogEntryWhereInput | LogEntryWhereInput[]
    OR?: LogEntryWhereInput[]
    NOT?: LogEntryWhereInput | LogEntryWhereInput[]
    title?: StringFilter<"LogEntry"> | string
    description?: StringFilter<"LogEntry"> | string
    type?: EnumEntryTypeFilter<"LogEntry"> | $Enums.EntryType
    subject?: StringFilter<"LogEntry"> | string
    location?: StringFilter<"LogEntry"> | string
    activityStartDate?: DateTimeFilter<"LogEntry"> | Date | string
    activityEndDate?: DateTimeFilter<"LogEntry"> | Date | string
    isConfidential?: BoolFilter<"LogEntry"> | boolean
    status?: EnumEntryStatusFilter<"LogEntry"> | $Enums.EntryStatus
    authorId?: StringFilter<"LogEntry"> | string
    projectId?: StringFilter<"LogEntry"> | string
    createdAt?: DateTimeFilter<"LogEntry"> | Date | string
    updatedAt?: DateTimeFilter<"LogEntry"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    project?: XOR<ProjectRelationFilter, ProjectWhereInput>
    assignees?: UserListRelationFilter
    comments?: CommentListRelationFilter
    attachments?: AttachmentListRelationFilter
    signatures?: SignatureListRelationFilter
    history?: LogEntryHistoryListRelationFilter
  }, "id" | "folioNumber">

  export type LogEntryOrderByWithAggregationInput = {
    id?: SortOrder
    folioNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    location?: SortOrder
    activityStartDate?: SortOrder
    activityEndDate?: SortOrder
    isConfidential?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LogEntryCountOrderByAggregateInput
    _avg?: LogEntryAvgOrderByAggregateInput
    _max?: LogEntryMaxOrderByAggregateInput
    _min?: LogEntryMinOrderByAggregateInput
    _sum?: LogEntrySumOrderByAggregateInput
  }

  export type LogEntryScalarWhereWithAggregatesInput = {
    AND?: LogEntryScalarWhereWithAggregatesInput | LogEntryScalarWhereWithAggregatesInput[]
    OR?: LogEntryScalarWhereWithAggregatesInput[]
    NOT?: LogEntryScalarWhereWithAggregatesInput | LogEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LogEntry"> | string
    folioNumber?: IntWithAggregatesFilter<"LogEntry"> | number
    title?: StringWithAggregatesFilter<"LogEntry"> | string
    description?: StringWithAggregatesFilter<"LogEntry"> | string
    type?: EnumEntryTypeWithAggregatesFilter<"LogEntry"> | $Enums.EntryType
    subject?: StringWithAggregatesFilter<"LogEntry"> | string
    location?: StringWithAggregatesFilter<"LogEntry"> | string
    activityStartDate?: DateTimeWithAggregatesFilter<"LogEntry"> | Date | string
    activityEndDate?: DateTimeWithAggregatesFilter<"LogEntry"> | Date | string
    isConfidential?: BoolWithAggregatesFilter<"LogEntry"> | boolean
    status?: EnumEntryStatusWithAggregatesFilter<"LogEntry"> | $Enums.EntryStatus
    authorId?: StringWithAggregatesFilter<"LogEntry"> | string
    projectId?: StringWithAggregatesFilter<"LogEntry"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LogEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LogEntry"> | Date | string
  }

  export type LogEntryHistoryWhereInput = {
    AND?: LogEntryHistoryWhereInput | LogEntryHistoryWhereInput[]
    OR?: LogEntryHistoryWhereInput[]
    NOT?: LogEntryHistoryWhereInput | LogEntryHistoryWhereInput[]
    id?: StringFilter<"LogEntryHistory"> | string
    fieldName?: StringFilter<"LogEntryHistory"> | string
    oldValue?: StringNullableFilter<"LogEntryHistory"> | string | null
    newValue?: StringNullableFilter<"LogEntryHistory"> | string | null
    timestamp?: DateTimeFilter<"LogEntryHistory"> | Date | string
    logEntryId?: StringFilter<"LogEntryHistory"> | string
    userId?: StringNullableFilter<"LogEntryHistory"> | string | null
    logEntry?: XOR<LogEntryRelationFilter, LogEntryWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type LogEntryHistoryOrderByWithRelationInput = {
    id?: SortOrder
    fieldName?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    logEntryId?: SortOrder
    userId?: SortOrderInput | SortOrder
    logEntry?: LogEntryOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type LogEntryHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LogEntryHistoryWhereInput | LogEntryHistoryWhereInput[]
    OR?: LogEntryHistoryWhereInput[]
    NOT?: LogEntryHistoryWhereInput | LogEntryHistoryWhereInput[]
    fieldName?: StringFilter<"LogEntryHistory"> | string
    oldValue?: StringNullableFilter<"LogEntryHistory"> | string | null
    newValue?: StringNullableFilter<"LogEntryHistory"> | string | null
    timestamp?: DateTimeFilter<"LogEntryHistory"> | Date | string
    logEntryId?: StringFilter<"LogEntryHistory"> | string
    userId?: StringNullableFilter<"LogEntryHistory"> | string | null
    logEntry?: XOR<LogEntryRelationFilter, LogEntryWhereInput>
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type LogEntryHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    fieldName?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    logEntryId?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: LogEntryHistoryCountOrderByAggregateInput
    _max?: LogEntryHistoryMaxOrderByAggregateInput
    _min?: LogEntryHistoryMinOrderByAggregateInput
  }

  export type LogEntryHistoryScalarWhereWithAggregatesInput = {
    AND?: LogEntryHistoryScalarWhereWithAggregatesInput | LogEntryHistoryScalarWhereWithAggregatesInput[]
    OR?: LogEntryHistoryScalarWhereWithAggregatesInput[]
    NOT?: LogEntryHistoryScalarWhereWithAggregatesInput | LogEntryHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LogEntryHistory"> | string
    fieldName?: StringWithAggregatesFilter<"LogEntryHistory"> | string
    oldValue?: StringNullableWithAggregatesFilter<"LogEntryHistory"> | string | null
    newValue?: StringNullableWithAggregatesFilter<"LogEntryHistory"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"LogEntryHistory"> | Date | string
    logEntryId?: StringWithAggregatesFilter<"LogEntryHistory"> | string
    userId?: StringNullableWithAggregatesFilter<"LogEntryHistory"> | string | null
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    timestamp?: DateTimeFilter<"Comment"> | Date | string
    authorId?: StringFilter<"Comment"> | string
    logEntryId?: StringNullableFilter<"Comment"> | string | null
    drawingId?: StringNullableFilter<"Comment"> | string | null
    author?: XOR<UserRelationFilter, UserWhereInput>
    logEntry?: XOR<LogEntryNullableRelationFilter, LogEntryWhereInput> | null
    drawing?: XOR<DrawingNullableRelationFilter, DrawingWhereInput> | null
    attachments?: AttachmentListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    authorId?: SortOrder
    logEntryId?: SortOrderInput | SortOrder
    drawingId?: SortOrderInput | SortOrder
    author?: UserOrderByWithRelationInput
    logEntry?: LogEntryOrderByWithRelationInput
    drawing?: DrawingOrderByWithRelationInput
    attachments?: AttachmentOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    content?: StringFilter<"Comment"> | string
    timestamp?: DateTimeFilter<"Comment"> | Date | string
    authorId?: StringFilter<"Comment"> | string
    logEntryId?: StringNullableFilter<"Comment"> | string | null
    drawingId?: StringNullableFilter<"Comment"> | string | null
    author?: XOR<UserRelationFilter, UserWhereInput>
    logEntry?: XOR<LogEntryNullableRelationFilter, LogEntryWhereInput> | null
    drawing?: XOR<DrawingNullableRelationFilter, DrawingWhereInput> | null
    attachments?: AttachmentListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    authorId?: SortOrder
    logEntryId?: SortOrderInput | SortOrder
    drawingId?: SortOrderInput | SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    timestamp?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    authorId?: StringWithAggregatesFilter<"Comment"> | string
    logEntryId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    drawingId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
  }

  export type SignatureWhereInput = {
    AND?: SignatureWhereInput | SignatureWhereInput[]
    OR?: SignatureWhereInput[]
    NOT?: SignatureWhereInput | SignatureWhereInput[]
    id?: StringFilter<"Signature"> | string
    signedAt?: DateTimeFilter<"Signature"> | Date | string
    signerId?: StringFilter<"Signature"> | string
    logEntryId?: StringNullableFilter<"Signature"> | string | null
    actaId?: StringNullableFilter<"Signature"> | string | null
    reportId?: StringNullableFilter<"Signature"> | string | null
    signer?: XOR<UserRelationFilter, UserWhereInput>
    logEntry?: XOR<LogEntryNullableRelationFilter, LogEntryWhereInput> | null
    acta?: XOR<ActaNullableRelationFilter, ActaWhereInput> | null
    report?: XOR<ReportNullableRelationFilter, ReportWhereInput> | null
  }

  export type SignatureOrderByWithRelationInput = {
    id?: SortOrder
    signedAt?: SortOrder
    signerId?: SortOrder
    logEntryId?: SortOrderInput | SortOrder
    actaId?: SortOrderInput | SortOrder
    reportId?: SortOrderInput | SortOrder
    signer?: UserOrderByWithRelationInput
    logEntry?: LogEntryOrderByWithRelationInput
    acta?: ActaOrderByWithRelationInput
    report?: ReportOrderByWithRelationInput
  }

  export type SignatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SignatureWhereInput | SignatureWhereInput[]
    OR?: SignatureWhereInput[]
    NOT?: SignatureWhereInput | SignatureWhereInput[]
    signedAt?: DateTimeFilter<"Signature"> | Date | string
    signerId?: StringFilter<"Signature"> | string
    logEntryId?: StringNullableFilter<"Signature"> | string | null
    actaId?: StringNullableFilter<"Signature"> | string | null
    reportId?: StringNullableFilter<"Signature"> | string | null
    signer?: XOR<UserRelationFilter, UserWhereInput>
    logEntry?: XOR<LogEntryNullableRelationFilter, LogEntryWhereInput> | null
    acta?: XOR<ActaNullableRelationFilter, ActaWhereInput> | null
    report?: XOR<ReportNullableRelationFilter, ReportWhereInput> | null
  }, "id">

  export type SignatureOrderByWithAggregationInput = {
    id?: SortOrder
    signedAt?: SortOrder
    signerId?: SortOrder
    logEntryId?: SortOrderInput | SortOrder
    actaId?: SortOrderInput | SortOrder
    reportId?: SortOrderInput | SortOrder
    _count?: SignatureCountOrderByAggregateInput
    _max?: SignatureMaxOrderByAggregateInput
    _min?: SignatureMinOrderByAggregateInput
  }

  export type SignatureScalarWhereWithAggregatesInput = {
    AND?: SignatureScalarWhereWithAggregatesInput | SignatureScalarWhereWithAggregatesInput[]
    OR?: SignatureScalarWhereWithAggregatesInput[]
    NOT?: SignatureScalarWhereWithAggregatesInput | SignatureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Signature"> | string
    signedAt?: DateTimeWithAggregatesFilter<"Signature"> | Date | string
    signerId?: StringWithAggregatesFilter<"Signature"> | string
    logEntryId?: StringNullableWithAggregatesFilter<"Signature"> | string | null
    actaId?: StringNullableWithAggregatesFilter<"Signature"> | string | null
    reportId?: StringNullableWithAggregatesFilter<"Signature"> | string | null
  }

  export type AttachmentWhereInput = {
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    id?: StringFilter<"Attachment"> | string
    fileName?: StringFilter<"Attachment"> | string
    url?: StringFilter<"Attachment"> | string
    size?: IntFilter<"Attachment"> | number
    type?: StringFilter<"Attachment"> | string
    logEntryId?: StringNullableFilter<"Attachment"> | string | null
    communicationId?: StringNullableFilter<"Attachment"> | string | null
    actaId?: StringNullableFilter<"Attachment"> | string | null
    costActaId?: StringNullableFilter<"Attachment"> | string | null
    reportId?: StringNullableFilter<"Attachment"> | string | null
    commentId?: StringNullableFilter<"Attachment"> | string | null
    workActaId?: StringNullableFilter<"Attachment"> | string | null
    weeklyReportId?: StringNullableFilter<"Attachment"> | string | null
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    logEntry?: XOR<LogEntryNullableRelationFilter, LogEntryWhereInput> | null
    communication?: XOR<CommunicationNullableRelationFilter, CommunicationWhereInput> | null
    acta?: XOR<ActaNullableRelationFilter, ActaWhereInput> | null
    costActa?: XOR<CostActaNullableRelationFilter, CostActaWhereInput> | null
    report?: XOR<ReportNullableRelationFilter, ReportWhereInput> | null
    comment?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
    contractMod?: XOR<ContractModificationNullableRelationFilter, ContractModificationWhereInput> | null
    workActa?: XOR<WorkActaNullableRelationFilter, WorkActaWhereInput> | null
    weeklyReport?: XOR<WeeklyReportNullableRelationFilter, WeeklyReportWhereInput> | null
    photoEntry?: XOR<PhotoEntryNullableRelationFilter, PhotoEntryWhereInput> | null
  }

  export type AttachmentOrderByWithRelationInput = {
    id?: SortOrder
    fileName?: SortOrder
    url?: SortOrder
    size?: SortOrder
    type?: SortOrder
    logEntryId?: SortOrderInput | SortOrder
    communicationId?: SortOrderInput | SortOrder
    actaId?: SortOrderInput | SortOrder
    costActaId?: SortOrderInput | SortOrder
    reportId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    workActaId?: SortOrderInput | SortOrder
    weeklyReportId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    logEntry?: LogEntryOrderByWithRelationInput
    communication?: CommunicationOrderByWithRelationInput
    acta?: ActaOrderByWithRelationInput
    costActa?: CostActaOrderByWithRelationInput
    report?: ReportOrderByWithRelationInput
    comment?: CommentOrderByWithRelationInput
    contractMod?: ContractModificationOrderByWithRelationInput
    workActa?: WorkActaOrderByWithRelationInput
    weeklyReport?: WeeklyReportOrderByWithRelationInput
    photoEntry?: PhotoEntryOrderByWithRelationInput
  }

  export type AttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttachmentWhereInput | AttachmentWhereInput[]
    OR?: AttachmentWhereInput[]
    NOT?: AttachmentWhereInput | AttachmentWhereInput[]
    fileName?: StringFilter<"Attachment"> | string
    url?: StringFilter<"Attachment"> | string
    size?: IntFilter<"Attachment"> | number
    type?: StringFilter<"Attachment"> | string
    logEntryId?: StringNullableFilter<"Attachment"> | string | null
    communicationId?: StringNullableFilter<"Attachment"> | string | null
    actaId?: StringNullableFilter<"Attachment"> | string | null
    costActaId?: StringNullableFilter<"Attachment"> | string | null
    reportId?: StringNullableFilter<"Attachment"> | string | null
    commentId?: StringNullableFilter<"Attachment"> | string | null
    workActaId?: StringNullableFilter<"Attachment"> | string | null
    weeklyReportId?: StringNullableFilter<"Attachment"> | string | null
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
    logEntry?: XOR<LogEntryNullableRelationFilter, LogEntryWhereInput> | null
    communication?: XOR<CommunicationNullableRelationFilter, CommunicationWhereInput> | null
    acta?: XOR<ActaNullableRelationFilter, ActaWhereInput> | null
    costActa?: XOR<CostActaNullableRelationFilter, CostActaWhereInput> | null
    report?: XOR<ReportNullableRelationFilter, ReportWhereInput> | null
    comment?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
    contractMod?: XOR<ContractModificationNullableRelationFilter, ContractModificationWhereInput> | null
    workActa?: XOR<WorkActaNullableRelationFilter, WorkActaWhereInput> | null
    weeklyReport?: XOR<WeeklyReportNullableRelationFilter, WeeklyReportWhereInput> | null
    photoEntry?: XOR<PhotoEntryNullableRelationFilter, PhotoEntryWhereInput> | null
  }, "id">

  export type AttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    fileName?: SortOrder
    url?: SortOrder
    size?: SortOrder
    type?: SortOrder
    logEntryId?: SortOrderInput | SortOrder
    communicationId?: SortOrderInput | SortOrder
    actaId?: SortOrderInput | SortOrder
    costActaId?: SortOrderInput | SortOrder
    reportId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    workActaId?: SortOrderInput | SortOrder
    weeklyReportId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AttachmentCountOrderByAggregateInput
    _avg?: AttachmentAvgOrderByAggregateInput
    _max?: AttachmentMaxOrderByAggregateInput
    _min?: AttachmentMinOrderByAggregateInput
    _sum?: AttachmentSumOrderByAggregateInput
  }

  export type AttachmentScalarWhereWithAggregatesInput = {
    AND?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    OR?: AttachmentScalarWhereWithAggregatesInput[]
    NOT?: AttachmentScalarWhereWithAggregatesInput | AttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attachment"> | string
    fileName?: StringWithAggregatesFilter<"Attachment"> | string
    url?: StringWithAggregatesFilter<"Attachment"> | string
    size?: IntWithAggregatesFilter<"Attachment"> | number
    type?: StringWithAggregatesFilter<"Attachment"> | string
    logEntryId?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    communicationId?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    actaId?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    costActaId?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    reportId?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    commentId?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    workActaId?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    weeklyReportId?: StringNullableWithAggregatesFilter<"Attachment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Attachment"> | Date | string
  }

  export type ActaWhereInput = {
    AND?: ActaWhereInput | ActaWhereInput[]
    OR?: ActaWhereInput[]
    NOT?: ActaWhereInput | ActaWhereInput[]
    id?: StringFilter<"Acta"> | string
    number?: StringFilter<"Acta"> | string
    title?: StringFilter<"Acta"> | string
    date?: DateTimeFilter<"Acta"> | Date | string
    area?: EnumActaAreaFilter<"Acta"> | $Enums.ActaArea
    status?: EnumActaStatusFilter<"Acta"> | $Enums.ActaStatus
    summary?: StringFilter<"Acta"> | string
    requiredSignatoriesJson?: StringNullableFilter<"Acta"> | string | null
    createdAt?: DateTimeFilter<"Acta"> | Date | string
    updatedAt?: DateTimeFilter<"Acta"> | Date | string
    attachments?: AttachmentListRelationFilter
    signatures?: SignatureListRelationFilter
    commitments?: CommitmentListRelationFilter
  }

  export type ActaOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    title?: SortOrder
    date?: SortOrder
    area?: SortOrder
    status?: SortOrder
    summary?: SortOrder
    requiredSignatoriesJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    attachments?: AttachmentOrderByRelationAggregateInput
    signatures?: SignatureOrderByRelationAggregateInput
    commitments?: CommitmentOrderByRelationAggregateInput
  }

  export type ActaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    number?: string
    AND?: ActaWhereInput | ActaWhereInput[]
    OR?: ActaWhereInput[]
    NOT?: ActaWhereInput | ActaWhereInput[]
    title?: StringFilter<"Acta"> | string
    date?: DateTimeFilter<"Acta"> | Date | string
    area?: EnumActaAreaFilter<"Acta"> | $Enums.ActaArea
    status?: EnumActaStatusFilter<"Acta"> | $Enums.ActaStatus
    summary?: StringFilter<"Acta"> | string
    requiredSignatoriesJson?: StringNullableFilter<"Acta"> | string | null
    createdAt?: DateTimeFilter<"Acta"> | Date | string
    updatedAt?: DateTimeFilter<"Acta"> | Date | string
    attachments?: AttachmentListRelationFilter
    signatures?: SignatureListRelationFilter
    commitments?: CommitmentListRelationFilter
  }, "id" | "number">

  export type ActaOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    title?: SortOrder
    date?: SortOrder
    area?: SortOrder
    status?: SortOrder
    summary?: SortOrder
    requiredSignatoriesJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ActaCountOrderByAggregateInput
    _max?: ActaMaxOrderByAggregateInput
    _min?: ActaMinOrderByAggregateInput
  }

  export type ActaScalarWhereWithAggregatesInput = {
    AND?: ActaScalarWhereWithAggregatesInput | ActaScalarWhereWithAggregatesInput[]
    OR?: ActaScalarWhereWithAggregatesInput[]
    NOT?: ActaScalarWhereWithAggregatesInput | ActaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Acta"> | string
    number?: StringWithAggregatesFilter<"Acta"> | string
    title?: StringWithAggregatesFilter<"Acta"> | string
    date?: DateTimeWithAggregatesFilter<"Acta"> | Date | string
    area?: EnumActaAreaWithAggregatesFilter<"Acta"> | $Enums.ActaArea
    status?: EnumActaStatusWithAggregatesFilter<"Acta"> | $Enums.ActaStatus
    summary?: StringWithAggregatesFilter<"Acta"> | string
    requiredSignatoriesJson?: StringNullableWithAggregatesFilter<"Acta"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Acta"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Acta"> | Date | string
  }

  export type CommitmentWhereInput = {
    AND?: CommitmentWhereInput | CommitmentWhereInput[]
    OR?: CommitmentWhereInput[]
    NOT?: CommitmentWhereInput | CommitmentWhereInput[]
    id?: StringFilter<"Commitment"> | string
    description?: StringFilter<"Commitment"> | string
    dueDate?: DateTimeFilter<"Commitment"> | Date | string
    status?: EnumCommitmentStatusFilter<"Commitment"> | $Enums.CommitmentStatus
    responsibleId?: StringFilter<"Commitment"> | string
    actaId?: StringFilter<"Commitment"> | string
    createdAt?: DateTimeFilter<"Commitment"> | Date | string
    updatedAt?: DateTimeFilter<"Commitment"> | Date | string
    responsible?: XOR<UserRelationFilter, UserWhereInput>
    acta?: XOR<ActaRelationFilter, ActaWhereInput>
  }

  export type CommitmentOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    responsibleId?: SortOrder
    actaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    responsible?: UserOrderByWithRelationInput
    acta?: ActaOrderByWithRelationInput
  }

  export type CommitmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommitmentWhereInput | CommitmentWhereInput[]
    OR?: CommitmentWhereInput[]
    NOT?: CommitmentWhereInput | CommitmentWhereInput[]
    description?: StringFilter<"Commitment"> | string
    dueDate?: DateTimeFilter<"Commitment"> | Date | string
    status?: EnumCommitmentStatusFilter<"Commitment"> | $Enums.CommitmentStatus
    responsibleId?: StringFilter<"Commitment"> | string
    actaId?: StringFilter<"Commitment"> | string
    createdAt?: DateTimeFilter<"Commitment"> | Date | string
    updatedAt?: DateTimeFilter<"Commitment"> | Date | string
    responsible?: XOR<UserRelationFilter, UserWhereInput>
    acta?: XOR<ActaRelationFilter, ActaWhereInput>
  }, "id">

  export type CommitmentOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    responsibleId?: SortOrder
    actaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommitmentCountOrderByAggregateInput
    _max?: CommitmentMaxOrderByAggregateInput
    _min?: CommitmentMinOrderByAggregateInput
  }

  export type CommitmentScalarWhereWithAggregatesInput = {
    AND?: CommitmentScalarWhereWithAggregatesInput | CommitmentScalarWhereWithAggregatesInput[]
    OR?: CommitmentScalarWhereWithAggregatesInput[]
    NOT?: CommitmentScalarWhereWithAggregatesInput | CommitmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Commitment"> | string
    description?: StringWithAggregatesFilter<"Commitment"> | string
    dueDate?: DateTimeWithAggregatesFilter<"Commitment"> | Date | string
    status?: EnumCommitmentStatusWithAggregatesFilter<"Commitment"> | $Enums.CommitmentStatus
    responsibleId?: StringWithAggregatesFilter<"Commitment"> | string
    actaId?: StringWithAggregatesFilter<"Commitment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Commitment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Commitment"> | Date | string
  }

  export type CostActaWhereInput = {
    AND?: CostActaWhereInput | CostActaWhereInput[]
    OR?: CostActaWhereInput[]
    NOT?: CostActaWhereInput | CostActaWhereInput[]
    id?: StringFilter<"CostActa"> | string
    number?: StringFilter<"CostActa"> | string
    period?: StringFilter<"CostActa"> | string
    submissionDate?: DateTimeFilter<"CostActa"> | Date | string
    approvalDate?: DateTimeNullableFilter<"CostActa"> | Date | string | null
    paymentDueDate?: DateTimeNullableFilter<"CostActa"> | Date | string | null
    billedAmount?: FloatFilter<"CostActa"> | number
    totalContractValue?: FloatFilter<"CostActa"> | number
    status?: EnumCostActaStatusFilter<"CostActa"> | $Enums.CostActaStatus
    relatedProgress?: StringNullableFilter<"CostActa"> | string | null
    createdAt?: DateTimeFilter<"CostActa"> | Date | string
    updatedAt?: DateTimeFilter<"CostActa"> | Date | string
    observations?: ObservationListRelationFilter
    attachments?: AttachmentListRelationFilter
  }

  export type CostActaOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    period?: SortOrder
    submissionDate?: SortOrder
    approvalDate?: SortOrderInput | SortOrder
    paymentDueDate?: SortOrderInput | SortOrder
    billedAmount?: SortOrder
    totalContractValue?: SortOrder
    status?: SortOrder
    relatedProgress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    observations?: ObservationOrderByRelationAggregateInput
    attachments?: AttachmentOrderByRelationAggregateInput
  }

  export type CostActaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    number?: string
    AND?: CostActaWhereInput | CostActaWhereInput[]
    OR?: CostActaWhereInput[]
    NOT?: CostActaWhereInput | CostActaWhereInput[]
    period?: StringFilter<"CostActa"> | string
    submissionDate?: DateTimeFilter<"CostActa"> | Date | string
    approvalDate?: DateTimeNullableFilter<"CostActa"> | Date | string | null
    paymentDueDate?: DateTimeNullableFilter<"CostActa"> | Date | string | null
    billedAmount?: FloatFilter<"CostActa"> | number
    totalContractValue?: FloatFilter<"CostActa"> | number
    status?: EnumCostActaStatusFilter<"CostActa"> | $Enums.CostActaStatus
    relatedProgress?: StringNullableFilter<"CostActa"> | string | null
    createdAt?: DateTimeFilter<"CostActa"> | Date | string
    updatedAt?: DateTimeFilter<"CostActa"> | Date | string
    observations?: ObservationListRelationFilter
    attachments?: AttachmentListRelationFilter
  }, "id" | "number">

  export type CostActaOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    period?: SortOrder
    submissionDate?: SortOrder
    approvalDate?: SortOrderInput | SortOrder
    paymentDueDate?: SortOrderInput | SortOrder
    billedAmount?: SortOrder
    totalContractValue?: SortOrder
    status?: SortOrder
    relatedProgress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CostActaCountOrderByAggregateInput
    _avg?: CostActaAvgOrderByAggregateInput
    _max?: CostActaMaxOrderByAggregateInput
    _min?: CostActaMinOrderByAggregateInput
    _sum?: CostActaSumOrderByAggregateInput
  }

  export type CostActaScalarWhereWithAggregatesInput = {
    AND?: CostActaScalarWhereWithAggregatesInput | CostActaScalarWhereWithAggregatesInput[]
    OR?: CostActaScalarWhereWithAggregatesInput[]
    NOT?: CostActaScalarWhereWithAggregatesInput | CostActaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CostActa"> | string
    number?: StringWithAggregatesFilter<"CostActa"> | string
    period?: StringWithAggregatesFilter<"CostActa"> | string
    submissionDate?: DateTimeWithAggregatesFilter<"CostActa"> | Date | string
    approvalDate?: DateTimeNullableWithAggregatesFilter<"CostActa"> | Date | string | null
    paymentDueDate?: DateTimeNullableWithAggregatesFilter<"CostActa"> | Date | string | null
    billedAmount?: FloatWithAggregatesFilter<"CostActa"> | number
    totalContractValue?: FloatWithAggregatesFilter<"CostActa"> | number
    status?: EnumCostActaStatusWithAggregatesFilter<"CostActa"> | $Enums.CostActaStatus
    relatedProgress?: StringNullableWithAggregatesFilter<"CostActa"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CostActa"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CostActa"> | Date | string
  }

  export type ObservationWhereInput = {
    AND?: ObservationWhereInput | ObservationWhereInput[]
    OR?: ObservationWhereInput[]
    NOT?: ObservationWhereInput | ObservationWhereInput[]
    id?: StringFilter<"Observation"> | string
    text?: StringFilter<"Observation"> | string
    timestamp?: DateTimeFilter<"Observation"> | Date | string
    authorId?: StringFilter<"Observation"> | string
    costActaId?: StringFilter<"Observation"> | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    costActa?: XOR<CostActaRelationFilter, CostActaWhereInput>
  }

  export type ObservationOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    timestamp?: SortOrder
    authorId?: SortOrder
    costActaId?: SortOrder
    author?: UserOrderByWithRelationInput
    costActa?: CostActaOrderByWithRelationInput
  }

  export type ObservationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ObservationWhereInput | ObservationWhereInput[]
    OR?: ObservationWhereInput[]
    NOT?: ObservationWhereInput | ObservationWhereInput[]
    text?: StringFilter<"Observation"> | string
    timestamp?: DateTimeFilter<"Observation"> | Date | string
    authorId?: StringFilter<"Observation"> | string
    costActaId?: StringFilter<"Observation"> | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    costActa?: XOR<CostActaRelationFilter, CostActaWhereInput>
  }, "id">

  export type ObservationOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    timestamp?: SortOrder
    authorId?: SortOrder
    costActaId?: SortOrder
    _count?: ObservationCountOrderByAggregateInput
    _max?: ObservationMaxOrderByAggregateInput
    _min?: ObservationMinOrderByAggregateInput
  }

  export type ObservationScalarWhereWithAggregatesInput = {
    AND?: ObservationScalarWhereWithAggregatesInput | ObservationScalarWhereWithAggregatesInput[]
    OR?: ObservationScalarWhereWithAggregatesInput[]
    NOT?: ObservationScalarWhereWithAggregatesInput | ObservationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Observation"> | string
    text?: StringWithAggregatesFilter<"Observation"> | string
    timestamp?: DateTimeWithAggregatesFilter<"Observation"> | Date | string
    authorId?: StringWithAggregatesFilter<"Observation"> | string
    costActaId?: StringWithAggregatesFilter<"Observation"> | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    type?: StringFilter<"Report"> | string
    reportScope?: EnumReportScopeFilter<"Report"> | $Enums.ReportScope
    number?: StringFilter<"Report"> | string
    period?: StringFilter<"Report"> | string
    submissionDate?: DateTimeFilter<"Report"> | Date | string
    summary?: StringFilter<"Report"> | string
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    authorId?: StringFilter<"Report"> | string
    requiredSignatoriesJson?: StringNullableFilter<"Report"> | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    attachments?: AttachmentListRelationFilter
    signatures?: SignatureListRelationFilter
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    reportScope?: SortOrder
    number?: SortOrder
    period?: SortOrder
    submissionDate?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    requiredSignatoriesJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    attachments?: AttachmentOrderByRelationAggregateInput
    signatures?: SignatureOrderByRelationAggregateInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    number?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    type?: StringFilter<"Report"> | string
    reportScope?: EnumReportScopeFilter<"Report"> | $Enums.ReportScope
    period?: StringFilter<"Report"> | string
    submissionDate?: DateTimeFilter<"Report"> | Date | string
    summary?: StringFilter<"Report"> | string
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    authorId?: StringFilter<"Report"> | string
    requiredSignatoriesJson?: StringNullableFilter<"Report"> | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    attachments?: AttachmentListRelationFilter
    signatures?: SignatureListRelationFilter
  }, "id" | "number">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    reportScope?: SortOrder
    number?: SortOrder
    period?: SortOrder
    submissionDate?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    requiredSignatoriesJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    type?: StringWithAggregatesFilter<"Report"> | string
    reportScope?: EnumReportScopeWithAggregatesFilter<"Report"> | $Enums.ReportScope
    number?: StringWithAggregatesFilter<"Report"> | string
    period?: StringWithAggregatesFilter<"Report"> | string
    submissionDate?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    summary?: StringWithAggregatesFilter<"Report"> | string
    status?: EnumReportStatusWithAggregatesFilter<"Report"> | $Enums.ReportStatus
    authorId?: StringWithAggregatesFilter<"Report"> | string
    requiredSignatoriesJson?: StringNullableWithAggregatesFilter<"Report"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
  }

  export type DrawingWhereInput = {
    AND?: DrawingWhereInput | DrawingWhereInput[]
    OR?: DrawingWhereInput[]
    NOT?: DrawingWhereInput | DrawingWhereInput[]
    id?: StringFilter<"Drawing"> | string
    code?: StringFilter<"Drawing"> | string
    title?: StringFilter<"Drawing"> | string
    discipline?: EnumDrawingDisciplineFilter<"Drawing"> | $Enums.DrawingDiscipline
    status?: EnumDrawingStatusFilter<"Drawing"> | $Enums.DrawingStatus
    createdAt?: DateTimeFilter<"Drawing"> | Date | string
    updatedAt?: DateTimeFilter<"Drawing"> | Date | string
    versions?: DrawingVersionListRelationFilter
    comments?: CommentListRelationFilter
  }

  export type DrawingOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    discipline?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    versions?: DrawingVersionOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type DrawingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: DrawingWhereInput | DrawingWhereInput[]
    OR?: DrawingWhereInput[]
    NOT?: DrawingWhereInput | DrawingWhereInput[]
    title?: StringFilter<"Drawing"> | string
    discipline?: EnumDrawingDisciplineFilter<"Drawing"> | $Enums.DrawingDiscipline
    status?: EnumDrawingStatusFilter<"Drawing"> | $Enums.DrawingStatus
    createdAt?: DateTimeFilter<"Drawing"> | Date | string
    updatedAt?: DateTimeFilter<"Drawing"> | Date | string
    versions?: DrawingVersionListRelationFilter
    comments?: CommentListRelationFilter
  }, "id" | "code">

  export type DrawingOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    discipline?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DrawingCountOrderByAggregateInput
    _max?: DrawingMaxOrderByAggregateInput
    _min?: DrawingMinOrderByAggregateInput
  }

  export type DrawingScalarWhereWithAggregatesInput = {
    AND?: DrawingScalarWhereWithAggregatesInput | DrawingScalarWhereWithAggregatesInput[]
    OR?: DrawingScalarWhereWithAggregatesInput[]
    NOT?: DrawingScalarWhereWithAggregatesInput | DrawingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Drawing"> | string
    code?: StringWithAggregatesFilter<"Drawing"> | string
    title?: StringWithAggregatesFilter<"Drawing"> | string
    discipline?: EnumDrawingDisciplineWithAggregatesFilter<"Drawing"> | $Enums.DrawingDiscipline
    status?: EnumDrawingStatusWithAggregatesFilter<"Drawing"> | $Enums.DrawingStatus
    createdAt?: DateTimeWithAggregatesFilter<"Drawing"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Drawing"> | Date | string
  }

  export type DrawingVersionWhereInput = {
    AND?: DrawingVersionWhereInput | DrawingVersionWhereInput[]
    OR?: DrawingVersionWhereInput[]
    NOT?: DrawingVersionWhereInput | DrawingVersionWhereInput[]
    id?: StringFilter<"DrawingVersion"> | string
    versionNumber?: IntFilter<"DrawingVersion"> | number
    fileName?: StringFilter<"DrawingVersion"> | string
    url?: StringFilter<"DrawingVersion"> | string
    size?: IntFilter<"DrawingVersion"> | number
    uploadDate?: DateTimeFilter<"DrawingVersion"> | Date | string
    uploaderId?: StringFilter<"DrawingVersion"> | string
    drawingId?: StringFilter<"DrawingVersion"> | string
    uploader?: XOR<UserRelationFilter, UserWhereInput>
    drawing?: XOR<DrawingRelationFilter, DrawingWhereInput>
  }

  export type DrawingVersionOrderByWithRelationInput = {
    id?: SortOrder
    versionNumber?: SortOrder
    fileName?: SortOrder
    url?: SortOrder
    size?: SortOrder
    uploadDate?: SortOrder
    uploaderId?: SortOrder
    drawingId?: SortOrder
    uploader?: UserOrderByWithRelationInput
    drawing?: DrawingOrderByWithRelationInput
  }

  export type DrawingVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DrawingVersionWhereInput | DrawingVersionWhereInput[]
    OR?: DrawingVersionWhereInput[]
    NOT?: DrawingVersionWhereInput | DrawingVersionWhereInput[]
    versionNumber?: IntFilter<"DrawingVersion"> | number
    fileName?: StringFilter<"DrawingVersion"> | string
    url?: StringFilter<"DrawingVersion"> | string
    size?: IntFilter<"DrawingVersion"> | number
    uploadDate?: DateTimeFilter<"DrawingVersion"> | Date | string
    uploaderId?: StringFilter<"DrawingVersion"> | string
    drawingId?: StringFilter<"DrawingVersion"> | string
    uploader?: XOR<UserRelationFilter, UserWhereInput>
    drawing?: XOR<DrawingRelationFilter, DrawingWhereInput>
  }, "id">

  export type DrawingVersionOrderByWithAggregationInput = {
    id?: SortOrder
    versionNumber?: SortOrder
    fileName?: SortOrder
    url?: SortOrder
    size?: SortOrder
    uploadDate?: SortOrder
    uploaderId?: SortOrder
    drawingId?: SortOrder
    _count?: DrawingVersionCountOrderByAggregateInput
    _avg?: DrawingVersionAvgOrderByAggregateInput
    _max?: DrawingVersionMaxOrderByAggregateInput
    _min?: DrawingVersionMinOrderByAggregateInput
    _sum?: DrawingVersionSumOrderByAggregateInput
  }

  export type DrawingVersionScalarWhereWithAggregatesInput = {
    AND?: DrawingVersionScalarWhereWithAggregatesInput | DrawingVersionScalarWhereWithAggregatesInput[]
    OR?: DrawingVersionScalarWhereWithAggregatesInput[]
    NOT?: DrawingVersionScalarWhereWithAggregatesInput | DrawingVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DrawingVersion"> | string
    versionNumber?: IntWithAggregatesFilter<"DrawingVersion"> | number
    fileName?: StringWithAggregatesFilter<"DrawingVersion"> | string
    url?: StringWithAggregatesFilter<"DrawingVersion"> | string
    size?: IntWithAggregatesFilter<"DrawingVersion"> | number
    uploadDate?: DateTimeWithAggregatesFilter<"DrawingVersion"> | Date | string
    uploaderId?: StringWithAggregatesFilter<"DrawingVersion"> | string
    drawingId?: StringWithAggregatesFilter<"DrawingVersion"> | string
  }

  export type PhotoEntryWhereInput = {
    AND?: PhotoEntryWhereInput | PhotoEntryWhereInput[]
    OR?: PhotoEntryWhereInput[]
    NOT?: PhotoEntryWhereInput | PhotoEntryWhereInput[]
    id?: StringFilter<"PhotoEntry"> | string
    url?: StringFilter<"PhotoEntry"> | string
    date?: DateTimeFilter<"PhotoEntry"> | Date | string
    notes?: StringNullableFilter<"PhotoEntry"> | string | null
    authorId?: StringFilter<"PhotoEntry"> | string
    controlPointId?: StringFilter<"PhotoEntry"> | string
    attachmentId?: StringNullableFilter<"PhotoEntry"> | string | null
    author?: XOR<UserRelationFilter, UserWhereInput>
    controlPoint?: XOR<ControlPointRelationFilter, ControlPointWhereInput>
    attachment?: XOR<AttachmentNullableRelationFilter, AttachmentWhereInput> | null
  }

  export type PhotoEntryOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    date?: SortOrder
    notes?: SortOrderInput | SortOrder
    authorId?: SortOrder
    controlPointId?: SortOrder
    attachmentId?: SortOrderInput | SortOrder
    author?: UserOrderByWithRelationInput
    controlPoint?: ControlPointOrderByWithRelationInput
    attachment?: AttachmentOrderByWithRelationInput
  }

  export type PhotoEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    attachmentId?: string
    AND?: PhotoEntryWhereInput | PhotoEntryWhereInput[]
    OR?: PhotoEntryWhereInput[]
    NOT?: PhotoEntryWhereInput | PhotoEntryWhereInput[]
    url?: StringFilter<"PhotoEntry"> | string
    date?: DateTimeFilter<"PhotoEntry"> | Date | string
    notes?: StringNullableFilter<"PhotoEntry"> | string | null
    authorId?: StringFilter<"PhotoEntry"> | string
    controlPointId?: StringFilter<"PhotoEntry"> | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    controlPoint?: XOR<ControlPointRelationFilter, ControlPointWhereInput>
    attachment?: XOR<AttachmentNullableRelationFilter, AttachmentWhereInput> | null
  }, "id" | "attachmentId">

  export type PhotoEntryOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    date?: SortOrder
    notes?: SortOrderInput | SortOrder
    authorId?: SortOrder
    controlPointId?: SortOrder
    attachmentId?: SortOrderInput | SortOrder
    _count?: PhotoEntryCountOrderByAggregateInput
    _max?: PhotoEntryMaxOrderByAggregateInput
    _min?: PhotoEntryMinOrderByAggregateInput
  }

  export type PhotoEntryScalarWhereWithAggregatesInput = {
    AND?: PhotoEntryScalarWhereWithAggregatesInput | PhotoEntryScalarWhereWithAggregatesInput[]
    OR?: PhotoEntryScalarWhereWithAggregatesInput[]
    NOT?: PhotoEntryScalarWhereWithAggregatesInput | PhotoEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PhotoEntry"> | string
    url?: StringWithAggregatesFilter<"PhotoEntry"> | string
    date?: DateTimeWithAggregatesFilter<"PhotoEntry"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"PhotoEntry"> | string | null
    authorId?: StringWithAggregatesFilter<"PhotoEntry"> | string
    controlPointId?: StringWithAggregatesFilter<"PhotoEntry"> | string
    attachmentId?: StringNullableWithAggregatesFilter<"PhotoEntry"> | string | null
  }

  export type ControlPointWhereInput = {
    AND?: ControlPointWhereInput | ControlPointWhereInput[]
    OR?: ControlPointWhereInput[]
    NOT?: ControlPointWhereInput | ControlPointWhereInput[]
    id?: StringFilter<"ControlPoint"> | string
    name?: StringFilter<"ControlPoint"> | string
    description?: StringNullableFilter<"ControlPoint"> | string | null
    location?: StringNullableFilter<"ControlPoint"> | string | null
    createdAt?: DateTimeFilter<"ControlPoint"> | Date | string
    updatedAt?: DateTimeFilter<"ControlPoint"> | Date | string
    photos?: PhotoEntryListRelationFilter
  }

  export type ControlPointOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    photos?: PhotoEntryOrderByRelationAggregateInput
  }

  export type ControlPointWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ControlPointWhereInput | ControlPointWhereInput[]
    OR?: ControlPointWhereInput[]
    NOT?: ControlPointWhereInput | ControlPointWhereInput[]
    name?: StringFilter<"ControlPoint"> | string
    description?: StringNullableFilter<"ControlPoint"> | string | null
    location?: StringNullableFilter<"ControlPoint"> | string | null
    createdAt?: DateTimeFilter<"ControlPoint"> | Date | string
    updatedAt?: DateTimeFilter<"ControlPoint"> | Date | string
    photos?: PhotoEntryListRelationFilter
  }, "id">

  export type ControlPointOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ControlPointCountOrderByAggregateInput
    _max?: ControlPointMaxOrderByAggregateInput
    _min?: ControlPointMinOrderByAggregateInput
  }

  export type ControlPointScalarWhereWithAggregatesInput = {
    AND?: ControlPointScalarWhereWithAggregatesInput | ControlPointScalarWhereWithAggregatesInput[]
    OR?: ControlPointScalarWhereWithAggregatesInput[]
    NOT?: ControlPointScalarWhereWithAggregatesInput | ControlPointScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ControlPoint"> | string
    name?: StringWithAggregatesFilter<"ControlPoint"> | string
    description?: StringNullableWithAggregatesFilter<"ControlPoint"> | string | null
    location?: StringNullableWithAggregatesFilter<"ControlPoint"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ControlPoint"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ControlPoint"> | Date | string
  }

  export type ProjectTaskWhereInput = {
    AND?: ProjectTaskWhereInput | ProjectTaskWhereInput[]
    OR?: ProjectTaskWhereInput[]
    NOT?: ProjectTaskWhereInput | ProjectTaskWhereInput[]
    id?: StringFilter<"ProjectTask"> | string
    name?: StringFilter<"ProjectTask"> | string
    startDate?: DateTimeFilter<"ProjectTask"> | Date | string
    endDate?: DateTimeFilter<"ProjectTask"> | Date | string
    progress?: IntFilter<"ProjectTask"> | number
    duration?: IntFilter<"ProjectTask"> | number
    isSummary?: BoolFilter<"ProjectTask"> | boolean
    outlineLevel?: IntFilter<"ProjectTask"> | number
    dependencies?: StringNullableFilter<"ProjectTask"> | string | null
    createdAt?: DateTimeFilter<"ProjectTask"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectTask"> | Date | string
  }

  export type ProjectTaskOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    progress?: SortOrder
    duration?: SortOrder
    isSummary?: SortOrder
    outlineLevel?: SortOrder
    dependencies?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectTaskWhereInput | ProjectTaskWhereInput[]
    OR?: ProjectTaskWhereInput[]
    NOT?: ProjectTaskWhereInput | ProjectTaskWhereInput[]
    name?: StringFilter<"ProjectTask"> | string
    startDate?: DateTimeFilter<"ProjectTask"> | Date | string
    endDate?: DateTimeFilter<"ProjectTask"> | Date | string
    progress?: IntFilter<"ProjectTask"> | number
    duration?: IntFilter<"ProjectTask"> | number
    isSummary?: BoolFilter<"ProjectTask"> | boolean
    outlineLevel?: IntFilter<"ProjectTask"> | number
    dependencies?: StringNullableFilter<"ProjectTask"> | string | null
    createdAt?: DateTimeFilter<"ProjectTask"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectTask"> | Date | string
  }, "id">

  export type ProjectTaskOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    progress?: SortOrder
    duration?: SortOrder
    isSummary?: SortOrder
    outlineLevel?: SortOrder
    dependencies?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectTaskCountOrderByAggregateInput
    _avg?: ProjectTaskAvgOrderByAggregateInput
    _max?: ProjectTaskMaxOrderByAggregateInput
    _min?: ProjectTaskMinOrderByAggregateInput
    _sum?: ProjectTaskSumOrderByAggregateInput
  }

  export type ProjectTaskScalarWhereWithAggregatesInput = {
    AND?: ProjectTaskScalarWhereWithAggregatesInput | ProjectTaskScalarWhereWithAggregatesInput[]
    OR?: ProjectTaskScalarWhereWithAggregatesInput[]
    NOT?: ProjectTaskScalarWhereWithAggregatesInput | ProjectTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectTask"> | string
    name?: StringWithAggregatesFilter<"ProjectTask"> | string
    startDate?: DateTimeWithAggregatesFilter<"ProjectTask"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"ProjectTask"> | Date | string
    progress?: IntWithAggregatesFilter<"ProjectTask"> | number
    duration?: IntWithAggregatesFilter<"ProjectTask"> | number
    isSummary?: BoolWithAggregatesFilter<"ProjectTask"> | boolean
    outlineLevel?: IntWithAggregatesFilter<"ProjectTask"> | number
    dependencies?: StringNullableWithAggregatesFilter<"ProjectTask"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProjectTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectTask"> | Date | string
  }

  export type ContractItemWhereInput = {
    AND?: ContractItemWhereInput | ContractItemWhereInput[]
    OR?: ContractItemWhereInput[]
    NOT?: ContractItemWhereInput | ContractItemWhereInput[]
    id?: StringFilter<"ContractItem"> | string
    itemCode?: StringFilter<"ContractItem"> | string
    description?: StringFilter<"ContractItem"> | string
    unit?: StringFilter<"ContractItem"> | string
    unitPrice?: FloatFilter<"ContractItem"> | number
    contractQuantity?: FloatFilter<"ContractItem"> | number
    createdAt?: DateTimeFilter<"ContractItem"> | Date | string
    updatedAt?: DateTimeFilter<"ContractItem"> | Date | string
    workActaItems?: WorkActaItemListRelationFilter
  }

  export type ContractItemOrderByWithRelationInput = {
    id?: SortOrder
    itemCode?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    contractQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workActaItems?: WorkActaItemOrderByRelationAggregateInput
  }

  export type ContractItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    itemCode?: string
    AND?: ContractItemWhereInput | ContractItemWhereInput[]
    OR?: ContractItemWhereInput[]
    NOT?: ContractItemWhereInput | ContractItemWhereInput[]
    description?: StringFilter<"ContractItem"> | string
    unit?: StringFilter<"ContractItem"> | string
    unitPrice?: FloatFilter<"ContractItem"> | number
    contractQuantity?: FloatFilter<"ContractItem"> | number
    createdAt?: DateTimeFilter<"ContractItem"> | Date | string
    updatedAt?: DateTimeFilter<"ContractItem"> | Date | string
    workActaItems?: WorkActaItemListRelationFilter
  }, "id" | "itemCode">

  export type ContractItemOrderByWithAggregationInput = {
    id?: SortOrder
    itemCode?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    contractQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContractItemCountOrderByAggregateInput
    _avg?: ContractItemAvgOrderByAggregateInput
    _max?: ContractItemMaxOrderByAggregateInput
    _min?: ContractItemMinOrderByAggregateInput
    _sum?: ContractItemSumOrderByAggregateInput
  }

  export type ContractItemScalarWhereWithAggregatesInput = {
    AND?: ContractItemScalarWhereWithAggregatesInput | ContractItemScalarWhereWithAggregatesInput[]
    OR?: ContractItemScalarWhereWithAggregatesInput[]
    NOT?: ContractItemScalarWhereWithAggregatesInput | ContractItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContractItem"> | string
    itemCode?: StringWithAggregatesFilter<"ContractItem"> | string
    description?: StringWithAggregatesFilter<"ContractItem"> | string
    unit?: StringWithAggregatesFilter<"ContractItem"> | string
    unitPrice?: FloatWithAggregatesFilter<"ContractItem"> | number
    contractQuantity?: FloatWithAggregatesFilter<"ContractItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ContractItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContractItem"> | Date | string
  }

  export type WorkActaWhereInput = {
    AND?: WorkActaWhereInput | WorkActaWhereInput[]
    OR?: WorkActaWhereInput[]
    NOT?: WorkActaWhereInput | WorkActaWhereInput[]
    id?: StringFilter<"WorkActa"> | string
    number?: StringFilter<"WorkActa"> | string
    period?: StringFilter<"WorkActa"> | string
    date?: DateTimeFilter<"WorkActa"> | Date | string
    status?: EnumWorkActaStatusFilter<"WorkActa"> | $Enums.WorkActaStatus
    createdAt?: DateTimeFilter<"WorkActa"> | Date | string
    updatedAt?: DateTimeFilter<"WorkActa"> | Date | string
    items?: WorkActaItemListRelationFilter
    attachments?: AttachmentListRelationFilter
  }

  export type WorkActaOrderByWithRelationInput = {
    id?: SortOrder
    number?: SortOrder
    period?: SortOrder
    date?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: WorkActaItemOrderByRelationAggregateInput
    attachments?: AttachmentOrderByRelationAggregateInput
  }

  export type WorkActaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    number?: string
    AND?: WorkActaWhereInput | WorkActaWhereInput[]
    OR?: WorkActaWhereInput[]
    NOT?: WorkActaWhereInput | WorkActaWhereInput[]
    period?: StringFilter<"WorkActa"> | string
    date?: DateTimeFilter<"WorkActa"> | Date | string
    status?: EnumWorkActaStatusFilter<"WorkActa"> | $Enums.WorkActaStatus
    createdAt?: DateTimeFilter<"WorkActa"> | Date | string
    updatedAt?: DateTimeFilter<"WorkActa"> | Date | string
    items?: WorkActaItemListRelationFilter
    attachments?: AttachmentListRelationFilter
  }, "id" | "number">

  export type WorkActaOrderByWithAggregationInput = {
    id?: SortOrder
    number?: SortOrder
    period?: SortOrder
    date?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkActaCountOrderByAggregateInput
    _max?: WorkActaMaxOrderByAggregateInput
    _min?: WorkActaMinOrderByAggregateInput
  }

  export type WorkActaScalarWhereWithAggregatesInput = {
    AND?: WorkActaScalarWhereWithAggregatesInput | WorkActaScalarWhereWithAggregatesInput[]
    OR?: WorkActaScalarWhereWithAggregatesInput[]
    NOT?: WorkActaScalarWhereWithAggregatesInput | WorkActaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkActa"> | string
    number?: StringWithAggregatesFilter<"WorkActa"> | string
    period?: StringWithAggregatesFilter<"WorkActa"> | string
    date?: DateTimeWithAggregatesFilter<"WorkActa"> | Date | string
    status?: EnumWorkActaStatusWithAggregatesFilter<"WorkActa"> | $Enums.WorkActaStatus
    createdAt?: DateTimeWithAggregatesFilter<"WorkActa"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkActa"> | Date | string
  }

  export type WorkActaItemWhereInput = {
    AND?: WorkActaItemWhereInput | WorkActaItemWhereInput[]
    OR?: WorkActaItemWhereInput[]
    NOT?: WorkActaItemWhereInput | WorkActaItemWhereInput[]
    id?: StringFilter<"WorkActaItem"> | string
    quantity?: FloatFilter<"WorkActaItem"> | number
    workActaId?: StringFilter<"WorkActaItem"> | string
    contractItemId?: StringFilter<"WorkActaItem"> | string
    createdAt?: DateTimeFilter<"WorkActaItem"> | Date | string
    updatedAt?: DateTimeFilter<"WorkActaItem"> | Date | string
    workActa?: XOR<WorkActaRelationFilter, WorkActaWhereInput>
    contractItem?: XOR<ContractItemRelationFilter, ContractItemWhereInput>
  }

  export type WorkActaItemOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrder
    workActaId?: SortOrder
    contractItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workActa?: WorkActaOrderByWithRelationInput
    contractItem?: ContractItemOrderByWithRelationInput
  }

  export type WorkActaItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkActaItemWhereInput | WorkActaItemWhereInput[]
    OR?: WorkActaItemWhereInput[]
    NOT?: WorkActaItemWhereInput | WorkActaItemWhereInput[]
    quantity?: FloatFilter<"WorkActaItem"> | number
    workActaId?: StringFilter<"WorkActaItem"> | string
    contractItemId?: StringFilter<"WorkActaItem"> | string
    createdAt?: DateTimeFilter<"WorkActaItem"> | Date | string
    updatedAt?: DateTimeFilter<"WorkActaItem"> | Date | string
    workActa?: XOR<WorkActaRelationFilter, WorkActaWhereInput>
    contractItem?: XOR<ContractItemRelationFilter, ContractItemWhereInput>
  }, "id">

  export type WorkActaItemOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrder
    workActaId?: SortOrder
    contractItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkActaItemCountOrderByAggregateInput
    _avg?: WorkActaItemAvgOrderByAggregateInput
    _max?: WorkActaItemMaxOrderByAggregateInput
    _min?: WorkActaItemMinOrderByAggregateInput
    _sum?: WorkActaItemSumOrderByAggregateInput
  }

  export type WorkActaItemScalarWhereWithAggregatesInput = {
    AND?: WorkActaItemScalarWhereWithAggregatesInput | WorkActaItemScalarWhereWithAggregatesInput[]
    OR?: WorkActaItemScalarWhereWithAggregatesInput[]
    NOT?: WorkActaItemScalarWhereWithAggregatesInput | WorkActaItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkActaItem"> | string
    quantity?: FloatWithAggregatesFilter<"WorkActaItem"> | number
    workActaId?: StringWithAggregatesFilter<"WorkActaItem"> | string
    contractItemId?: StringWithAggregatesFilter<"WorkActaItem"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WorkActaItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkActaItem"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryCreateNestedManyWithoutAuthorInput
    assignedTo?: LogEntryCreateNestedManyWithoutAssigneesInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    signatures?: SignatureCreateNestedManyWithoutSignerInput
    communications?: CommunicationCreateNestedManyWithoutUploaderInput
    statusChanges?: CommunicationStatusHistoryCreateNestedManyWithoutUserInput
    photoEntries?: PhotoEntryCreateNestedManyWithoutAuthorInput
    responsibleFor?: CommitmentCreateNestedManyWithoutResponsibleInput
    observations?: ObservationCreateNestedManyWithoutAuthorInput
    reports?: ReportCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionCreateNestedManyWithoutUploaderInput
    logEntryHistory?: LogEntryHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryUncheckedCreateNestedManyWithoutAuthorInput
    assignedTo?: LogEntryUncheckedCreateNestedManyWithoutAssigneesInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutSignerInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUploaderInput
    statusChanges?: CommunicationStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    photoEntries?: PhotoEntryUncheckedCreateNestedManyWithoutAuthorInput
    responsibleFor?: CommitmentUncheckedCreateNestedManyWithoutResponsibleInput
    observations?: ObservationUncheckedCreateNestedManyWithoutAuthorInput
    reports?: ReportUncheckedCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionUncheckedCreateNestedManyWithoutUploaderInput
    logEntryHistory?: LogEntryHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUpdateManyWithoutAuthorNestedInput
    assignedTo?: LogEntryUpdateManyWithoutAssigneesNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    signatures?: SignatureUpdateManyWithoutSignerNestedInput
    communications?: CommunicationUpdateManyWithoutUploaderNestedInput
    statusChanges?: CommunicationStatusHistoryUpdateManyWithoutUserNestedInput
    photoEntries?: PhotoEntryUpdateManyWithoutAuthorNestedInput
    responsibleFor?: CommitmentUpdateManyWithoutResponsibleNestedInput
    observations?: ObservationUpdateManyWithoutAuthorNestedInput
    reports?: ReportUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUpdateManyWithoutUploaderNestedInput
    logEntryHistory?: LogEntryHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTo?: LogEntryUncheckedUpdateManyWithoutAssigneesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutSignerNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUploaderNestedInput
    statusChanges?: CommunicationStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    photoEntries?: PhotoEntryUncheckedUpdateManyWithoutAuthorNestedInput
    responsibleFor?: CommitmentUncheckedUpdateManyWithoutResponsibleNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutAuthorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUncheckedUpdateManyWithoutUploaderNestedInput
    logEntryHistory?: LogEntryHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    contractId: string
    object: string
    contractorName: string
    supervisorName: string
    initialValue: number
    startDate: Date | string
    initialEndDate: Date | string
    interventoriaContractId: string
    interventoriaInitialValue: number
    technicalSupervisorName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    keyPersonnel?: KeyPersonnelCreateNestedManyWithoutProjectInput
    logEntries?: LogEntryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    contractId: string
    object: string
    contractorName: string
    supervisorName: string
    initialValue: number
    startDate: Date | string
    initialEndDate: Date | string
    interventoriaContractId: string
    interventoriaInitialValue: number
    technicalSupervisorName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    keyPersonnel?: KeyPersonnelUncheckedCreateNestedManyWithoutProjectInput
    logEntries?: LogEntryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    object?: StringFieldUpdateOperationsInput | string
    contractorName?: StringFieldUpdateOperationsInput | string
    supervisorName?: StringFieldUpdateOperationsInput | string
    initialValue?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interventoriaContractId?: StringFieldUpdateOperationsInput | string
    interventoriaInitialValue?: FloatFieldUpdateOperationsInput | number
    technicalSupervisorName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keyPersonnel?: KeyPersonnelUpdateManyWithoutProjectNestedInput
    logEntries?: LogEntryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    object?: StringFieldUpdateOperationsInput | string
    contractorName?: StringFieldUpdateOperationsInput | string
    supervisorName?: StringFieldUpdateOperationsInput | string
    initialValue?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interventoriaContractId?: StringFieldUpdateOperationsInput | string
    interventoriaInitialValue?: FloatFieldUpdateOperationsInput | number
    technicalSupervisorName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keyPersonnel?: KeyPersonnelUncheckedUpdateManyWithoutProjectNestedInput
    logEntries?: LogEntryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    contractId: string
    object: string
    contractorName: string
    supervisorName: string
    initialValue: number
    startDate: Date | string
    initialEndDate: Date | string
    interventoriaContractId: string
    interventoriaInitialValue: number
    technicalSupervisorName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    object?: StringFieldUpdateOperationsInput | string
    contractorName?: StringFieldUpdateOperationsInput | string
    supervisorName?: StringFieldUpdateOperationsInput | string
    initialValue?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interventoriaContractId?: StringFieldUpdateOperationsInput | string
    interventoriaInitialValue?: FloatFieldUpdateOperationsInput | number
    technicalSupervisorName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    object?: StringFieldUpdateOperationsInput | string
    contractorName?: StringFieldUpdateOperationsInput | string
    supervisorName?: StringFieldUpdateOperationsInput | string
    initialValue?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interventoriaContractId?: StringFieldUpdateOperationsInput | string
    interventoriaInitialValue?: FloatFieldUpdateOperationsInput | number
    technicalSupervisorName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeyPersonnelCreateInput = {
    id?: string
    name: string
    role: string
    company: string
    email: string
    phone: string
    project: ProjectCreateNestedOneWithoutKeyPersonnelInput
  }

  export type KeyPersonnelUncheckedCreateInput = {
    id?: string
    name: string
    role: string
    company: string
    email: string
    phone: string
    projectId: string
  }

  export type KeyPersonnelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    project?: ProjectUpdateOneRequiredWithoutKeyPersonnelNestedInput
  }

  export type KeyPersonnelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type KeyPersonnelCreateManyInput = {
    id?: string
    name: string
    role: string
    company: string
    email: string
    phone: string
    projectId: string
  }

  export type KeyPersonnelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type KeyPersonnelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type CommunicationCreateInput = {
    id?: string
    radicado: string
    subject: string
    description: string
    senderEntity: string
    senderName: string
    senderTitle: string
    recipientEntity: string
    recipientName: string
    recipientTitle: string
    signerName: string
    sentDate: Date | string
    dueDate?: Date | string | null
    deliveryMethod: $Enums.DeliveryMethod
    notes?: string | null
    status: $Enums.CommunicationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    uploader: UserCreateNestedOneWithoutCommunicationsInput
    parent?: CommunicationCreateNestedOneWithoutRepliesInput
    replies?: CommunicationCreateNestedManyWithoutParentInput
    statusHistory?: CommunicationStatusHistoryCreateNestedManyWithoutCommunicationInput
    attachments?: AttachmentCreateNestedManyWithoutCommunicationInput
  }

  export type CommunicationUncheckedCreateInput = {
    id?: string
    radicado: string
    subject: string
    description: string
    senderEntity: string
    senderName: string
    senderTitle: string
    recipientEntity: string
    recipientName: string
    recipientTitle: string
    signerName: string
    sentDate: Date | string
    dueDate?: Date | string | null
    deliveryMethod: $Enums.DeliveryMethod
    notes?: string | null
    status: $Enums.CommunicationStatus
    uploaderId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommunicationUncheckedCreateNestedManyWithoutParentInput
    statusHistory?: CommunicationStatusHistoryUncheckedCreateNestedManyWithoutCommunicationInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutCommunicationInput
  }

  export type CommunicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    radicado?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    senderEntity?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderTitle?: StringFieldUpdateOperationsInput | string
    recipientEntity?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientTitle?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommunicationStatusFieldUpdateOperationsInput | $Enums.CommunicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneRequiredWithoutCommunicationsNestedInput
    parent?: CommunicationUpdateOneWithoutRepliesNestedInput
    replies?: CommunicationUpdateManyWithoutParentNestedInput
    statusHistory?: CommunicationStatusHistoryUpdateManyWithoutCommunicationNestedInput
    attachments?: AttachmentUpdateManyWithoutCommunicationNestedInput
  }

  export type CommunicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    radicado?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    senderEntity?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderTitle?: StringFieldUpdateOperationsInput | string
    recipientEntity?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientTitle?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommunicationStatusFieldUpdateOperationsInput | $Enums.CommunicationStatus
    uploaderId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommunicationUncheckedUpdateManyWithoutParentNestedInput
    statusHistory?: CommunicationStatusHistoryUncheckedUpdateManyWithoutCommunicationNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutCommunicationNestedInput
  }

  export type CommunicationCreateManyInput = {
    id?: string
    radicado: string
    subject: string
    description: string
    senderEntity: string
    senderName: string
    senderTitle: string
    recipientEntity: string
    recipientName: string
    recipientTitle: string
    signerName: string
    sentDate: Date | string
    dueDate?: Date | string | null
    deliveryMethod: $Enums.DeliveryMethod
    notes?: string | null
    status: $Enums.CommunicationStatus
    uploaderId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    radicado?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    senderEntity?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderTitle?: StringFieldUpdateOperationsInput | string
    recipientEntity?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientTitle?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommunicationStatusFieldUpdateOperationsInput | $Enums.CommunicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    radicado?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    senderEntity?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderTitle?: StringFieldUpdateOperationsInput | string
    recipientEntity?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientTitle?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommunicationStatusFieldUpdateOperationsInput | $Enums.CommunicationStatus
    uploaderId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationStatusHistoryCreateInput = {
    id?: string
    status: string
    timestamp?: Date | string
    communication: CommunicationCreateNestedOneWithoutStatusHistoryInput
    user: UserCreateNestedOneWithoutStatusChangesInput
  }

  export type CommunicationStatusHistoryUncheckedCreateInput = {
    id?: string
    status: string
    timestamp?: Date | string
    communicationId: string
    userId: string
  }

  export type CommunicationStatusHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    communication?: CommunicationUpdateOneRequiredWithoutStatusHistoryNestedInput
    user?: UserUpdateOneRequiredWithoutStatusChangesNestedInput
  }

  export type CommunicationStatusHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    communicationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CommunicationStatusHistoryCreateManyInput = {
    id?: string
    status: string
    timestamp?: Date | string
    communicationId: string
    userId: string
  }

  export type CommunicationStatusHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationStatusHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    communicationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ContractModificationCreateInput = {
    id?: string
    number: string
    type: $Enums.ModificationType
    date: Date | string
    value?: number | null
    days?: number | null
    justification: string
    createdAt?: Date | string
    updatedAt?: Date | string
    attachment?: AttachmentCreateNestedOneWithoutContractModInput
  }

  export type ContractModificationUncheckedCreateInput = {
    id?: string
    number: string
    type: $Enums.ModificationType
    date: Date | string
    value?: number | null
    days?: number | null
    justification: string
    attachmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractModificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumModificationTypeFieldUpdateOperationsInput | $Enums.ModificationType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    justification?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachment?: AttachmentUpdateOneWithoutContractModNestedInput
  }

  export type ContractModificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumModificationTypeFieldUpdateOperationsInput | $Enums.ModificationType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    justification?: StringFieldUpdateOperationsInput | string
    attachmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractModificationCreateManyInput = {
    id?: string
    number: string
    type: $Enums.ModificationType
    date: Date | string
    value?: number | null
    days?: number | null
    justification: string
    attachmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractModificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumModificationTypeFieldUpdateOperationsInput | $Enums.ModificationType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    justification?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractModificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumModificationTypeFieldUpdateOperationsInput | $Enums.ModificationType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    justification?: StringFieldUpdateOperationsInput | string
    attachmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyReportCreateInput = {
    id?: string
    number: string
    startDate: Date | string
    endDate: Date | string
    summary: string
    progressSummary?: string | null
    nextWeekPlan?: string | null
    issues?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentCreateNestedManyWithoutWeeklyReportInput
  }

  export type WeeklyReportUncheckedCreateInput = {
    id?: string
    number: string
    startDate: Date | string
    endDate: Date | string
    summary: string
    progressSummary?: string | null
    nextWeekPlan?: string | null
    issues?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutWeeklyReportInput
  }

  export type WeeklyReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    progressSummary?: NullableStringFieldUpdateOperationsInput | string | null
    nextWeekPlan?: NullableStringFieldUpdateOperationsInput | string | null
    issues?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUpdateManyWithoutWeeklyReportNestedInput
  }

  export type WeeklyReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    progressSummary?: NullableStringFieldUpdateOperationsInput | string | null
    nextWeekPlan?: NullableStringFieldUpdateOperationsInput | string | null
    issues?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutWeeklyReportNestedInput
  }

  export type WeeklyReportCreateManyInput = {
    id?: string
    number: string
    startDate: Date | string
    endDate: Date | string
    summary: string
    progressSummary?: string | null
    nextWeekPlan?: string | null
    issues?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeeklyReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    progressSummary?: NullableStringFieldUpdateOperationsInput | string | null
    nextWeekPlan?: NullableStringFieldUpdateOperationsInput | string | null
    issues?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    progressSummary?: NullableStringFieldUpdateOperationsInput | string | null
    nextWeekPlan?: NullableStringFieldUpdateOperationsInput | string | null
    issues?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogEntryCreateInput = {
    id?: string
    folioNumber?: number
    title: string
    description: string
    type: $Enums.EntryType
    subject: string
    location: string
    activityStartDate: Date | string
    activityEndDate: Date | string
    isConfidential?: boolean
    status: $Enums.EntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutLogEntriesInput
    project: ProjectCreateNestedOneWithoutLogEntriesInput
    assignees?: UserCreateNestedManyWithoutAssignedToInput
    comments?: CommentCreateNestedManyWithoutLogEntryInput
    attachments?: AttachmentCreateNestedManyWithoutLogEntryInput
    signatures?: SignatureCreateNestedManyWithoutLogEntryInput
    history?: LogEntryHistoryCreateNestedManyWithoutLogEntryInput
  }

  export type LogEntryUncheckedCreateInput = {
    id?: string
    folioNumber?: number
    title: string
    description: string
    type: $Enums.EntryType
    subject: string
    location: string
    activityStartDate: Date | string
    activityEndDate: Date | string
    isConfidential?: boolean
    status: $Enums.EntryStatus
    authorId: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignees?: UserUncheckedCreateNestedManyWithoutAssignedToInput
    comments?: CommentUncheckedCreateNestedManyWithoutLogEntryInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutLogEntryInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutLogEntryInput
    history?: LogEntryHistoryUncheckedCreateNestedManyWithoutLogEntryInput
  }

  export type LogEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumEntryTypeFieldUpdateOperationsInput | $Enums.EntryType
    subject?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    activityEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutLogEntriesNestedInput
    project?: ProjectUpdateOneRequiredWithoutLogEntriesNestedInput
    assignees?: UserUpdateManyWithoutAssignedToNestedInput
    comments?: CommentUpdateManyWithoutLogEntryNestedInput
    attachments?: AttachmentUpdateManyWithoutLogEntryNestedInput
    signatures?: SignatureUpdateManyWithoutLogEntryNestedInput
    history?: LogEntryHistoryUpdateManyWithoutLogEntryNestedInput
  }

  export type LogEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    folioNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumEntryTypeFieldUpdateOperationsInput | $Enums.EntryType
    subject?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    activityEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignees?: UserUncheckedUpdateManyWithoutAssignedToNestedInput
    comments?: CommentUncheckedUpdateManyWithoutLogEntryNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutLogEntryNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutLogEntryNestedInput
    history?: LogEntryHistoryUncheckedUpdateManyWithoutLogEntryNestedInput
  }

  export type LogEntryCreateManyInput = {
    id?: string
    folioNumber?: number
    title: string
    description: string
    type: $Enums.EntryType
    subject: string
    location: string
    activityStartDate: Date | string
    activityEndDate: Date | string
    isConfidential?: boolean
    status: $Enums.EntryStatus
    authorId: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LogEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumEntryTypeFieldUpdateOperationsInput | $Enums.EntryType
    subject?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    activityEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    folioNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumEntryTypeFieldUpdateOperationsInput | $Enums.EntryType
    subject?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    activityEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogEntryHistoryCreateInput = {
    id?: string
    fieldName: string
    oldValue?: string | null
    newValue?: string | null
    timestamp?: Date | string
    logEntry: LogEntryCreateNestedOneWithoutHistoryInput
    user?: UserCreateNestedOneWithoutLogEntryHistoryInput
  }

  export type LogEntryHistoryUncheckedCreateInput = {
    id?: string
    fieldName: string
    oldValue?: string | null
    newValue?: string | null
    timestamp?: Date | string
    logEntryId: string
    userId?: string | null
  }

  export type LogEntryHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntry?: LogEntryUpdateOneRequiredWithoutHistoryNestedInput
    user?: UserUpdateOneWithoutLogEntryHistoryNestedInput
  }

  export type LogEntryHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntryId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogEntryHistoryCreateManyInput = {
    id?: string
    fieldName: string
    oldValue?: string | null
    newValue?: string | null
    timestamp?: Date | string
    logEntryId: string
    userId?: string | null
  }

  export type LogEntryHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogEntryHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntryId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    timestamp?: Date | string
    author: UserCreateNestedOneWithoutCommentsInput
    logEntry?: LogEntryCreateNestedOneWithoutCommentsInput
    drawing?: DrawingCreateNestedOneWithoutCommentsInput
    attachments?: AttachmentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    content: string
    timestamp?: Date | string
    authorId: string
    logEntryId?: string | null
    drawingId?: string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    logEntry?: LogEntryUpdateOneWithoutCommentsNestedInput
    drawing?: DrawingUpdateOneWithoutCommentsNestedInput
    attachments?: AttachmentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    drawingId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    content: string
    timestamp?: Date | string
    authorId: string
    logEntryId?: string | null
    drawingId?: string | null
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    drawingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SignatureCreateInput = {
    id?: string
    signedAt?: Date | string
    signer: UserCreateNestedOneWithoutSignaturesInput
    logEntry?: LogEntryCreateNestedOneWithoutSignaturesInput
    acta?: ActaCreateNestedOneWithoutSignaturesInput
    report?: ReportCreateNestedOneWithoutSignaturesInput
  }

  export type SignatureUncheckedCreateInput = {
    id?: string
    signedAt?: Date | string
    signerId: string
    logEntryId?: string | null
    actaId?: string | null
    reportId?: string | null
  }

  export type SignatureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signer?: UserUpdateOneRequiredWithoutSignaturesNestedInput
    logEntry?: LogEntryUpdateOneWithoutSignaturesNestedInput
    acta?: ActaUpdateOneWithoutSignaturesNestedInput
    report?: ReportUpdateOneWithoutSignaturesNestedInput
  }

  export type SignatureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signerId?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SignatureCreateManyInput = {
    id?: string
    signedAt?: Date | string
    signerId: string
    logEntryId?: string | null
    actaId?: string | null
    reportId?: string | null
  }

  export type SignatureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignatureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signerId?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttachmentCreateInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    createdAt?: Date | string
    logEntry?: LogEntryCreateNestedOneWithoutAttachmentsInput
    communication?: CommunicationCreateNestedOneWithoutAttachmentsInput
    acta?: ActaCreateNestedOneWithoutAttachmentsInput
    costActa?: CostActaCreateNestedOneWithoutAttachmentsInput
    report?: ReportCreateNestedOneWithoutAttachmentsInput
    comment?: CommentCreateNestedOneWithoutAttachmentsInput
    contractMod?: ContractModificationCreateNestedOneWithoutAttachmentInput
    workActa?: WorkActaCreateNestedOneWithoutAttachmentsInput
    weeklyReport?: WeeklyReportCreateNestedOneWithoutAttachmentsInput
    photoEntry?: PhotoEntryCreateNestedOneWithoutAttachmentInput
  }

  export type AttachmentUncheckedCreateInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    logEntryId?: string | null
    communicationId?: string | null
    actaId?: string | null
    costActaId?: string | null
    reportId?: string | null
    commentId?: string | null
    workActaId?: string | null
    weeklyReportId?: string | null
    createdAt?: Date | string
    contractMod?: ContractModificationUncheckedCreateNestedOneWithoutAttachmentInput
    photoEntry?: PhotoEntryUncheckedCreateNestedOneWithoutAttachmentInput
  }

  export type AttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntry?: LogEntryUpdateOneWithoutAttachmentsNestedInput
    communication?: CommunicationUpdateOneWithoutAttachmentsNestedInput
    acta?: ActaUpdateOneWithoutAttachmentsNestedInput
    costActa?: CostActaUpdateOneWithoutAttachmentsNestedInput
    report?: ReportUpdateOneWithoutAttachmentsNestedInput
    comment?: CommentUpdateOneWithoutAttachmentsNestedInput
    contractMod?: ContractModificationUpdateOneWithoutAttachmentNestedInput
    workActa?: WorkActaUpdateOneWithoutAttachmentsNestedInput
    weeklyReport?: WeeklyReportUpdateOneWithoutAttachmentsNestedInput
    photoEntry?: PhotoEntryUpdateOneWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    communicationId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    costActaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    workActaId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyReportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractMod?: ContractModificationUncheckedUpdateOneWithoutAttachmentNestedInput
    photoEntry?: PhotoEntryUncheckedUpdateOneWithoutAttachmentNestedInput
  }

  export type AttachmentCreateManyInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    logEntryId?: string | null
    communicationId?: string | null
    actaId?: string | null
    costActaId?: string | null
    reportId?: string | null
    commentId?: string | null
    workActaId?: string | null
    weeklyReportId?: string | null
    createdAt?: Date | string
  }

  export type AttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    communicationId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    costActaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    workActaId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyReportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActaCreateInput = {
    id?: string
    number: string
    title: string
    date: Date | string
    area: $Enums.ActaArea
    status: $Enums.ActaStatus
    summary: string
    requiredSignatoriesJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentCreateNestedManyWithoutActaInput
    signatures?: SignatureCreateNestedManyWithoutActaInput
    commitments?: CommitmentCreateNestedManyWithoutActaInput
  }

  export type ActaUncheckedCreateInput = {
    id?: string
    number: string
    title: string
    date: Date | string
    area: $Enums.ActaArea
    status: $Enums.ActaStatus
    summary: string
    requiredSignatoriesJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutActaInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutActaInput
    commitments?: CommitmentUncheckedCreateNestedManyWithoutActaInput
  }

  export type ActaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: EnumActaAreaFieldUpdateOperationsInput | $Enums.ActaArea
    status?: EnumActaStatusFieldUpdateOperationsInput | $Enums.ActaStatus
    summary?: StringFieldUpdateOperationsInput | string
    requiredSignatoriesJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUpdateManyWithoutActaNestedInput
    signatures?: SignatureUpdateManyWithoutActaNestedInput
    commitments?: CommitmentUpdateManyWithoutActaNestedInput
  }

  export type ActaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: EnumActaAreaFieldUpdateOperationsInput | $Enums.ActaArea
    status?: EnumActaStatusFieldUpdateOperationsInput | $Enums.ActaStatus
    summary?: StringFieldUpdateOperationsInput | string
    requiredSignatoriesJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutActaNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutActaNestedInput
    commitments?: CommitmentUncheckedUpdateManyWithoutActaNestedInput
  }

  export type ActaCreateManyInput = {
    id?: string
    number: string
    title: string
    date: Date | string
    area: $Enums.ActaArea
    status: $Enums.ActaStatus
    summary: string
    requiredSignatoriesJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: EnumActaAreaFieldUpdateOperationsInput | $Enums.ActaArea
    status?: EnumActaStatusFieldUpdateOperationsInput | $Enums.ActaStatus
    summary?: StringFieldUpdateOperationsInput | string
    requiredSignatoriesJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: EnumActaAreaFieldUpdateOperationsInput | $Enums.ActaArea
    status?: EnumActaStatusFieldUpdateOperationsInput | $Enums.ActaStatus
    summary?: StringFieldUpdateOperationsInput | string
    requiredSignatoriesJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommitmentCreateInput = {
    id?: string
    description: string
    dueDate: Date | string
    status: $Enums.CommitmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    responsible: UserCreateNestedOneWithoutResponsibleForInput
    acta: ActaCreateNestedOneWithoutCommitmentsInput
  }

  export type CommitmentUncheckedCreateInput = {
    id?: string
    description: string
    dueDate: Date | string
    status: $Enums.CommitmentStatus
    responsibleId: string
    actaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommitmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCommitmentStatusFieldUpdateOperationsInput | $Enums.CommitmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible?: UserUpdateOneRequiredWithoutResponsibleForNestedInput
    acta?: ActaUpdateOneRequiredWithoutCommitmentsNestedInput
  }

  export type CommitmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCommitmentStatusFieldUpdateOperationsInput | $Enums.CommitmentStatus
    responsibleId?: StringFieldUpdateOperationsInput | string
    actaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommitmentCreateManyInput = {
    id?: string
    description: string
    dueDate: Date | string
    status: $Enums.CommitmentStatus
    responsibleId: string
    actaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommitmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCommitmentStatusFieldUpdateOperationsInput | $Enums.CommitmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommitmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCommitmentStatusFieldUpdateOperationsInput | $Enums.CommitmentStatus
    responsibleId?: StringFieldUpdateOperationsInput | string
    actaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostActaCreateInput = {
    id?: string
    number: string
    period: string
    submissionDate: Date | string
    approvalDate?: Date | string | null
    paymentDueDate?: Date | string | null
    billedAmount: number
    totalContractValue: number
    status: $Enums.CostActaStatus
    relatedProgress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    observations?: ObservationCreateNestedManyWithoutCostActaInput
    attachments?: AttachmentCreateNestedManyWithoutCostActaInput
  }

  export type CostActaUncheckedCreateInput = {
    id?: string
    number: string
    period: string
    submissionDate: Date | string
    approvalDate?: Date | string | null
    paymentDueDate?: Date | string | null
    billedAmount: number
    totalContractValue: number
    status: $Enums.CostActaStatus
    relatedProgress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    observations?: ObservationUncheckedCreateNestedManyWithoutCostActaInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutCostActaInput
  }

  export type CostActaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billedAmount?: FloatFieldUpdateOperationsInput | number
    totalContractValue?: FloatFieldUpdateOperationsInput | number
    status?: EnumCostActaStatusFieldUpdateOperationsInput | $Enums.CostActaStatus
    relatedProgress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    observations?: ObservationUpdateManyWithoutCostActaNestedInput
    attachments?: AttachmentUpdateManyWithoutCostActaNestedInput
  }

  export type CostActaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billedAmount?: FloatFieldUpdateOperationsInput | number
    totalContractValue?: FloatFieldUpdateOperationsInput | number
    status?: EnumCostActaStatusFieldUpdateOperationsInput | $Enums.CostActaStatus
    relatedProgress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    observations?: ObservationUncheckedUpdateManyWithoutCostActaNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutCostActaNestedInput
  }

  export type CostActaCreateManyInput = {
    id?: string
    number: string
    period: string
    submissionDate: Date | string
    approvalDate?: Date | string | null
    paymentDueDate?: Date | string | null
    billedAmount: number
    totalContractValue: number
    status: $Enums.CostActaStatus
    relatedProgress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostActaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billedAmount?: FloatFieldUpdateOperationsInput | number
    totalContractValue?: FloatFieldUpdateOperationsInput | number
    status?: EnumCostActaStatusFieldUpdateOperationsInput | $Enums.CostActaStatus
    relatedProgress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostActaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billedAmount?: FloatFieldUpdateOperationsInput | number
    totalContractValue?: FloatFieldUpdateOperationsInput | number
    status?: EnumCostActaStatusFieldUpdateOperationsInput | $Enums.CostActaStatus
    relatedProgress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObservationCreateInput = {
    id?: string
    text: string
    timestamp?: Date | string
    author: UserCreateNestedOneWithoutObservationsInput
    costActa: CostActaCreateNestedOneWithoutObservationsInput
  }

  export type ObservationUncheckedCreateInput = {
    id?: string
    text: string
    timestamp?: Date | string
    authorId: string
    costActaId: string
  }

  export type ObservationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutObservationsNestedInput
    costActa?: CostActaUpdateOneRequiredWithoutObservationsNestedInput
  }

  export type ObservationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    costActaId?: StringFieldUpdateOperationsInput | string
  }

  export type ObservationCreateManyInput = {
    id?: string
    text: string
    timestamp?: Date | string
    authorId: string
    costActaId: string
  }

  export type ObservationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObservationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    costActaId?: StringFieldUpdateOperationsInput | string
  }

  export type ReportCreateInput = {
    id?: string
    type: string
    reportScope: $Enums.ReportScope
    number: string
    period: string
    submissionDate: Date | string
    summary: string
    status: $Enums.ReportStatus
    requiredSignatoriesJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutReportsInput
    attachments?: AttachmentCreateNestedManyWithoutReportInput
    signatures?: SignatureCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    type: string
    reportScope: $Enums.ReportScope
    number: string
    period: string
    submissionDate: Date | string
    summary: string
    status: $Enums.ReportStatus
    authorId: string
    requiredSignatoriesJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutReportInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reportScope?: EnumReportScopeFieldUpdateOperationsInput | $Enums.ReportScope
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    requiredSignatoriesJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutReportsNestedInput
    attachments?: AttachmentUpdateManyWithoutReportNestedInput
    signatures?: SignatureUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reportScope?: EnumReportScopeFieldUpdateOperationsInput | $Enums.ReportScope
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    authorId?: StringFieldUpdateOperationsInput | string
    requiredSignatoriesJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutReportNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportCreateManyInput = {
    id?: string
    type: string
    reportScope: $Enums.ReportScope
    number: string
    period: string
    submissionDate: Date | string
    summary: string
    status: $Enums.ReportStatus
    authorId: string
    requiredSignatoriesJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reportScope?: EnumReportScopeFieldUpdateOperationsInput | $Enums.ReportScope
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    requiredSignatoriesJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reportScope?: EnumReportScopeFieldUpdateOperationsInput | $Enums.ReportScope
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    authorId?: StringFieldUpdateOperationsInput | string
    requiredSignatoriesJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DrawingCreateInput = {
    id?: string
    code: string
    title: string
    discipline: $Enums.DrawingDiscipline
    status: $Enums.DrawingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: DrawingVersionCreateNestedManyWithoutDrawingInput
    comments?: CommentCreateNestedManyWithoutDrawingInput
  }

  export type DrawingUncheckedCreateInput = {
    id?: string
    code: string
    title: string
    discipline: $Enums.DrawingDiscipline
    status: $Enums.DrawingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: DrawingVersionUncheckedCreateNestedManyWithoutDrawingInput
    comments?: CommentUncheckedCreateNestedManyWithoutDrawingInput
  }

  export type DrawingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    discipline?: EnumDrawingDisciplineFieldUpdateOperationsInput | $Enums.DrawingDiscipline
    status?: EnumDrawingStatusFieldUpdateOperationsInput | $Enums.DrawingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: DrawingVersionUpdateManyWithoutDrawingNestedInput
    comments?: CommentUpdateManyWithoutDrawingNestedInput
  }

  export type DrawingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    discipline?: EnumDrawingDisciplineFieldUpdateOperationsInput | $Enums.DrawingDiscipline
    status?: EnumDrawingStatusFieldUpdateOperationsInput | $Enums.DrawingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: DrawingVersionUncheckedUpdateManyWithoutDrawingNestedInput
    comments?: CommentUncheckedUpdateManyWithoutDrawingNestedInput
  }

  export type DrawingCreateManyInput = {
    id?: string
    code: string
    title: string
    discipline: $Enums.DrawingDiscipline
    status: $Enums.DrawingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DrawingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    discipline?: EnumDrawingDisciplineFieldUpdateOperationsInput | $Enums.DrawingDiscipline
    status?: EnumDrawingStatusFieldUpdateOperationsInput | $Enums.DrawingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DrawingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    discipline?: EnumDrawingDisciplineFieldUpdateOperationsInput | $Enums.DrawingDiscipline
    status?: EnumDrawingStatusFieldUpdateOperationsInput | $Enums.DrawingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DrawingVersionCreateInput = {
    id?: string
    versionNumber: number
    fileName: string
    url: string
    size: number
    uploadDate?: Date | string
    uploader: UserCreateNestedOneWithoutDrawingVersionsInput
    drawing: DrawingCreateNestedOneWithoutVersionsInput
  }

  export type DrawingVersionUncheckedCreateInput = {
    id?: string
    versionNumber: number
    fileName: string
    url: string
    size: number
    uploadDate?: Date | string
    uploaderId: string
    drawingId: string
  }

  export type DrawingVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneRequiredWithoutDrawingVersionsNestedInput
    drawing?: DrawingUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type DrawingVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    uploaderId?: StringFieldUpdateOperationsInput | string
    drawingId?: StringFieldUpdateOperationsInput | string
  }

  export type DrawingVersionCreateManyInput = {
    id?: string
    versionNumber: number
    fileName: string
    url: string
    size: number
    uploadDate?: Date | string
    uploaderId: string
    drawingId: string
  }

  export type DrawingVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DrawingVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    uploaderId?: StringFieldUpdateOperationsInput | string
    drawingId?: StringFieldUpdateOperationsInput | string
  }

  export type PhotoEntryCreateInput = {
    id?: string
    url: string
    date?: Date | string
    notes?: string | null
    author: UserCreateNestedOneWithoutPhotoEntriesInput
    controlPoint: ControlPointCreateNestedOneWithoutPhotosInput
    attachment?: AttachmentCreateNestedOneWithoutPhotoEntryInput
  }

  export type PhotoEntryUncheckedCreateInput = {
    id?: string
    url: string
    date?: Date | string
    notes?: string | null
    authorId: string
    controlPointId: string
    attachmentId?: string | null
  }

  export type PhotoEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    author?: UserUpdateOneRequiredWithoutPhotoEntriesNestedInput
    controlPoint?: ControlPointUpdateOneRequiredWithoutPhotosNestedInput
    attachment?: AttachmentUpdateOneWithoutPhotoEntryNestedInput
  }

  export type PhotoEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    controlPointId?: StringFieldUpdateOperationsInput | string
    attachmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhotoEntryCreateManyInput = {
    id?: string
    url: string
    date?: Date | string
    notes?: string | null
    authorId: string
    controlPointId: string
    attachmentId?: string | null
  }

  export type PhotoEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhotoEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    controlPointId?: StringFieldUpdateOperationsInput | string
    attachmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ControlPointCreateInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: PhotoEntryCreateNestedManyWithoutControlPointInput
  }

  export type ControlPointUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: PhotoEntryUncheckedCreateNestedManyWithoutControlPointInput
  }

  export type ControlPointUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: PhotoEntryUpdateManyWithoutControlPointNestedInput
  }

  export type ControlPointUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: PhotoEntryUncheckedUpdateManyWithoutControlPointNestedInput
  }

  export type ControlPointCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ControlPointUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ControlPointUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTaskCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    progress?: number
    duration: number
    isSummary?: boolean
    outlineLevel?: number
    dependencies?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectTaskUncheckedCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    progress?: number
    duration: number
    isSummary?: boolean
    outlineLevel?: number
    dependencies?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    isSummary?: BoolFieldUpdateOperationsInput | boolean
    outlineLevel?: IntFieldUpdateOperationsInput | number
    dependencies?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    isSummary?: BoolFieldUpdateOperationsInput | boolean
    outlineLevel?: IntFieldUpdateOperationsInput | number
    dependencies?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTaskCreateManyInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    progress?: number
    duration: number
    isSummary?: boolean
    outlineLevel?: number
    dependencies?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    isSummary?: BoolFieldUpdateOperationsInput | boolean
    outlineLevel?: IntFieldUpdateOperationsInput | number
    dependencies?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    isSummary?: BoolFieldUpdateOperationsInput | boolean
    outlineLevel?: IntFieldUpdateOperationsInput | number
    dependencies?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractItemCreateInput = {
    id?: string
    itemCode: string
    description: string
    unit: string
    unitPrice: number
    contractQuantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workActaItems?: WorkActaItemCreateNestedManyWithoutContractItemInput
  }

  export type ContractItemUncheckedCreateInput = {
    id?: string
    itemCode: string
    description: string
    unit: string
    unitPrice: number
    contractQuantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workActaItems?: WorkActaItemUncheckedCreateNestedManyWithoutContractItemInput
  }

  export type ContractItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    contractQuantity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workActaItems?: WorkActaItemUpdateManyWithoutContractItemNestedInput
  }

  export type ContractItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    contractQuantity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workActaItems?: WorkActaItemUncheckedUpdateManyWithoutContractItemNestedInput
  }

  export type ContractItemCreateManyInput = {
    id?: string
    itemCode: string
    description: string
    unit: string
    unitPrice: number
    contractQuantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    contractQuantity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    contractQuantity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkActaCreateInput = {
    id?: string
    number: string
    period: string
    date: Date | string
    status: $Enums.WorkActaStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: WorkActaItemCreateNestedManyWithoutWorkActaInput
    attachments?: AttachmentCreateNestedManyWithoutWorkActaInput
  }

  export type WorkActaUncheckedCreateInput = {
    id?: string
    number: string
    period: string
    date: Date | string
    status: $Enums.WorkActaStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: WorkActaItemUncheckedCreateNestedManyWithoutWorkActaInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutWorkActaInput
  }

  export type WorkActaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWorkActaStatusFieldUpdateOperationsInput | $Enums.WorkActaStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: WorkActaItemUpdateManyWithoutWorkActaNestedInput
    attachments?: AttachmentUpdateManyWithoutWorkActaNestedInput
  }

  export type WorkActaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWorkActaStatusFieldUpdateOperationsInput | $Enums.WorkActaStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: WorkActaItemUncheckedUpdateManyWithoutWorkActaNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutWorkActaNestedInput
  }

  export type WorkActaCreateManyInput = {
    id?: string
    number: string
    period: string
    date: Date | string
    status: $Enums.WorkActaStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkActaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWorkActaStatusFieldUpdateOperationsInput | $Enums.WorkActaStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkActaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWorkActaStatusFieldUpdateOperationsInput | $Enums.WorkActaStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkActaItemCreateInput = {
    id?: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workActa: WorkActaCreateNestedOneWithoutItemsInput
    contractItem: ContractItemCreateNestedOneWithoutWorkActaItemsInput
  }

  export type WorkActaItemUncheckedCreateInput = {
    id?: string
    quantity: number
    workActaId: string
    contractItemId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkActaItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workActa?: WorkActaUpdateOneRequiredWithoutItemsNestedInput
    contractItem?: ContractItemUpdateOneRequiredWithoutWorkActaItemsNestedInput
  }

  export type WorkActaItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    workActaId?: StringFieldUpdateOperationsInput | string
    contractItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkActaItemCreateManyInput = {
    id?: string
    quantity: number
    workActaId: string
    contractItemId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkActaItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkActaItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    workActaId?: StringFieldUpdateOperationsInput | string
    contractItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumAppRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AppRole | EnumAppRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AppRole[]
    notIn?: $Enums.AppRole[]
    not?: NestedEnumAppRoleFilter<$PrismaModel> | $Enums.AppRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type LogEntryListRelationFilter = {
    every?: LogEntryWhereInput
    some?: LogEntryWhereInput
    none?: LogEntryWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type SignatureListRelationFilter = {
    every?: SignatureWhereInput
    some?: SignatureWhereInput
    none?: SignatureWhereInput
  }

  export type CommunicationListRelationFilter = {
    every?: CommunicationWhereInput
    some?: CommunicationWhereInput
    none?: CommunicationWhereInput
  }

  export type CommunicationStatusHistoryListRelationFilter = {
    every?: CommunicationStatusHistoryWhereInput
    some?: CommunicationStatusHistoryWhereInput
    none?: CommunicationStatusHistoryWhereInput
  }

  export type PhotoEntryListRelationFilter = {
    every?: PhotoEntryWhereInput
    some?: PhotoEntryWhereInput
    none?: PhotoEntryWhereInput
  }

  export type CommitmentListRelationFilter = {
    every?: CommitmentWhereInput
    some?: CommitmentWhereInput
    none?: CommitmentWhereInput
  }

  export type ObservationListRelationFilter = {
    every?: ObservationWhereInput
    some?: ObservationWhereInput
    none?: ObservationWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type DrawingVersionListRelationFilter = {
    every?: DrawingVersionWhereInput
    some?: DrawingVersionWhereInput
    none?: DrawingVersionWhereInput
  }

  export type LogEntryHistoryListRelationFilter = {
    every?: LogEntryHistoryWhereInput
    some?: LogEntryHistoryWhereInput
    none?: LogEntryHistoryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type LogEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SignatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunicationStatusHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhotoEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommitmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DrawingVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogEntryHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    projectRole?: SortOrder
    appRole?: SortOrder
    avatarUrl?: SortOrder
    status?: SortOrder
    lastLoginAt?: SortOrder
    tokenVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    tokenVersion?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    projectRole?: SortOrder
    appRole?: SortOrder
    avatarUrl?: SortOrder
    status?: SortOrder
    lastLoginAt?: SortOrder
    tokenVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    fullName?: SortOrder
    projectRole?: SortOrder
    appRole?: SortOrder
    avatarUrl?: SortOrder
    status?: SortOrder
    lastLoginAt?: SortOrder
    tokenVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    tokenVersion?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumAppRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppRole | EnumAppRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AppRole[]
    notIn?: $Enums.AppRole[]
    not?: NestedEnumAppRoleWithAggregatesFilter<$PrismaModel> | $Enums.AppRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppRoleFilter<$PrismaModel>
    _max?: NestedEnumAppRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type KeyPersonnelListRelationFilter = {
    every?: KeyPersonnelWhereInput
    some?: KeyPersonnelWhereInput
    none?: KeyPersonnelWhereInput
  }

  export type KeyPersonnelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contractId?: SortOrder
    object?: SortOrder
    contractorName?: SortOrder
    supervisorName?: SortOrder
    initialValue?: SortOrder
    startDate?: SortOrder
    initialEndDate?: SortOrder
    interventoriaContractId?: SortOrder
    interventoriaInitialValue?: SortOrder
    technicalSupervisorName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    initialValue?: SortOrder
    interventoriaInitialValue?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contractId?: SortOrder
    object?: SortOrder
    contractorName?: SortOrder
    supervisorName?: SortOrder
    initialValue?: SortOrder
    startDate?: SortOrder
    initialEndDate?: SortOrder
    interventoriaContractId?: SortOrder
    interventoriaInitialValue?: SortOrder
    technicalSupervisorName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contractId?: SortOrder
    object?: SortOrder
    contractorName?: SortOrder
    supervisorName?: SortOrder
    initialValue?: SortOrder
    startDate?: SortOrder
    initialEndDate?: SortOrder
    interventoriaContractId?: SortOrder
    interventoriaInitialValue?: SortOrder
    technicalSupervisorName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    initialValue?: SortOrder
    interventoriaInitialValue?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ProjectRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type KeyPersonnelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    company?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    projectId?: SortOrder
  }

  export type KeyPersonnelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    company?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    projectId?: SortOrder
  }

  export type KeyPersonnelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    company?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    projectId?: SortOrder
  }

  export type EnumDeliveryMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryMethod | EnumDeliveryMethodFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryMethod[]
    notIn?: $Enums.DeliveryMethod[]
    not?: NestedEnumDeliveryMethodFilter<$PrismaModel> | $Enums.DeliveryMethod
  }

  export type EnumCommunicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationStatus | EnumCommunicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationStatus[]
    notIn?: $Enums.CommunicationStatus[]
    not?: NestedEnumCommunicationStatusFilter<$PrismaModel> | $Enums.CommunicationStatus
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CommunicationNullableRelationFilter = {
    is?: CommunicationWhereInput | null
    isNot?: CommunicationWhereInput | null
  }

  export type AttachmentListRelationFilter = {
    every?: AttachmentWhereInput
    some?: AttachmentWhereInput
    none?: AttachmentWhereInput
  }

  export type AttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunicationCountOrderByAggregateInput = {
    id?: SortOrder
    radicado?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    senderEntity?: SortOrder
    senderName?: SortOrder
    senderTitle?: SortOrder
    recipientEntity?: SortOrder
    recipientName?: SortOrder
    recipientTitle?: SortOrder
    signerName?: SortOrder
    sentDate?: SortOrder
    dueDate?: SortOrder
    deliveryMethod?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    uploaderId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunicationMaxOrderByAggregateInput = {
    id?: SortOrder
    radicado?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    senderEntity?: SortOrder
    senderName?: SortOrder
    senderTitle?: SortOrder
    recipientEntity?: SortOrder
    recipientName?: SortOrder
    recipientTitle?: SortOrder
    signerName?: SortOrder
    sentDate?: SortOrder
    dueDate?: SortOrder
    deliveryMethod?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    uploaderId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunicationMinOrderByAggregateInput = {
    id?: SortOrder
    radicado?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    senderEntity?: SortOrder
    senderName?: SortOrder
    senderTitle?: SortOrder
    recipientEntity?: SortOrder
    recipientName?: SortOrder
    recipientTitle?: SortOrder
    signerName?: SortOrder
    sentDate?: SortOrder
    dueDate?: SortOrder
    deliveryMethod?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    uploaderId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDeliveryMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryMethod | EnumDeliveryMethodFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryMethod[]
    notIn?: $Enums.DeliveryMethod[]
    not?: NestedEnumDeliveryMethodWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryMethodFilter<$PrismaModel>
    _max?: NestedEnumDeliveryMethodFilter<$PrismaModel>
  }

  export type EnumCommunicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationStatus | EnumCommunicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationStatus[]
    notIn?: $Enums.CommunicationStatus[]
    not?: NestedEnumCommunicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.CommunicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommunicationStatusFilter<$PrismaModel>
    _max?: NestedEnumCommunicationStatusFilter<$PrismaModel>
  }

  export type CommunicationRelationFilter = {
    is?: CommunicationWhereInput
    isNot?: CommunicationWhereInput
  }

  export type CommunicationStatusHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    communicationId?: SortOrder
    userId?: SortOrder
  }

  export type CommunicationStatusHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    communicationId?: SortOrder
    userId?: SortOrder
  }

  export type CommunicationStatusHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    timestamp?: SortOrder
    communicationId?: SortOrder
    userId?: SortOrder
  }

  export type EnumModificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ModificationType | EnumModificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ModificationType[]
    notIn?: $Enums.ModificationType[]
    not?: NestedEnumModificationTypeFilter<$PrismaModel> | $Enums.ModificationType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AttachmentNullableRelationFilter = {
    is?: AttachmentWhereInput | null
    isNot?: AttachmentWhereInput | null
  }

  export type ContractModificationCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    date?: SortOrder
    value?: SortOrder
    days?: SortOrder
    justification?: SortOrder
    attachmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractModificationAvgOrderByAggregateInput = {
    value?: SortOrder
    days?: SortOrder
  }

  export type ContractModificationMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    date?: SortOrder
    value?: SortOrder
    days?: SortOrder
    justification?: SortOrder
    attachmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractModificationMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    type?: SortOrder
    date?: SortOrder
    value?: SortOrder
    days?: SortOrder
    justification?: SortOrder
    attachmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractModificationSumOrderByAggregateInput = {
    value?: SortOrder
    days?: SortOrder
  }

  export type EnumModificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModificationType | EnumModificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ModificationType[]
    notIn?: $Enums.ModificationType[]
    not?: NestedEnumModificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ModificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModificationTypeFilter<$PrismaModel>
    _max?: NestedEnumModificationTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type WeeklyReportCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    summary?: SortOrder
    progressSummary?: SortOrder
    nextWeekPlan?: SortOrder
    issues?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeeklyReportMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    summary?: SortOrder
    progressSummary?: SortOrder
    nextWeekPlan?: SortOrder
    issues?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WeeklyReportMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    summary?: SortOrder
    progressSummary?: SortOrder
    nextWeekPlan?: SortOrder
    issues?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEntryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EntryType | EnumEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntryType[]
    notIn?: $Enums.EntryType[]
    not?: NestedEnumEntryTypeFilter<$PrismaModel> | $Enums.EntryType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumEntryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EntryStatus | EnumEntryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EntryStatus[]
    notIn?: $Enums.EntryStatus[]
    not?: NestedEnumEntryStatusFilter<$PrismaModel> | $Enums.EntryStatus
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogEntryCountOrderByAggregateInput = {
    id?: SortOrder
    folioNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    location?: SortOrder
    activityStartDate?: SortOrder
    activityEndDate?: SortOrder
    isConfidential?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LogEntryAvgOrderByAggregateInput = {
    folioNumber?: SortOrder
  }

  export type LogEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    folioNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    location?: SortOrder
    activityStartDate?: SortOrder
    activityEndDate?: SortOrder
    isConfidential?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LogEntryMinOrderByAggregateInput = {
    id?: SortOrder
    folioNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    location?: SortOrder
    activityStartDate?: SortOrder
    activityEndDate?: SortOrder
    isConfidential?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    projectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LogEntrySumOrderByAggregateInput = {
    folioNumber?: SortOrder
  }

  export type EnumEntryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntryType | EnumEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntryType[]
    notIn?: $Enums.EntryType[]
    not?: NestedEnumEntryTypeWithAggregatesFilter<$PrismaModel> | $Enums.EntryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntryTypeFilter<$PrismaModel>
    _max?: NestedEnumEntryTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumEntryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntryStatus | EnumEntryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EntryStatus[]
    notIn?: $Enums.EntryStatus[]
    not?: NestedEnumEntryStatusWithAggregatesFilter<$PrismaModel> | $Enums.EntryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntryStatusFilter<$PrismaModel>
    _max?: NestedEnumEntryStatusFilter<$PrismaModel>
  }

  export type LogEntryRelationFilter = {
    is?: LogEntryWhereInput
    isNot?: LogEntryWhereInput
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type LogEntryHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    fieldName?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    timestamp?: SortOrder
    logEntryId?: SortOrder
    userId?: SortOrder
  }

  export type LogEntryHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    fieldName?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    timestamp?: SortOrder
    logEntryId?: SortOrder
    userId?: SortOrder
  }

  export type LogEntryHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    fieldName?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    timestamp?: SortOrder
    logEntryId?: SortOrder
    userId?: SortOrder
  }

  export type LogEntryNullableRelationFilter = {
    is?: LogEntryWhereInput | null
    isNot?: LogEntryWhereInput | null
  }

  export type DrawingNullableRelationFilter = {
    is?: DrawingWhereInput | null
    isNot?: DrawingWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    authorId?: SortOrder
    logEntryId?: SortOrder
    drawingId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    authorId?: SortOrder
    logEntryId?: SortOrder
    drawingId?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    timestamp?: SortOrder
    authorId?: SortOrder
    logEntryId?: SortOrder
    drawingId?: SortOrder
  }

  export type ActaNullableRelationFilter = {
    is?: ActaWhereInput | null
    isNot?: ActaWhereInput | null
  }

  export type ReportNullableRelationFilter = {
    is?: ReportWhereInput | null
    isNot?: ReportWhereInput | null
  }

  export type SignatureCountOrderByAggregateInput = {
    id?: SortOrder
    signedAt?: SortOrder
    signerId?: SortOrder
    logEntryId?: SortOrder
    actaId?: SortOrder
    reportId?: SortOrder
  }

  export type SignatureMaxOrderByAggregateInput = {
    id?: SortOrder
    signedAt?: SortOrder
    signerId?: SortOrder
    logEntryId?: SortOrder
    actaId?: SortOrder
    reportId?: SortOrder
  }

  export type SignatureMinOrderByAggregateInput = {
    id?: SortOrder
    signedAt?: SortOrder
    signerId?: SortOrder
    logEntryId?: SortOrder
    actaId?: SortOrder
    reportId?: SortOrder
  }

  export type CostActaNullableRelationFilter = {
    is?: CostActaWhereInput | null
    isNot?: CostActaWhereInput | null
  }

  export type CommentNullableRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type ContractModificationNullableRelationFilter = {
    is?: ContractModificationWhereInput | null
    isNot?: ContractModificationWhereInput | null
  }

  export type WorkActaNullableRelationFilter = {
    is?: WorkActaWhereInput | null
    isNot?: WorkActaWhereInput | null
  }

  export type WeeklyReportNullableRelationFilter = {
    is?: WeeklyReportWhereInput | null
    isNot?: WeeklyReportWhereInput | null
  }

  export type PhotoEntryNullableRelationFilter = {
    is?: PhotoEntryWhereInput | null
    isNot?: PhotoEntryWhereInput | null
  }

  export type AttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    url?: SortOrder
    size?: SortOrder
    type?: SortOrder
    logEntryId?: SortOrder
    communicationId?: SortOrder
    actaId?: SortOrder
    costActaId?: SortOrder
    reportId?: SortOrder
    commentId?: SortOrder
    workActaId?: SortOrder
    weeklyReportId?: SortOrder
    createdAt?: SortOrder
  }

  export type AttachmentAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type AttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    url?: SortOrder
    size?: SortOrder
    type?: SortOrder
    logEntryId?: SortOrder
    communicationId?: SortOrder
    actaId?: SortOrder
    costActaId?: SortOrder
    reportId?: SortOrder
    commentId?: SortOrder
    workActaId?: SortOrder
    weeklyReportId?: SortOrder
    createdAt?: SortOrder
  }

  export type AttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    fileName?: SortOrder
    url?: SortOrder
    size?: SortOrder
    type?: SortOrder
    logEntryId?: SortOrder
    communicationId?: SortOrder
    actaId?: SortOrder
    costActaId?: SortOrder
    reportId?: SortOrder
    commentId?: SortOrder
    workActaId?: SortOrder
    weeklyReportId?: SortOrder
    createdAt?: SortOrder
  }

  export type AttachmentSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type EnumActaAreaFilter<$PrismaModel = never> = {
    equals?: $Enums.ActaArea | EnumActaAreaFieldRefInput<$PrismaModel>
    in?: $Enums.ActaArea[]
    notIn?: $Enums.ActaArea[]
    not?: NestedEnumActaAreaFilter<$PrismaModel> | $Enums.ActaArea
  }

  export type EnumActaStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ActaStatus | EnumActaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActaStatus[]
    notIn?: $Enums.ActaStatus[]
    not?: NestedEnumActaStatusFilter<$PrismaModel> | $Enums.ActaStatus
  }

  export type ActaCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    title?: SortOrder
    date?: SortOrder
    area?: SortOrder
    status?: SortOrder
    summary?: SortOrder
    requiredSignatoriesJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActaMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    title?: SortOrder
    date?: SortOrder
    area?: SortOrder
    status?: SortOrder
    summary?: SortOrder
    requiredSignatoriesJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActaMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    title?: SortOrder
    date?: SortOrder
    area?: SortOrder
    status?: SortOrder
    summary?: SortOrder
    requiredSignatoriesJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumActaAreaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActaArea | EnumActaAreaFieldRefInput<$PrismaModel>
    in?: $Enums.ActaArea[]
    notIn?: $Enums.ActaArea[]
    not?: NestedEnumActaAreaWithAggregatesFilter<$PrismaModel> | $Enums.ActaArea
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActaAreaFilter<$PrismaModel>
    _max?: NestedEnumActaAreaFilter<$PrismaModel>
  }

  export type EnumActaStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActaStatus | EnumActaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActaStatus[]
    notIn?: $Enums.ActaStatus[]
    not?: NestedEnumActaStatusWithAggregatesFilter<$PrismaModel> | $Enums.ActaStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActaStatusFilter<$PrismaModel>
    _max?: NestedEnumActaStatusFilter<$PrismaModel>
  }

  export type EnumCommitmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CommitmentStatus | EnumCommitmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommitmentStatus[]
    notIn?: $Enums.CommitmentStatus[]
    not?: NestedEnumCommitmentStatusFilter<$PrismaModel> | $Enums.CommitmentStatus
  }

  export type ActaRelationFilter = {
    is?: ActaWhereInput
    isNot?: ActaWhereInput
  }

  export type CommitmentCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    responsibleId?: SortOrder
    actaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommitmentMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    responsibleId?: SortOrder
    actaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommitmentMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    responsibleId?: SortOrder
    actaId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCommitmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommitmentStatus | EnumCommitmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommitmentStatus[]
    notIn?: $Enums.CommitmentStatus[]
    not?: NestedEnumCommitmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.CommitmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommitmentStatusFilter<$PrismaModel>
    _max?: NestedEnumCommitmentStatusFilter<$PrismaModel>
  }

  export type EnumCostActaStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CostActaStatus | EnumCostActaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CostActaStatus[]
    notIn?: $Enums.CostActaStatus[]
    not?: NestedEnumCostActaStatusFilter<$PrismaModel> | $Enums.CostActaStatus
  }

  export type CostActaCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    period?: SortOrder
    submissionDate?: SortOrder
    approvalDate?: SortOrder
    paymentDueDate?: SortOrder
    billedAmount?: SortOrder
    totalContractValue?: SortOrder
    status?: SortOrder
    relatedProgress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostActaAvgOrderByAggregateInput = {
    billedAmount?: SortOrder
    totalContractValue?: SortOrder
  }

  export type CostActaMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    period?: SortOrder
    submissionDate?: SortOrder
    approvalDate?: SortOrder
    paymentDueDate?: SortOrder
    billedAmount?: SortOrder
    totalContractValue?: SortOrder
    status?: SortOrder
    relatedProgress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostActaMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    period?: SortOrder
    submissionDate?: SortOrder
    approvalDate?: SortOrder
    paymentDueDate?: SortOrder
    billedAmount?: SortOrder
    totalContractValue?: SortOrder
    status?: SortOrder
    relatedProgress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostActaSumOrderByAggregateInput = {
    billedAmount?: SortOrder
    totalContractValue?: SortOrder
  }

  export type EnumCostActaStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CostActaStatus | EnumCostActaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CostActaStatus[]
    notIn?: $Enums.CostActaStatus[]
    not?: NestedEnumCostActaStatusWithAggregatesFilter<$PrismaModel> | $Enums.CostActaStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCostActaStatusFilter<$PrismaModel>
    _max?: NestedEnumCostActaStatusFilter<$PrismaModel>
  }

  export type CostActaRelationFilter = {
    is?: CostActaWhereInput
    isNot?: CostActaWhereInput
  }

  export type ObservationCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    timestamp?: SortOrder
    authorId?: SortOrder
    costActaId?: SortOrder
  }

  export type ObservationMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    timestamp?: SortOrder
    authorId?: SortOrder
    costActaId?: SortOrder
  }

  export type ObservationMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    timestamp?: SortOrder
    authorId?: SortOrder
    costActaId?: SortOrder
  }

  export type EnumReportScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportScope | EnumReportScopeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportScope[]
    notIn?: $Enums.ReportScope[]
    not?: NestedEnumReportScopeFilter<$PrismaModel> | $Enums.ReportScope
  }

  export type EnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[]
    notIn?: $Enums.ReportStatus[]
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    reportScope?: SortOrder
    number?: SortOrder
    period?: SortOrder
    submissionDate?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    requiredSignatoriesJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    reportScope?: SortOrder
    number?: SortOrder
    period?: SortOrder
    submissionDate?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    requiredSignatoriesJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    reportScope?: SortOrder
    number?: SortOrder
    period?: SortOrder
    submissionDate?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    authorId?: SortOrder
    requiredSignatoriesJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumReportScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportScope | EnumReportScopeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportScope[]
    notIn?: $Enums.ReportScope[]
    not?: NestedEnumReportScopeWithAggregatesFilter<$PrismaModel> | $Enums.ReportScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportScopeFilter<$PrismaModel>
    _max?: NestedEnumReportScopeFilter<$PrismaModel>
  }

  export type EnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[]
    notIn?: $Enums.ReportStatus[]
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type EnumDrawingDisciplineFilter<$PrismaModel = never> = {
    equals?: $Enums.DrawingDiscipline | EnumDrawingDisciplineFieldRefInput<$PrismaModel>
    in?: $Enums.DrawingDiscipline[]
    notIn?: $Enums.DrawingDiscipline[]
    not?: NestedEnumDrawingDisciplineFilter<$PrismaModel> | $Enums.DrawingDiscipline
  }

  export type EnumDrawingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DrawingStatus | EnumDrawingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DrawingStatus[]
    notIn?: $Enums.DrawingStatus[]
    not?: NestedEnumDrawingStatusFilter<$PrismaModel> | $Enums.DrawingStatus
  }

  export type DrawingCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    discipline?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DrawingMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    discipline?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DrawingMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    title?: SortOrder
    discipline?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDrawingDisciplineWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DrawingDiscipline | EnumDrawingDisciplineFieldRefInput<$PrismaModel>
    in?: $Enums.DrawingDiscipline[]
    notIn?: $Enums.DrawingDiscipline[]
    not?: NestedEnumDrawingDisciplineWithAggregatesFilter<$PrismaModel> | $Enums.DrawingDiscipline
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDrawingDisciplineFilter<$PrismaModel>
    _max?: NestedEnumDrawingDisciplineFilter<$PrismaModel>
  }

  export type EnumDrawingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DrawingStatus | EnumDrawingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DrawingStatus[]
    notIn?: $Enums.DrawingStatus[]
    not?: NestedEnumDrawingStatusWithAggregatesFilter<$PrismaModel> | $Enums.DrawingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDrawingStatusFilter<$PrismaModel>
    _max?: NestedEnumDrawingStatusFilter<$PrismaModel>
  }

  export type DrawingRelationFilter = {
    is?: DrawingWhereInput
    isNot?: DrawingWhereInput
  }

  export type DrawingVersionCountOrderByAggregateInput = {
    id?: SortOrder
    versionNumber?: SortOrder
    fileName?: SortOrder
    url?: SortOrder
    size?: SortOrder
    uploadDate?: SortOrder
    uploaderId?: SortOrder
    drawingId?: SortOrder
  }

  export type DrawingVersionAvgOrderByAggregateInput = {
    versionNumber?: SortOrder
    size?: SortOrder
  }

  export type DrawingVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    versionNumber?: SortOrder
    fileName?: SortOrder
    url?: SortOrder
    size?: SortOrder
    uploadDate?: SortOrder
    uploaderId?: SortOrder
    drawingId?: SortOrder
  }

  export type DrawingVersionMinOrderByAggregateInput = {
    id?: SortOrder
    versionNumber?: SortOrder
    fileName?: SortOrder
    url?: SortOrder
    size?: SortOrder
    uploadDate?: SortOrder
    uploaderId?: SortOrder
    drawingId?: SortOrder
  }

  export type DrawingVersionSumOrderByAggregateInput = {
    versionNumber?: SortOrder
    size?: SortOrder
  }

  export type ControlPointRelationFilter = {
    is?: ControlPointWhereInput
    isNot?: ControlPointWhereInput
  }

  export type PhotoEntryCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    date?: SortOrder
    notes?: SortOrder
    authorId?: SortOrder
    controlPointId?: SortOrder
    attachmentId?: SortOrder
  }

  export type PhotoEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    date?: SortOrder
    notes?: SortOrder
    authorId?: SortOrder
    controlPointId?: SortOrder
    attachmentId?: SortOrder
  }

  export type PhotoEntryMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    date?: SortOrder
    notes?: SortOrder
    authorId?: SortOrder
    controlPointId?: SortOrder
    attachmentId?: SortOrder
  }

  export type ControlPointCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ControlPointMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ControlPointMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectTaskCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    progress?: SortOrder
    duration?: SortOrder
    isSummary?: SortOrder
    outlineLevel?: SortOrder
    dependencies?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectTaskAvgOrderByAggregateInput = {
    progress?: SortOrder
    duration?: SortOrder
    outlineLevel?: SortOrder
  }

  export type ProjectTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    progress?: SortOrder
    duration?: SortOrder
    isSummary?: SortOrder
    outlineLevel?: SortOrder
    dependencies?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectTaskMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    progress?: SortOrder
    duration?: SortOrder
    isSummary?: SortOrder
    outlineLevel?: SortOrder
    dependencies?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectTaskSumOrderByAggregateInput = {
    progress?: SortOrder
    duration?: SortOrder
    outlineLevel?: SortOrder
  }

  export type WorkActaItemListRelationFilter = {
    every?: WorkActaItemWhereInput
    some?: WorkActaItemWhereInput
    none?: WorkActaItemWhereInput
  }

  export type WorkActaItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractItemCountOrderByAggregateInput = {
    id?: SortOrder
    itemCode?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    contractQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractItemAvgOrderByAggregateInput = {
    unitPrice?: SortOrder
    contractQuantity?: SortOrder
  }

  export type ContractItemMaxOrderByAggregateInput = {
    id?: SortOrder
    itemCode?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    contractQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractItemMinOrderByAggregateInput = {
    id?: SortOrder
    itemCode?: SortOrder
    description?: SortOrder
    unit?: SortOrder
    unitPrice?: SortOrder
    contractQuantity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractItemSumOrderByAggregateInput = {
    unitPrice?: SortOrder
    contractQuantity?: SortOrder
  }

  export type EnumWorkActaStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkActaStatus | EnumWorkActaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkActaStatus[]
    notIn?: $Enums.WorkActaStatus[]
    not?: NestedEnumWorkActaStatusFilter<$PrismaModel> | $Enums.WorkActaStatus
  }

  export type WorkActaCountOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    period?: SortOrder
    date?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkActaMaxOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    period?: SortOrder
    date?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkActaMinOrderByAggregateInput = {
    id?: SortOrder
    number?: SortOrder
    period?: SortOrder
    date?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumWorkActaStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkActaStatus | EnumWorkActaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkActaStatus[]
    notIn?: $Enums.WorkActaStatus[]
    not?: NestedEnumWorkActaStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkActaStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkActaStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkActaStatusFilter<$PrismaModel>
  }

  export type WorkActaRelationFilter = {
    is?: WorkActaWhereInput
    isNot?: WorkActaWhereInput
  }

  export type ContractItemRelationFilter = {
    is?: ContractItemWhereInput
    isNot?: ContractItemWhereInput
  }

  export type WorkActaItemCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    workActaId?: SortOrder
    contractItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkActaItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type WorkActaItemMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    workActaId?: SortOrder
    contractItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkActaItemMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    workActaId?: SortOrder
    contractItemId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkActaItemSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type LogEntryCreateNestedManyWithoutAuthorInput = {
    create?: XOR<LogEntryCreateWithoutAuthorInput, LogEntryUncheckedCreateWithoutAuthorInput> | LogEntryCreateWithoutAuthorInput[] | LogEntryUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: LogEntryCreateOrConnectWithoutAuthorInput | LogEntryCreateOrConnectWithoutAuthorInput[]
    createMany?: LogEntryCreateManyAuthorInputEnvelope
    connect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
  }

  export type LogEntryCreateNestedManyWithoutAssigneesInput = {
    create?: XOR<LogEntryCreateWithoutAssigneesInput, LogEntryUncheckedCreateWithoutAssigneesInput> | LogEntryCreateWithoutAssigneesInput[] | LogEntryUncheckedCreateWithoutAssigneesInput[]
    connectOrCreate?: LogEntryCreateOrConnectWithoutAssigneesInput | LogEntryCreateOrConnectWithoutAssigneesInput[]
    connect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type SignatureCreateNestedManyWithoutSignerInput = {
    create?: XOR<SignatureCreateWithoutSignerInput, SignatureUncheckedCreateWithoutSignerInput> | SignatureCreateWithoutSignerInput[] | SignatureUncheckedCreateWithoutSignerInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutSignerInput | SignatureCreateOrConnectWithoutSignerInput[]
    createMany?: SignatureCreateManySignerInputEnvelope
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
  }

  export type CommunicationCreateNestedManyWithoutUploaderInput = {
    create?: XOR<CommunicationCreateWithoutUploaderInput, CommunicationUncheckedCreateWithoutUploaderInput> | CommunicationCreateWithoutUploaderInput[] | CommunicationUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutUploaderInput | CommunicationCreateOrConnectWithoutUploaderInput[]
    createMany?: CommunicationCreateManyUploaderInputEnvelope
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
  }

  export type CommunicationStatusHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<CommunicationStatusHistoryCreateWithoutUserInput, CommunicationStatusHistoryUncheckedCreateWithoutUserInput> | CommunicationStatusHistoryCreateWithoutUserInput[] | CommunicationStatusHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunicationStatusHistoryCreateOrConnectWithoutUserInput | CommunicationStatusHistoryCreateOrConnectWithoutUserInput[]
    createMany?: CommunicationStatusHistoryCreateManyUserInputEnvelope
    connect?: CommunicationStatusHistoryWhereUniqueInput | CommunicationStatusHistoryWhereUniqueInput[]
  }

  export type PhotoEntryCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PhotoEntryCreateWithoutAuthorInput, PhotoEntryUncheckedCreateWithoutAuthorInput> | PhotoEntryCreateWithoutAuthorInput[] | PhotoEntryUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PhotoEntryCreateOrConnectWithoutAuthorInput | PhotoEntryCreateOrConnectWithoutAuthorInput[]
    createMany?: PhotoEntryCreateManyAuthorInputEnvelope
    connect?: PhotoEntryWhereUniqueInput | PhotoEntryWhereUniqueInput[]
  }

  export type CommitmentCreateNestedManyWithoutResponsibleInput = {
    create?: XOR<CommitmentCreateWithoutResponsibleInput, CommitmentUncheckedCreateWithoutResponsibleInput> | CommitmentCreateWithoutResponsibleInput[] | CommitmentUncheckedCreateWithoutResponsibleInput[]
    connectOrCreate?: CommitmentCreateOrConnectWithoutResponsibleInput | CommitmentCreateOrConnectWithoutResponsibleInput[]
    createMany?: CommitmentCreateManyResponsibleInputEnvelope
    connect?: CommitmentWhereUniqueInput | CommitmentWhereUniqueInput[]
  }

  export type ObservationCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ObservationCreateWithoutAuthorInput, ObservationUncheckedCreateWithoutAuthorInput> | ObservationCreateWithoutAuthorInput[] | ObservationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ObservationCreateOrConnectWithoutAuthorInput | ObservationCreateOrConnectWithoutAuthorInput[]
    createMany?: ObservationCreateManyAuthorInputEnvelope
    connect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ReportCreateWithoutAuthorInput, ReportUncheckedCreateWithoutAuthorInput> | ReportCreateWithoutAuthorInput[] | ReportUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAuthorInput | ReportCreateOrConnectWithoutAuthorInput[]
    createMany?: ReportCreateManyAuthorInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type DrawingVersionCreateNestedManyWithoutUploaderInput = {
    create?: XOR<DrawingVersionCreateWithoutUploaderInput, DrawingVersionUncheckedCreateWithoutUploaderInput> | DrawingVersionCreateWithoutUploaderInput[] | DrawingVersionUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DrawingVersionCreateOrConnectWithoutUploaderInput | DrawingVersionCreateOrConnectWithoutUploaderInput[]
    createMany?: DrawingVersionCreateManyUploaderInputEnvelope
    connect?: DrawingVersionWhereUniqueInput | DrawingVersionWhereUniqueInput[]
  }

  export type LogEntryHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<LogEntryHistoryCreateWithoutUserInput, LogEntryHistoryUncheckedCreateWithoutUserInput> | LogEntryHistoryCreateWithoutUserInput[] | LogEntryHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogEntryHistoryCreateOrConnectWithoutUserInput | LogEntryHistoryCreateOrConnectWithoutUserInput[]
    createMany?: LogEntryHistoryCreateManyUserInputEnvelope
    connect?: LogEntryHistoryWhereUniqueInput | LogEntryHistoryWhereUniqueInput[]
  }

  export type LogEntryUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<LogEntryCreateWithoutAuthorInput, LogEntryUncheckedCreateWithoutAuthorInput> | LogEntryCreateWithoutAuthorInput[] | LogEntryUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: LogEntryCreateOrConnectWithoutAuthorInput | LogEntryCreateOrConnectWithoutAuthorInput[]
    createMany?: LogEntryCreateManyAuthorInputEnvelope
    connect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
  }

  export type LogEntryUncheckedCreateNestedManyWithoutAssigneesInput = {
    create?: XOR<LogEntryCreateWithoutAssigneesInput, LogEntryUncheckedCreateWithoutAssigneesInput> | LogEntryCreateWithoutAssigneesInput[] | LogEntryUncheckedCreateWithoutAssigneesInput[]
    connectOrCreate?: LogEntryCreateOrConnectWithoutAssigneesInput | LogEntryCreateOrConnectWithoutAssigneesInput[]
    connect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type SignatureUncheckedCreateNestedManyWithoutSignerInput = {
    create?: XOR<SignatureCreateWithoutSignerInput, SignatureUncheckedCreateWithoutSignerInput> | SignatureCreateWithoutSignerInput[] | SignatureUncheckedCreateWithoutSignerInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutSignerInput | SignatureCreateOrConnectWithoutSignerInput[]
    createMany?: SignatureCreateManySignerInputEnvelope
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
  }

  export type CommunicationUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<CommunicationCreateWithoutUploaderInput, CommunicationUncheckedCreateWithoutUploaderInput> | CommunicationCreateWithoutUploaderInput[] | CommunicationUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutUploaderInput | CommunicationCreateOrConnectWithoutUploaderInput[]
    createMany?: CommunicationCreateManyUploaderInputEnvelope
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
  }

  export type CommunicationStatusHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommunicationStatusHistoryCreateWithoutUserInput, CommunicationStatusHistoryUncheckedCreateWithoutUserInput> | CommunicationStatusHistoryCreateWithoutUserInput[] | CommunicationStatusHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunicationStatusHistoryCreateOrConnectWithoutUserInput | CommunicationStatusHistoryCreateOrConnectWithoutUserInput[]
    createMany?: CommunicationStatusHistoryCreateManyUserInputEnvelope
    connect?: CommunicationStatusHistoryWhereUniqueInput | CommunicationStatusHistoryWhereUniqueInput[]
  }

  export type PhotoEntryUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PhotoEntryCreateWithoutAuthorInput, PhotoEntryUncheckedCreateWithoutAuthorInput> | PhotoEntryCreateWithoutAuthorInput[] | PhotoEntryUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PhotoEntryCreateOrConnectWithoutAuthorInput | PhotoEntryCreateOrConnectWithoutAuthorInput[]
    createMany?: PhotoEntryCreateManyAuthorInputEnvelope
    connect?: PhotoEntryWhereUniqueInput | PhotoEntryWhereUniqueInput[]
  }

  export type CommitmentUncheckedCreateNestedManyWithoutResponsibleInput = {
    create?: XOR<CommitmentCreateWithoutResponsibleInput, CommitmentUncheckedCreateWithoutResponsibleInput> | CommitmentCreateWithoutResponsibleInput[] | CommitmentUncheckedCreateWithoutResponsibleInput[]
    connectOrCreate?: CommitmentCreateOrConnectWithoutResponsibleInput | CommitmentCreateOrConnectWithoutResponsibleInput[]
    createMany?: CommitmentCreateManyResponsibleInputEnvelope
    connect?: CommitmentWhereUniqueInput | CommitmentWhereUniqueInput[]
  }

  export type ObservationUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ObservationCreateWithoutAuthorInput, ObservationUncheckedCreateWithoutAuthorInput> | ObservationCreateWithoutAuthorInput[] | ObservationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ObservationCreateOrConnectWithoutAuthorInput | ObservationCreateOrConnectWithoutAuthorInput[]
    createMany?: ObservationCreateManyAuthorInputEnvelope
    connect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ReportCreateWithoutAuthorInput, ReportUncheckedCreateWithoutAuthorInput> | ReportCreateWithoutAuthorInput[] | ReportUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAuthorInput | ReportCreateOrConnectWithoutAuthorInput[]
    createMany?: ReportCreateManyAuthorInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type DrawingVersionUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<DrawingVersionCreateWithoutUploaderInput, DrawingVersionUncheckedCreateWithoutUploaderInput> | DrawingVersionCreateWithoutUploaderInput[] | DrawingVersionUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DrawingVersionCreateOrConnectWithoutUploaderInput | DrawingVersionCreateOrConnectWithoutUploaderInput[]
    createMany?: DrawingVersionCreateManyUploaderInputEnvelope
    connect?: DrawingVersionWhereUniqueInput | DrawingVersionWhereUniqueInput[]
  }

  export type LogEntryHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LogEntryHistoryCreateWithoutUserInput, LogEntryHistoryUncheckedCreateWithoutUserInput> | LogEntryHistoryCreateWithoutUserInput[] | LogEntryHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogEntryHistoryCreateOrConnectWithoutUserInput | LogEntryHistoryCreateOrConnectWithoutUserInput[]
    createMany?: LogEntryHistoryCreateManyUserInputEnvelope
    connect?: LogEntryHistoryWhereUniqueInput | LogEntryHistoryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumAppRoleFieldUpdateOperationsInput = {
    set?: $Enums.AppRole
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type LogEntryUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<LogEntryCreateWithoutAuthorInput, LogEntryUncheckedCreateWithoutAuthorInput> | LogEntryCreateWithoutAuthorInput[] | LogEntryUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: LogEntryCreateOrConnectWithoutAuthorInput | LogEntryCreateOrConnectWithoutAuthorInput[]
    upsert?: LogEntryUpsertWithWhereUniqueWithoutAuthorInput | LogEntryUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: LogEntryCreateManyAuthorInputEnvelope
    set?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    disconnect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    delete?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    connect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    update?: LogEntryUpdateWithWhereUniqueWithoutAuthorInput | LogEntryUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: LogEntryUpdateManyWithWhereWithoutAuthorInput | LogEntryUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: LogEntryScalarWhereInput | LogEntryScalarWhereInput[]
  }

  export type LogEntryUpdateManyWithoutAssigneesNestedInput = {
    create?: XOR<LogEntryCreateWithoutAssigneesInput, LogEntryUncheckedCreateWithoutAssigneesInput> | LogEntryCreateWithoutAssigneesInput[] | LogEntryUncheckedCreateWithoutAssigneesInput[]
    connectOrCreate?: LogEntryCreateOrConnectWithoutAssigneesInput | LogEntryCreateOrConnectWithoutAssigneesInput[]
    upsert?: LogEntryUpsertWithWhereUniqueWithoutAssigneesInput | LogEntryUpsertWithWhereUniqueWithoutAssigneesInput[]
    set?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    disconnect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    delete?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    connect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    update?: LogEntryUpdateWithWhereUniqueWithoutAssigneesInput | LogEntryUpdateWithWhereUniqueWithoutAssigneesInput[]
    updateMany?: LogEntryUpdateManyWithWhereWithoutAssigneesInput | LogEntryUpdateManyWithWhereWithoutAssigneesInput[]
    deleteMany?: LogEntryScalarWhereInput | LogEntryScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type SignatureUpdateManyWithoutSignerNestedInput = {
    create?: XOR<SignatureCreateWithoutSignerInput, SignatureUncheckedCreateWithoutSignerInput> | SignatureCreateWithoutSignerInput[] | SignatureUncheckedCreateWithoutSignerInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutSignerInput | SignatureCreateOrConnectWithoutSignerInput[]
    upsert?: SignatureUpsertWithWhereUniqueWithoutSignerInput | SignatureUpsertWithWhereUniqueWithoutSignerInput[]
    createMany?: SignatureCreateManySignerInputEnvelope
    set?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    disconnect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    delete?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    update?: SignatureUpdateWithWhereUniqueWithoutSignerInput | SignatureUpdateWithWhereUniqueWithoutSignerInput[]
    updateMany?: SignatureUpdateManyWithWhereWithoutSignerInput | SignatureUpdateManyWithWhereWithoutSignerInput[]
    deleteMany?: SignatureScalarWhereInput | SignatureScalarWhereInput[]
  }

  export type CommunicationUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<CommunicationCreateWithoutUploaderInput, CommunicationUncheckedCreateWithoutUploaderInput> | CommunicationCreateWithoutUploaderInput[] | CommunicationUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutUploaderInput | CommunicationCreateOrConnectWithoutUploaderInput[]
    upsert?: CommunicationUpsertWithWhereUniqueWithoutUploaderInput | CommunicationUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: CommunicationCreateManyUploaderInputEnvelope
    set?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    disconnect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    delete?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    update?: CommunicationUpdateWithWhereUniqueWithoutUploaderInput | CommunicationUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: CommunicationUpdateManyWithWhereWithoutUploaderInput | CommunicationUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
  }

  export type CommunicationStatusHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommunicationStatusHistoryCreateWithoutUserInput, CommunicationStatusHistoryUncheckedCreateWithoutUserInput> | CommunicationStatusHistoryCreateWithoutUserInput[] | CommunicationStatusHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunicationStatusHistoryCreateOrConnectWithoutUserInput | CommunicationStatusHistoryCreateOrConnectWithoutUserInput[]
    upsert?: CommunicationStatusHistoryUpsertWithWhereUniqueWithoutUserInput | CommunicationStatusHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommunicationStatusHistoryCreateManyUserInputEnvelope
    set?: CommunicationStatusHistoryWhereUniqueInput | CommunicationStatusHistoryWhereUniqueInput[]
    disconnect?: CommunicationStatusHistoryWhereUniqueInput | CommunicationStatusHistoryWhereUniqueInput[]
    delete?: CommunicationStatusHistoryWhereUniqueInput | CommunicationStatusHistoryWhereUniqueInput[]
    connect?: CommunicationStatusHistoryWhereUniqueInput | CommunicationStatusHistoryWhereUniqueInput[]
    update?: CommunicationStatusHistoryUpdateWithWhereUniqueWithoutUserInput | CommunicationStatusHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommunicationStatusHistoryUpdateManyWithWhereWithoutUserInput | CommunicationStatusHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommunicationStatusHistoryScalarWhereInput | CommunicationStatusHistoryScalarWhereInput[]
  }

  export type PhotoEntryUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PhotoEntryCreateWithoutAuthorInput, PhotoEntryUncheckedCreateWithoutAuthorInput> | PhotoEntryCreateWithoutAuthorInput[] | PhotoEntryUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PhotoEntryCreateOrConnectWithoutAuthorInput | PhotoEntryCreateOrConnectWithoutAuthorInput[]
    upsert?: PhotoEntryUpsertWithWhereUniqueWithoutAuthorInput | PhotoEntryUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PhotoEntryCreateManyAuthorInputEnvelope
    set?: PhotoEntryWhereUniqueInput | PhotoEntryWhereUniqueInput[]
    disconnect?: PhotoEntryWhereUniqueInput | PhotoEntryWhereUniqueInput[]
    delete?: PhotoEntryWhereUniqueInput | PhotoEntryWhereUniqueInput[]
    connect?: PhotoEntryWhereUniqueInput | PhotoEntryWhereUniqueInput[]
    update?: PhotoEntryUpdateWithWhereUniqueWithoutAuthorInput | PhotoEntryUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PhotoEntryUpdateManyWithWhereWithoutAuthorInput | PhotoEntryUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PhotoEntryScalarWhereInput | PhotoEntryScalarWhereInput[]
  }

  export type CommitmentUpdateManyWithoutResponsibleNestedInput = {
    create?: XOR<CommitmentCreateWithoutResponsibleInput, CommitmentUncheckedCreateWithoutResponsibleInput> | CommitmentCreateWithoutResponsibleInput[] | CommitmentUncheckedCreateWithoutResponsibleInput[]
    connectOrCreate?: CommitmentCreateOrConnectWithoutResponsibleInput | CommitmentCreateOrConnectWithoutResponsibleInput[]
    upsert?: CommitmentUpsertWithWhereUniqueWithoutResponsibleInput | CommitmentUpsertWithWhereUniqueWithoutResponsibleInput[]
    createMany?: CommitmentCreateManyResponsibleInputEnvelope
    set?: CommitmentWhereUniqueInput | CommitmentWhereUniqueInput[]
    disconnect?: CommitmentWhereUniqueInput | CommitmentWhereUniqueInput[]
    delete?: CommitmentWhereUniqueInput | CommitmentWhereUniqueInput[]
    connect?: CommitmentWhereUniqueInput | CommitmentWhereUniqueInput[]
    update?: CommitmentUpdateWithWhereUniqueWithoutResponsibleInput | CommitmentUpdateWithWhereUniqueWithoutResponsibleInput[]
    updateMany?: CommitmentUpdateManyWithWhereWithoutResponsibleInput | CommitmentUpdateManyWithWhereWithoutResponsibleInput[]
    deleteMany?: CommitmentScalarWhereInput | CommitmentScalarWhereInput[]
  }

  export type ObservationUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ObservationCreateWithoutAuthorInput, ObservationUncheckedCreateWithoutAuthorInput> | ObservationCreateWithoutAuthorInput[] | ObservationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ObservationCreateOrConnectWithoutAuthorInput | ObservationCreateOrConnectWithoutAuthorInput[]
    upsert?: ObservationUpsertWithWhereUniqueWithoutAuthorInput | ObservationUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ObservationCreateManyAuthorInputEnvelope
    set?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    disconnect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    delete?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    connect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    update?: ObservationUpdateWithWhereUniqueWithoutAuthorInput | ObservationUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ObservationUpdateManyWithWhereWithoutAuthorInput | ObservationUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ObservationScalarWhereInput | ObservationScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ReportCreateWithoutAuthorInput, ReportUncheckedCreateWithoutAuthorInput> | ReportCreateWithoutAuthorInput[] | ReportUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAuthorInput | ReportCreateOrConnectWithoutAuthorInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutAuthorInput | ReportUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ReportCreateManyAuthorInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutAuthorInput | ReportUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutAuthorInput | ReportUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type DrawingVersionUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<DrawingVersionCreateWithoutUploaderInput, DrawingVersionUncheckedCreateWithoutUploaderInput> | DrawingVersionCreateWithoutUploaderInput[] | DrawingVersionUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DrawingVersionCreateOrConnectWithoutUploaderInput | DrawingVersionCreateOrConnectWithoutUploaderInput[]
    upsert?: DrawingVersionUpsertWithWhereUniqueWithoutUploaderInput | DrawingVersionUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: DrawingVersionCreateManyUploaderInputEnvelope
    set?: DrawingVersionWhereUniqueInput | DrawingVersionWhereUniqueInput[]
    disconnect?: DrawingVersionWhereUniqueInput | DrawingVersionWhereUniqueInput[]
    delete?: DrawingVersionWhereUniqueInput | DrawingVersionWhereUniqueInput[]
    connect?: DrawingVersionWhereUniqueInput | DrawingVersionWhereUniqueInput[]
    update?: DrawingVersionUpdateWithWhereUniqueWithoutUploaderInput | DrawingVersionUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: DrawingVersionUpdateManyWithWhereWithoutUploaderInput | DrawingVersionUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: DrawingVersionScalarWhereInput | DrawingVersionScalarWhereInput[]
  }

  export type LogEntryHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogEntryHistoryCreateWithoutUserInput, LogEntryHistoryUncheckedCreateWithoutUserInput> | LogEntryHistoryCreateWithoutUserInput[] | LogEntryHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogEntryHistoryCreateOrConnectWithoutUserInput | LogEntryHistoryCreateOrConnectWithoutUserInput[]
    upsert?: LogEntryHistoryUpsertWithWhereUniqueWithoutUserInput | LogEntryHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogEntryHistoryCreateManyUserInputEnvelope
    set?: LogEntryHistoryWhereUniqueInput | LogEntryHistoryWhereUniqueInput[]
    disconnect?: LogEntryHistoryWhereUniqueInput | LogEntryHistoryWhereUniqueInput[]
    delete?: LogEntryHistoryWhereUniqueInput | LogEntryHistoryWhereUniqueInput[]
    connect?: LogEntryHistoryWhereUniqueInput | LogEntryHistoryWhereUniqueInput[]
    update?: LogEntryHistoryUpdateWithWhereUniqueWithoutUserInput | LogEntryHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogEntryHistoryUpdateManyWithWhereWithoutUserInput | LogEntryHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogEntryHistoryScalarWhereInput | LogEntryHistoryScalarWhereInput[]
  }

  export type LogEntryUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<LogEntryCreateWithoutAuthorInput, LogEntryUncheckedCreateWithoutAuthorInput> | LogEntryCreateWithoutAuthorInput[] | LogEntryUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: LogEntryCreateOrConnectWithoutAuthorInput | LogEntryCreateOrConnectWithoutAuthorInput[]
    upsert?: LogEntryUpsertWithWhereUniqueWithoutAuthorInput | LogEntryUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: LogEntryCreateManyAuthorInputEnvelope
    set?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    disconnect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    delete?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    connect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    update?: LogEntryUpdateWithWhereUniqueWithoutAuthorInput | LogEntryUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: LogEntryUpdateManyWithWhereWithoutAuthorInput | LogEntryUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: LogEntryScalarWhereInput | LogEntryScalarWhereInput[]
  }

  export type LogEntryUncheckedUpdateManyWithoutAssigneesNestedInput = {
    create?: XOR<LogEntryCreateWithoutAssigneesInput, LogEntryUncheckedCreateWithoutAssigneesInput> | LogEntryCreateWithoutAssigneesInput[] | LogEntryUncheckedCreateWithoutAssigneesInput[]
    connectOrCreate?: LogEntryCreateOrConnectWithoutAssigneesInput | LogEntryCreateOrConnectWithoutAssigneesInput[]
    upsert?: LogEntryUpsertWithWhereUniqueWithoutAssigneesInput | LogEntryUpsertWithWhereUniqueWithoutAssigneesInput[]
    set?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    disconnect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    delete?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    connect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    update?: LogEntryUpdateWithWhereUniqueWithoutAssigneesInput | LogEntryUpdateWithWhereUniqueWithoutAssigneesInput[]
    updateMany?: LogEntryUpdateManyWithWhereWithoutAssigneesInput | LogEntryUpdateManyWithWhereWithoutAssigneesInput[]
    deleteMany?: LogEntryScalarWhereInput | LogEntryScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type SignatureUncheckedUpdateManyWithoutSignerNestedInput = {
    create?: XOR<SignatureCreateWithoutSignerInput, SignatureUncheckedCreateWithoutSignerInput> | SignatureCreateWithoutSignerInput[] | SignatureUncheckedCreateWithoutSignerInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutSignerInput | SignatureCreateOrConnectWithoutSignerInput[]
    upsert?: SignatureUpsertWithWhereUniqueWithoutSignerInput | SignatureUpsertWithWhereUniqueWithoutSignerInput[]
    createMany?: SignatureCreateManySignerInputEnvelope
    set?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    disconnect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    delete?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    update?: SignatureUpdateWithWhereUniqueWithoutSignerInput | SignatureUpdateWithWhereUniqueWithoutSignerInput[]
    updateMany?: SignatureUpdateManyWithWhereWithoutSignerInput | SignatureUpdateManyWithWhereWithoutSignerInput[]
    deleteMany?: SignatureScalarWhereInput | SignatureScalarWhereInput[]
  }

  export type CommunicationUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<CommunicationCreateWithoutUploaderInput, CommunicationUncheckedCreateWithoutUploaderInput> | CommunicationCreateWithoutUploaderInput[] | CommunicationUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutUploaderInput | CommunicationCreateOrConnectWithoutUploaderInput[]
    upsert?: CommunicationUpsertWithWhereUniqueWithoutUploaderInput | CommunicationUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: CommunicationCreateManyUploaderInputEnvelope
    set?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    disconnect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    delete?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    update?: CommunicationUpdateWithWhereUniqueWithoutUploaderInput | CommunicationUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: CommunicationUpdateManyWithWhereWithoutUploaderInput | CommunicationUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
  }

  export type CommunicationStatusHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommunicationStatusHistoryCreateWithoutUserInput, CommunicationStatusHistoryUncheckedCreateWithoutUserInput> | CommunicationStatusHistoryCreateWithoutUserInput[] | CommunicationStatusHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunicationStatusHistoryCreateOrConnectWithoutUserInput | CommunicationStatusHistoryCreateOrConnectWithoutUserInput[]
    upsert?: CommunicationStatusHistoryUpsertWithWhereUniqueWithoutUserInput | CommunicationStatusHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommunicationStatusHistoryCreateManyUserInputEnvelope
    set?: CommunicationStatusHistoryWhereUniqueInput | CommunicationStatusHistoryWhereUniqueInput[]
    disconnect?: CommunicationStatusHistoryWhereUniqueInput | CommunicationStatusHistoryWhereUniqueInput[]
    delete?: CommunicationStatusHistoryWhereUniqueInput | CommunicationStatusHistoryWhereUniqueInput[]
    connect?: CommunicationStatusHistoryWhereUniqueInput | CommunicationStatusHistoryWhereUniqueInput[]
    update?: CommunicationStatusHistoryUpdateWithWhereUniqueWithoutUserInput | CommunicationStatusHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommunicationStatusHistoryUpdateManyWithWhereWithoutUserInput | CommunicationStatusHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommunicationStatusHistoryScalarWhereInput | CommunicationStatusHistoryScalarWhereInput[]
  }

  export type PhotoEntryUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PhotoEntryCreateWithoutAuthorInput, PhotoEntryUncheckedCreateWithoutAuthorInput> | PhotoEntryCreateWithoutAuthorInput[] | PhotoEntryUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PhotoEntryCreateOrConnectWithoutAuthorInput | PhotoEntryCreateOrConnectWithoutAuthorInput[]
    upsert?: PhotoEntryUpsertWithWhereUniqueWithoutAuthorInput | PhotoEntryUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PhotoEntryCreateManyAuthorInputEnvelope
    set?: PhotoEntryWhereUniqueInput | PhotoEntryWhereUniqueInput[]
    disconnect?: PhotoEntryWhereUniqueInput | PhotoEntryWhereUniqueInput[]
    delete?: PhotoEntryWhereUniqueInput | PhotoEntryWhereUniqueInput[]
    connect?: PhotoEntryWhereUniqueInput | PhotoEntryWhereUniqueInput[]
    update?: PhotoEntryUpdateWithWhereUniqueWithoutAuthorInput | PhotoEntryUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PhotoEntryUpdateManyWithWhereWithoutAuthorInput | PhotoEntryUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PhotoEntryScalarWhereInput | PhotoEntryScalarWhereInput[]
  }

  export type CommitmentUncheckedUpdateManyWithoutResponsibleNestedInput = {
    create?: XOR<CommitmentCreateWithoutResponsibleInput, CommitmentUncheckedCreateWithoutResponsibleInput> | CommitmentCreateWithoutResponsibleInput[] | CommitmentUncheckedCreateWithoutResponsibleInput[]
    connectOrCreate?: CommitmentCreateOrConnectWithoutResponsibleInput | CommitmentCreateOrConnectWithoutResponsibleInput[]
    upsert?: CommitmentUpsertWithWhereUniqueWithoutResponsibleInput | CommitmentUpsertWithWhereUniqueWithoutResponsibleInput[]
    createMany?: CommitmentCreateManyResponsibleInputEnvelope
    set?: CommitmentWhereUniqueInput | CommitmentWhereUniqueInput[]
    disconnect?: CommitmentWhereUniqueInput | CommitmentWhereUniqueInput[]
    delete?: CommitmentWhereUniqueInput | CommitmentWhereUniqueInput[]
    connect?: CommitmentWhereUniqueInput | CommitmentWhereUniqueInput[]
    update?: CommitmentUpdateWithWhereUniqueWithoutResponsibleInput | CommitmentUpdateWithWhereUniqueWithoutResponsibleInput[]
    updateMany?: CommitmentUpdateManyWithWhereWithoutResponsibleInput | CommitmentUpdateManyWithWhereWithoutResponsibleInput[]
    deleteMany?: CommitmentScalarWhereInput | CommitmentScalarWhereInput[]
  }

  export type ObservationUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ObservationCreateWithoutAuthorInput, ObservationUncheckedCreateWithoutAuthorInput> | ObservationCreateWithoutAuthorInput[] | ObservationUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ObservationCreateOrConnectWithoutAuthorInput | ObservationCreateOrConnectWithoutAuthorInput[]
    upsert?: ObservationUpsertWithWhereUniqueWithoutAuthorInput | ObservationUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ObservationCreateManyAuthorInputEnvelope
    set?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    disconnect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    delete?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    connect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    update?: ObservationUpdateWithWhereUniqueWithoutAuthorInput | ObservationUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ObservationUpdateManyWithWhereWithoutAuthorInput | ObservationUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ObservationScalarWhereInput | ObservationScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ReportCreateWithoutAuthorInput, ReportUncheckedCreateWithoutAuthorInput> | ReportCreateWithoutAuthorInput[] | ReportUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutAuthorInput | ReportCreateOrConnectWithoutAuthorInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutAuthorInput | ReportUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ReportCreateManyAuthorInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutAuthorInput | ReportUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutAuthorInput | ReportUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type DrawingVersionUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<DrawingVersionCreateWithoutUploaderInput, DrawingVersionUncheckedCreateWithoutUploaderInput> | DrawingVersionCreateWithoutUploaderInput[] | DrawingVersionUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DrawingVersionCreateOrConnectWithoutUploaderInput | DrawingVersionCreateOrConnectWithoutUploaderInput[]
    upsert?: DrawingVersionUpsertWithWhereUniqueWithoutUploaderInput | DrawingVersionUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: DrawingVersionCreateManyUploaderInputEnvelope
    set?: DrawingVersionWhereUniqueInput | DrawingVersionWhereUniqueInput[]
    disconnect?: DrawingVersionWhereUniqueInput | DrawingVersionWhereUniqueInput[]
    delete?: DrawingVersionWhereUniqueInput | DrawingVersionWhereUniqueInput[]
    connect?: DrawingVersionWhereUniqueInput | DrawingVersionWhereUniqueInput[]
    update?: DrawingVersionUpdateWithWhereUniqueWithoutUploaderInput | DrawingVersionUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: DrawingVersionUpdateManyWithWhereWithoutUploaderInput | DrawingVersionUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: DrawingVersionScalarWhereInput | DrawingVersionScalarWhereInput[]
  }

  export type LogEntryHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LogEntryHistoryCreateWithoutUserInput, LogEntryHistoryUncheckedCreateWithoutUserInput> | LogEntryHistoryCreateWithoutUserInput[] | LogEntryHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LogEntryHistoryCreateOrConnectWithoutUserInput | LogEntryHistoryCreateOrConnectWithoutUserInput[]
    upsert?: LogEntryHistoryUpsertWithWhereUniqueWithoutUserInput | LogEntryHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LogEntryHistoryCreateManyUserInputEnvelope
    set?: LogEntryHistoryWhereUniqueInput | LogEntryHistoryWhereUniqueInput[]
    disconnect?: LogEntryHistoryWhereUniqueInput | LogEntryHistoryWhereUniqueInput[]
    delete?: LogEntryHistoryWhereUniqueInput | LogEntryHistoryWhereUniqueInput[]
    connect?: LogEntryHistoryWhereUniqueInput | LogEntryHistoryWhereUniqueInput[]
    update?: LogEntryHistoryUpdateWithWhereUniqueWithoutUserInput | LogEntryHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LogEntryHistoryUpdateManyWithWhereWithoutUserInput | LogEntryHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LogEntryHistoryScalarWhereInput | LogEntryHistoryScalarWhereInput[]
  }

  export type KeyPersonnelCreateNestedManyWithoutProjectInput = {
    create?: XOR<KeyPersonnelCreateWithoutProjectInput, KeyPersonnelUncheckedCreateWithoutProjectInput> | KeyPersonnelCreateWithoutProjectInput[] | KeyPersonnelUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: KeyPersonnelCreateOrConnectWithoutProjectInput | KeyPersonnelCreateOrConnectWithoutProjectInput[]
    createMany?: KeyPersonnelCreateManyProjectInputEnvelope
    connect?: KeyPersonnelWhereUniqueInput | KeyPersonnelWhereUniqueInput[]
  }

  export type LogEntryCreateNestedManyWithoutProjectInput = {
    create?: XOR<LogEntryCreateWithoutProjectInput, LogEntryUncheckedCreateWithoutProjectInput> | LogEntryCreateWithoutProjectInput[] | LogEntryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LogEntryCreateOrConnectWithoutProjectInput | LogEntryCreateOrConnectWithoutProjectInput[]
    createMany?: LogEntryCreateManyProjectInputEnvelope
    connect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
  }

  export type KeyPersonnelUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<KeyPersonnelCreateWithoutProjectInput, KeyPersonnelUncheckedCreateWithoutProjectInput> | KeyPersonnelCreateWithoutProjectInput[] | KeyPersonnelUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: KeyPersonnelCreateOrConnectWithoutProjectInput | KeyPersonnelCreateOrConnectWithoutProjectInput[]
    createMany?: KeyPersonnelCreateManyProjectInputEnvelope
    connect?: KeyPersonnelWhereUniqueInput | KeyPersonnelWhereUniqueInput[]
  }

  export type LogEntryUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<LogEntryCreateWithoutProjectInput, LogEntryUncheckedCreateWithoutProjectInput> | LogEntryCreateWithoutProjectInput[] | LogEntryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LogEntryCreateOrConnectWithoutProjectInput | LogEntryCreateOrConnectWithoutProjectInput[]
    createMany?: LogEntryCreateManyProjectInputEnvelope
    connect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type KeyPersonnelUpdateManyWithoutProjectNestedInput = {
    create?: XOR<KeyPersonnelCreateWithoutProjectInput, KeyPersonnelUncheckedCreateWithoutProjectInput> | KeyPersonnelCreateWithoutProjectInput[] | KeyPersonnelUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: KeyPersonnelCreateOrConnectWithoutProjectInput | KeyPersonnelCreateOrConnectWithoutProjectInput[]
    upsert?: KeyPersonnelUpsertWithWhereUniqueWithoutProjectInput | KeyPersonnelUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: KeyPersonnelCreateManyProjectInputEnvelope
    set?: KeyPersonnelWhereUniqueInput | KeyPersonnelWhereUniqueInput[]
    disconnect?: KeyPersonnelWhereUniqueInput | KeyPersonnelWhereUniqueInput[]
    delete?: KeyPersonnelWhereUniqueInput | KeyPersonnelWhereUniqueInput[]
    connect?: KeyPersonnelWhereUniqueInput | KeyPersonnelWhereUniqueInput[]
    update?: KeyPersonnelUpdateWithWhereUniqueWithoutProjectInput | KeyPersonnelUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: KeyPersonnelUpdateManyWithWhereWithoutProjectInput | KeyPersonnelUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: KeyPersonnelScalarWhereInput | KeyPersonnelScalarWhereInput[]
  }

  export type LogEntryUpdateManyWithoutProjectNestedInput = {
    create?: XOR<LogEntryCreateWithoutProjectInput, LogEntryUncheckedCreateWithoutProjectInput> | LogEntryCreateWithoutProjectInput[] | LogEntryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LogEntryCreateOrConnectWithoutProjectInput | LogEntryCreateOrConnectWithoutProjectInput[]
    upsert?: LogEntryUpsertWithWhereUniqueWithoutProjectInput | LogEntryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: LogEntryCreateManyProjectInputEnvelope
    set?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    disconnect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    delete?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    connect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    update?: LogEntryUpdateWithWhereUniqueWithoutProjectInput | LogEntryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: LogEntryUpdateManyWithWhereWithoutProjectInput | LogEntryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: LogEntryScalarWhereInput | LogEntryScalarWhereInput[]
  }

  export type KeyPersonnelUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<KeyPersonnelCreateWithoutProjectInput, KeyPersonnelUncheckedCreateWithoutProjectInput> | KeyPersonnelCreateWithoutProjectInput[] | KeyPersonnelUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: KeyPersonnelCreateOrConnectWithoutProjectInput | KeyPersonnelCreateOrConnectWithoutProjectInput[]
    upsert?: KeyPersonnelUpsertWithWhereUniqueWithoutProjectInput | KeyPersonnelUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: KeyPersonnelCreateManyProjectInputEnvelope
    set?: KeyPersonnelWhereUniqueInput | KeyPersonnelWhereUniqueInput[]
    disconnect?: KeyPersonnelWhereUniqueInput | KeyPersonnelWhereUniqueInput[]
    delete?: KeyPersonnelWhereUniqueInput | KeyPersonnelWhereUniqueInput[]
    connect?: KeyPersonnelWhereUniqueInput | KeyPersonnelWhereUniqueInput[]
    update?: KeyPersonnelUpdateWithWhereUniqueWithoutProjectInput | KeyPersonnelUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: KeyPersonnelUpdateManyWithWhereWithoutProjectInput | KeyPersonnelUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: KeyPersonnelScalarWhereInput | KeyPersonnelScalarWhereInput[]
  }

  export type LogEntryUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<LogEntryCreateWithoutProjectInput, LogEntryUncheckedCreateWithoutProjectInput> | LogEntryCreateWithoutProjectInput[] | LogEntryUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LogEntryCreateOrConnectWithoutProjectInput | LogEntryCreateOrConnectWithoutProjectInput[]
    upsert?: LogEntryUpsertWithWhereUniqueWithoutProjectInput | LogEntryUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: LogEntryCreateManyProjectInputEnvelope
    set?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    disconnect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    delete?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    connect?: LogEntryWhereUniqueInput | LogEntryWhereUniqueInput[]
    update?: LogEntryUpdateWithWhereUniqueWithoutProjectInput | LogEntryUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: LogEntryUpdateManyWithWhereWithoutProjectInput | LogEntryUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: LogEntryScalarWhereInput | LogEntryScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutKeyPersonnelInput = {
    create?: XOR<ProjectCreateWithoutKeyPersonnelInput, ProjectUncheckedCreateWithoutKeyPersonnelInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutKeyPersonnelInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutKeyPersonnelNestedInput = {
    create?: XOR<ProjectCreateWithoutKeyPersonnelInput, ProjectUncheckedCreateWithoutKeyPersonnelInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutKeyPersonnelInput
    upsert?: ProjectUpsertWithoutKeyPersonnelInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutKeyPersonnelInput, ProjectUpdateWithoutKeyPersonnelInput>, ProjectUncheckedUpdateWithoutKeyPersonnelInput>
  }

  export type UserCreateNestedOneWithoutCommunicationsInput = {
    create?: XOR<UserCreateWithoutCommunicationsInput, UserUncheckedCreateWithoutCommunicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunicationsInput
    connect?: UserWhereUniqueInput
  }

  export type CommunicationCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommunicationCreateWithoutRepliesInput, CommunicationUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommunicationCreateOrConnectWithoutRepliesInput
    connect?: CommunicationWhereUniqueInput
  }

  export type CommunicationCreateNestedManyWithoutParentInput = {
    create?: XOR<CommunicationCreateWithoutParentInput, CommunicationUncheckedCreateWithoutParentInput> | CommunicationCreateWithoutParentInput[] | CommunicationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutParentInput | CommunicationCreateOrConnectWithoutParentInput[]
    createMany?: CommunicationCreateManyParentInputEnvelope
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
  }

  export type CommunicationStatusHistoryCreateNestedManyWithoutCommunicationInput = {
    create?: XOR<CommunicationStatusHistoryCreateWithoutCommunicationInput, CommunicationStatusHistoryUncheckedCreateWithoutCommunicationInput> | CommunicationStatusHistoryCreateWithoutCommunicationInput[] | CommunicationStatusHistoryUncheckedCreateWithoutCommunicationInput[]
    connectOrCreate?: CommunicationStatusHistoryCreateOrConnectWithoutCommunicationInput | CommunicationStatusHistoryCreateOrConnectWithoutCommunicationInput[]
    createMany?: CommunicationStatusHistoryCreateManyCommunicationInputEnvelope
    connect?: CommunicationStatusHistoryWhereUniqueInput | CommunicationStatusHistoryWhereUniqueInput[]
  }

  export type AttachmentCreateNestedManyWithoutCommunicationInput = {
    create?: XOR<AttachmentCreateWithoutCommunicationInput, AttachmentUncheckedCreateWithoutCommunicationInput> | AttachmentCreateWithoutCommunicationInput[] | AttachmentUncheckedCreateWithoutCommunicationInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutCommunicationInput | AttachmentCreateOrConnectWithoutCommunicationInput[]
    createMany?: AttachmentCreateManyCommunicationInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type CommunicationUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CommunicationCreateWithoutParentInput, CommunicationUncheckedCreateWithoutParentInput> | CommunicationCreateWithoutParentInput[] | CommunicationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutParentInput | CommunicationCreateOrConnectWithoutParentInput[]
    createMany?: CommunicationCreateManyParentInputEnvelope
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
  }

  export type CommunicationStatusHistoryUncheckedCreateNestedManyWithoutCommunicationInput = {
    create?: XOR<CommunicationStatusHistoryCreateWithoutCommunicationInput, CommunicationStatusHistoryUncheckedCreateWithoutCommunicationInput> | CommunicationStatusHistoryCreateWithoutCommunicationInput[] | CommunicationStatusHistoryUncheckedCreateWithoutCommunicationInput[]
    connectOrCreate?: CommunicationStatusHistoryCreateOrConnectWithoutCommunicationInput | CommunicationStatusHistoryCreateOrConnectWithoutCommunicationInput[]
    createMany?: CommunicationStatusHistoryCreateManyCommunicationInputEnvelope
    connect?: CommunicationStatusHistoryWhereUniqueInput | CommunicationStatusHistoryWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutCommunicationInput = {
    create?: XOR<AttachmentCreateWithoutCommunicationInput, AttachmentUncheckedCreateWithoutCommunicationInput> | AttachmentCreateWithoutCommunicationInput[] | AttachmentUncheckedCreateWithoutCommunicationInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutCommunicationInput | AttachmentCreateOrConnectWithoutCommunicationInput[]
    createMany?: AttachmentCreateManyCommunicationInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type EnumDeliveryMethodFieldUpdateOperationsInput = {
    set?: $Enums.DeliveryMethod
  }

  export type EnumCommunicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.CommunicationStatus
  }

  export type UserUpdateOneRequiredWithoutCommunicationsNestedInput = {
    create?: XOR<UserCreateWithoutCommunicationsInput, UserUncheckedCreateWithoutCommunicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunicationsInput
    upsert?: UserUpsertWithoutCommunicationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommunicationsInput, UserUpdateWithoutCommunicationsInput>, UserUncheckedUpdateWithoutCommunicationsInput>
  }

  export type CommunicationUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<CommunicationCreateWithoutRepliesInput, CommunicationUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommunicationCreateOrConnectWithoutRepliesInput
    upsert?: CommunicationUpsertWithoutRepliesInput
    disconnect?: CommunicationWhereInput | boolean
    delete?: CommunicationWhereInput | boolean
    connect?: CommunicationWhereUniqueInput
    update?: XOR<XOR<CommunicationUpdateToOneWithWhereWithoutRepliesInput, CommunicationUpdateWithoutRepliesInput>, CommunicationUncheckedUpdateWithoutRepliesInput>
  }

  export type CommunicationUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommunicationCreateWithoutParentInput, CommunicationUncheckedCreateWithoutParentInput> | CommunicationCreateWithoutParentInput[] | CommunicationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutParentInput | CommunicationCreateOrConnectWithoutParentInput[]
    upsert?: CommunicationUpsertWithWhereUniqueWithoutParentInput | CommunicationUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommunicationCreateManyParentInputEnvelope
    set?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    disconnect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    delete?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    update?: CommunicationUpdateWithWhereUniqueWithoutParentInput | CommunicationUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommunicationUpdateManyWithWhereWithoutParentInput | CommunicationUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
  }

  export type CommunicationStatusHistoryUpdateManyWithoutCommunicationNestedInput = {
    create?: XOR<CommunicationStatusHistoryCreateWithoutCommunicationInput, CommunicationStatusHistoryUncheckedCreateWithoutCommunicationInput> | CommunicationStatusHistoryCreateWithoutCommunicationInput[] | CommunicationStatusHistoryUncheckedCreateWithoutCommunicationInput[]
    connectOrCreate?: CommunicationStatusHistoryCreateOrConnectWithoutCommunicationInput | CommunicationStatusHistoryCreateOrConnectWithoutCommunicationInput[]
    upsert?: CommunicationStatusHistoryUpsertWithWhereUniqueWithoutCommunicationInput | CommunicationStatusHistoryUpsertWithWhereUniqueWithoutCommunicationInput[]
    createMany?: CommunicationStatusHistoryCreateManyCommunicationInputEnvelope
    set?: CommunicationStatusHistoryWhereUniqueInput | CommunicationStatusHistoryWhereUniqueInput[]
    disconnect?: CommunicationStatusHistoryWhereUniqueInput | CommunicationStatusHistoryWhereUniqueInput[]
    delete?: CommunicationStatusHistoryWhereUniqueInput | CommunicationStatusHistoryWhereUniqueInput[]
    connect?: CommunicationStatusHistoryWhereUniqueInput | CommunicationStatusHistoryWhereUniqueInput[]
    update?: CommunicationStatusHistoryUpdateWithWhereUniqueWithoutCommunicationInput | CommunicationStatusHistoryUpdateWithWhereUniqueWithoutCommunicationInput[]
    updateMany?: CommunicationStatusHistoryUpdateManyWithWhereWithoutCommunicationInput | CommunicationStatusHistoryUpdateManyWithWhereWithoutCommunicationInput[]
    deleteMany?: CommunicationStatusHistoryScalarWhereInput | CommunicationStatusHistoryScalarWhereInput[]
  }

  export type AttachmentUpdateManyWithoutCommunicationNestedInput = {
    create?: XOR<AttachmentCreateWithoutCommunicationInput, AttachmentUncheckedCreateWithoutCommunicationInput> | AttachmentCreateWithoutCommunicationInput[] | AttachmentUncheckedCreateWithoutCommunicationInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutCommunicationInput | AttachmentCreateOrConnectWithoutCommunicationInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutCommunicationInput | AttachmentUpsertWithWhereUniqueWithoutCommunicationInput[]
    createMany?: AttachmentCreateManyCommunicationInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutCommunicationInput | AttachmentUpdateWithWhereUniqueWithoutCommunicationInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutCommunicationInput | AttachmentUpdateManyWithWhereWithoutCommunicationInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type CommunicationUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommunicationCreateWithoutParentInput, CommunicationUncheckedCreateWithoutParentInput> | CommunicationCreateWithoutParentInput[] | CommunicationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommunicationCreateOrConnectWithoutParentInput | CommunicationCreateOrConnectWithoutParentInput[]
    upsert?: CommunicationUpsertWithWhereUniqueWithoutParentInput | CommunicationUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommunicationCreateManyParentInputEnvelope
    set?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    disconnect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    delete?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    connect?: CommunicationWhereUniqueInput | CommunicationWhereUniqueInput[]
    update?: CommunicationUpdateWithWhereUniqueWithoutParentInput | CommunicationUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommunicationUpdateManyWithWhereWithoutParentInput | CommunicationUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
  }

  export type CommunicationStatusHistoryUncheckedUpdateManyWithoutCommunicationNestedInput = {
    create?: XOR<CommunicationStatusHistoryCreateWithoutCommunicationInput, CommunicationStatusHistoryUncheckedCreateWithoutCommunicationInput> | CommunicationStatusHistoryCreateWithoutCommunicationInput[] | CommunicationStatusHistoryUncheckedCreateWithoutCommunicationInput[]
    connectOrCreate?: CommunicationStatusHistoryCreateOrConnectWithoutCommunicationInput | CommunicationStatusHistoryCreateOrConnectWithoutCommunicationInput[]
    upsert?: CommunicationStatusHistoryUpsertWithWhereUniqueWithoutCommunicationInput | CommunicationStatusHistoryUpsertWithWhereUniqueWithoutCommunicationInput[]
    createMany?: CommunicationStatusHistoryCreateManyCommunicationInputEnvelope
    set?: CommunicationStatusHistoryWhereUniqueInput | CommunicationStatusHistoryWhereUniqueInput[]
    disconnect?: CommunicationStatusHistoryWhereUniqueInput | CommunicationStatusHistoryWhereUniqueInput[]
    delete?: CommunicationStatusHistoryWhereUniqueInput | CommunicationStatusHistoryWhereUniqueInput[]
    connect?: CommunicationStatusHistoryWhereUniqueInput | CommunicationStatusHistoryWhereUniqueInput[]
    update?: CommunicationStatusHistoryUpdateWithWhereUniqueWithoutCommunicationInput | CommunicationStatusHistoryUpdateWithWhereUniqueWithoutCommunicationInput[]
    updateMany?: CommunicationStatusHistoryUpdateManyWithWhereWithoutCommunicationInput | CommunicationStatusHistoryUpdateManyWithWhereWithoutCommunicationInput[]
    deleteMany?: CommunicationStatusHistoryScalarWhereInput | CommunicationStatusHistoryScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutCommunicationNestedInput = {
    create?: XOR<AttachmentCreateWithoutCommunicationInput, AttachmentUncheckedCreateWithoutCommunicationInput> | AttachmentCreateWithoutCommunicationInput[] | AttachmentUncheckedCreateWithoutCommunicationInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutCommunicationInput | AttachmentCreateOrConnectWithoutCommunicationInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutCommunicationInput | AttachmentUpsertWithWhereUniqueWithoutCommunicationInput[]
    createMany?: AttachmentCreateManyCommunicationInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutCommunicationInput | AttachmentUpdateWithWhereUniqueWithoutCommunicationInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutCommunicationInput | AttachmentUpdateManyWithWhereWithoutCommunicationInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type CommunicationCreateNestedOneWithoutStatusHistoryInput = {
    create?: XOR<CommunicationCreateWithoutStatusHistoryInput, CommunicationUncheckedCreateWithoutStatusHistoryInput>
    connectOrCreate?: CommunicationCreateOrConnectWithoutStatusHistoryInput
    connect?: CommunicationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStatusChangesInput = {
    create?: XOR<UserCreateWithoutStatusChangesInput, UserUncheckedCreateWithoutStatusChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatusChangesInput
    connect?: UserWhereUniqueInput
  }

  export type CommunicationUpdateOneRequiredWithoutStatusHistoryNestedInput = {
    create?: XOR<CommunicationCreateWithoutStatusHistoryInput, CommunicationUncheckedCreateWithoutStatusHistoryInput>
    connectOrCreate?: CommunicationCreateOrConnectWithoutStatusHistoryInput
    upsert?: CommunicationUpsertWithoutStatusHistoryInput
    connect?: CommunicationWhereUniqueInput
    update?: XOR<XOR<CommunicationUpdateToOneWithWhereWithoutStatusHistoryInput, CommunicationUpdateWithoutStatusHistoryInput>, CommunicationUncheckedUpdateWithoutStatusHistoryInput>
  }

  export type UserUpdateOneRequiredWithoutStatusChangesNestedInput = {
    create?: XOR<UserCreateWithoutStatusChangesInput, UserUncheckedCreateWithoutStatusChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatusChangesInput
    upsert?: UserUpsertWithoutStatusChangesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStatusChangesInput, UserUpdateWithoutStatusChangesInput>, UserUncheckedUpdateWithoutStatusChangesInput>
  }

  export type AttachmentCreateNestedOneWithoutContractModInput = {
    create?: XOR<AttachmentCreateWithoutContractModInput, AttachmentUncheckedCreateWithoutContractModInput>
    connectOrCreate?: AttachmentCreateOrConnectWithoutContractModInput
    connect?: AttachmentWhereUniqueInput
  }

  export type EnumModificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.ModificationType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AttachmentUpdateOneWithoutContractModNestedInput = {
    create?: XOR<AttachmentCreateWithoutContractModInput, AttachmentUncheckedCreateWithoutContractModInput>
    connectOrCreate?: AttachmentCreateOrConnectWithoutContractModInput
    upsert?: AttachmentUpsertWithoutContractModInput
    disconnect?: AttachmentWhereInput | boolean
    delete?: AttachmentWhereInput | boolean
    connect?: AttachmentWhereUniqueInput
    update?: XOR<XOR<AttachmentUpdateToOneWithWhereWithoutContractModInput, AttachmentUpdateWithoutContractModInput>, AttachmentUncheckedUpdateWithoutContractModInput>
  }

  export type AttachmentCreateNestedManyWithoutWeeklyReportInput = {
    create?: XOR<AttachmentCreateWithoutWeeklyReportInput, AttachmentUncheckedCreateWithoutWeeklyReportInput> | AttachmentCreateWithoutWeeklyReportInput[] | AttachmentUncheckedCreateWithoutWeeklyReportInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutWeeklyReportInput | AttachmentCreateOrConnectWithoutWeeklyReportInput[]
    createMany?: AttachmentCreateManyWeeklyReportInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutWeeklyReportInput = {
    create?: XOR<AttachmentCreateWithoutWeeklyReportInput, AttachmentUncheckedCreateWithoutWeeklyReportInput> | AttachmentCreateWithoutWeeklyReportInput[] | AttachmentUncheckedCreateWithoutWeeklyReportInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutWeeklyReportInput | AttachmentCreateOrConnectWithoutWeeklyReportInput[]
    createMany?: AttachmentCreateManyWeeklyReportInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type AttachmentUpdateManyWithoutWeeklyReportNestedInput = {
    create?: XOR<AttachmentCreateWithoutWeeklyReportInput, AttachmentUncheckedCreateWithoutWeeklyReportInput> | AttachmentCreateWithoutWeeklyReportInput[] | AttachmentUncheckedCreateWithoutWeeklyReportInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutWeeklyReportInput | AttachmentCreateOrConnectWithoutWeeklyReportInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutWeeklyReportInput | AttachmentUpsertWithWhereUniqueWithoutWeeklyReportInput[]
    createMany?: AttachmentCreateManyWeeklyReportInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutWeeklyReportInput | AttachmentUpdateWithWhereUniqueWithoutWeeklyReportInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutWeeklyReportInput | AttachmentUpdateManyWithWhereWithoutWeeklyReportInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutWeeklyReportNestedInput = {
    create?: XOR<AttachmentCreateWithoutWeeklyReportInput, AttachmentUncheckedCreateWithoutWeeklyReportInput> | AttachmentCreateWithoutWeeklyReportInput[] | AttachmentUncheckedCreateWithoutWeeklyReportInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutWeeklyReportInput | AttachmentCreateOrConnectWithoutWeeklyReportInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutWeeklyReportInput | AttachmentUpsertWithWhereUniqueWithoutWeeklyReportInput[]
    createMany?: AttachmentCreateManyWeeklyReportInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutWeeklyReportInput | AttachmentUpdateWithWhereUniqueWithoutWeeklyReportInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutWeeklyReportInput | AttachmentUpdateManyWithWhereWithoutWeeklyReportInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLogEntriesInput = {
    create?: XOR<UserCreateWithoutLogEntriesInput, UserUncheckedCreateWithoutLogEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutLogEntriesInput = {
    create?: XOR<ProjectCreateWithoutLogEntriesInput, ProjectUncheckedCreateWithoutLogEntriesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLogEntriesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<UserCreateWithoutAssignedToInput, UserUncheckedCreateWithoutAssignedToInput> | UserCreateWithoutAssignedToInput[] | UserUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedToInput | UserCreateOrConnectWithoutAssignedToInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutLogEntryInput = {
    create?: XOR<CommentCreateWithoutLogEntryInput, CommentUncheckedCreateWithoutLogEntryInput> | CommentCreateWithoutLogEntryInput[] | CommentUncheckedCreateWithoutLogEntryInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutLogEntryInput | CommentCreateOrConnectWithoutLogEntryInput[]
    createMany?: CommentCreateManyLogEntryInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type AttachmentCreateNestedManyWithoutLogEntryInput = {
    create?: XOR<AttachmentCreateWithoutLogEntryInput, AttachmentUncheckedCreateWithoutLogEntryInput> | AttachmentCreateWithoutLogEntryInput[] | AttachmentUncheckedCreateWithoutLogEntryInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutLogEntryInput | AttachmentCreateOrConnectWithoutLogEntryInput[]
    createMany?: AttachmentCreateManyLogEntryInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type SignatureCreateNestedManyWithoutLogEntryInput = {
    create?: XOR<SignatureCreateWithoutLogEntryInput, SignatureUncheckedCreateWithoutLogEntryInput> | SignatureCreateWithoutLogEntryInput[] | SignatureUncheckedCreateWithoutLogEntryInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutLogEntryInput | SignatureCreateOrConnectWithoutLogEntryInput[]
    createMany?: SignatureCreateManyLogEntryInputEnvelope
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
  }

  export type LogEntryHistoryCreateNestedManyWithoutLogEntryInput = {
    create?: XOR<LogEntryHistoryCreateWithoutLogEntryInput, LogEntryHistoryUncheckedCreateWithoutLogEntryInput> | LogEntryHistoryCreateWithoutLogEntryInput[] | LogEntryHistoryUncheckedCreateWithoutLogEntryInput[]
    connectOrCreate?: LogEntryHistoryCreateOrConnectWithoutLogEntryInput | LogEntryHistoryCreateOrConnectWithoutLogEntryInput[]
    createMany?: LogEntryHistoryCreateManyLogEntryInputEnvelope
    connect?: LogEntryHistoryWhereUniqueInput | LogEntryHistoryWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<UserCreateWithoutAssignedToInput, UserUncheckedCreateWithoutAssignedToInput> | UserCreateWithoutAssignedToInput[] | UserUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedToInput | UserCreateOrConnectWithoutAssignedToInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutLogEntryInput = {
    create?: XOR<CommentCreateWithoutLogEntryInput, CommentUncheckedCreateWithoutLogEntryInput> | CommentCreateWithoutLogEntryInput[] | CommentUncheckedCreateWithoutLogEntryInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutLogEntryInput | CommentCreateOrConnectWithoutLogEntryInput[]
    createMany?: CommentCreateManyLogEntryInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutLogEntryInput = {
    create?: XOR<AttachmentCreateWithoutLogEntryInput, AttachmentUncheckedCreateWithoutLogEntryInput> | AttachmentCreateWithoutLogEntryInput[] | AttachmentUncheckedCreateWithoutLogEntryInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutLogEntryInput | AttachmentCreateOrConnectWithoutLogEntryInput[]
    createMany?: AttachmentCreateManyLogEntryInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type SignatureUncheckedCreateNestedManyWithoutLogEntryInput = {
    create?: XOR<SignatureCreateWithoutLogEntryInput, SignatureUncheckedCreateWithoutLogEntryInput> | SignatureCreateWithoutLogEntryInput[] | SignatureUncheckedCreateWithoutLogEntryInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutLogEntryInput | SignatureCreateOrConnectWithoutLogEntryInput[]
    createMany?: SignatureCreateManyLogEntryInputEnvelope
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
  }

  export type LogEntryHistoryUncheckedCreateNestedManyWithoutLogEntryInput = {
    create?: XOR<LogEntryHistoryCreateWithoutLogEntryInput, LogEntryHistoryUncheckedCreateWithoutLogEntryInput> | LogEntryHistoryCreateWithoutLogEntryInput[] | LogEntryHistoryUncheckedCreateWithoutLogEntryInput[]
    connectOrCreate?: LogEntryHistoryCreateOrConnectWithoutLogEntryInput | LogEntryHistoryCreateOrConnectWithoutLogEntryInput[]
    createMany?: LogEntryHistoryCreateManyLogEntryInputEnvelope
    connect?: LogEntryHistoryWhereUniqueInput | LogEntryHistoryWhereUniqueInput[]
  }

  export type EnumEntryTypeFieldUpdateOperationsInput = {
    set?: $Enums.EntryType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumEntryStatusFieldUpdateOperationsInput = {
    set?: $Enums.EntryStatus
  }

  export type UserUpdateOneRequiredWithoutLogEntriesNestedInput = {
    create?: XOR<UserCreateWithoutLogEntriesInput, UserUncheckedCreateWithoutLogEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogEntriesInput
    upsert?: UserUpsertWithoutLogEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogEntriesInput, UserUpdateWithoutLogEntriesInput>, UserUncheckedUpdateWithoutLogEntriesInput>
  }

  export type ProjectUpdateOneRequiredWithoutLogEntriesNestedInput = {
    create?: XOR<ProjectCreateWithoutLogEntriesInput, ProjectUncheckedCreateWithoutLogEntriesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLogEntriesInput
    upsert?: ProjectUpsertWithoutLogEntriesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutLogEntriesInput, ProjectUpdateWithoutLogEntriesInput>, ProjectUncheckedUpdateWithoutLogEntriesInput>
  }

  export type UserUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<UserCreateWithoutAssignedToInput, UserUncheckedCreateWithoutAssignedToInput> | UserCreateWithoutAssignedToInput[] | UserUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedToInput | UserCreateOrConnectWithoutAssignedToInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAssignedToInput | UserUpsertWithWhereUniqueWithoutAssignedToInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAssignedToInput | UserUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAssignedToInput | UserUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutLogEntryNestedInput = {
    create?: XOR<CommentCreateWithoutLogEntryInput, CommentUncheckedCreateWithoutLogEntryInput> | CommentCreateWithoutLogEntryInput[] | CommentUncheckedCreateWithoutLogEntryInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutLogEntryInput | CommentCreateOrConnectWithoutLogEntryInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutLogEntryInput | CommentUpsertWithWhereUniqueWithoutLogEntryInput[]
    createMany?: CommentCreateManyLogEntryInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutLogEntryInput | CommentUpdateWithWhereUniqueWithoutLogEntryInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutLogEntryInput | CommentUpdateManyWithWhereWithoutLogEntryInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type AttachmentUpdateManyWithoutLogEntryNestedInput = {
    create?: XOR<AttachmentCreateWithoutLogEntryInput, AttachmentUncheckedCreateWithoutLogEntryInput> | AttachmentCreateWithoutLogEntryInput[] | AttachmentUncheckedCreateWithoutLogEntryInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutLogEntryInput | AttachmentCreateOrConnectWithoutLogEntryInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutLogEntryInput | AttachmentUpsertWithWhereUniqueWithoutLogEntryInput[]
    createMany?: AttachmentCreateManyLogEntryInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutLogEntryInput | AttachmentUpdateWithWhereUniqueWithoutLogEntryInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutLogEntryInput | AttachmentUpdateManyWithWhereWithoutLogEntryInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type SignatureUpdateManyWithoutLogEntryNestedInput = {
    create?: XOR<SignatureCreateWithoutLogEntryInput, SignatureUncheckedCreateWithoutLogEntryInput> | SignatureCreateWithoutLogEntryInput[] | SignatureUncheckedCreateWithoutLogEntryInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutLogEntryInput | SignatureCreateOrConnectWithoutLogEntryInput[]
    upsert?: SignatureUpsertWithWhereUniqueWithoutLogEntryInput | SignatureUpsertWithWhereUniqueWithoutLogEntryInput[]
    createMany?: SignatureCreateManyLogEntryInputEnvelope
    set?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    disconnect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    delete?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    update?: SignatureUpdateWithWhereUniqueWithoutLogEntryInput | SignatureUpdateWithWhereUniqueWithoutLogEntryInput[]
    updateMany?: SignatureUpdateManyWithWhereWithoutLogEntryInput | SignatureUpdateManyWithWhereWithoutLogEntryInput[]
    deleteMany?: SignatureScalarWhereInput | SignatureScalarWhereInput[]
  }

  export type LogEntryHistoryUpdateManyWithoutLogEntryNestedInput = {
    create?: XOR<LogEntryHistoryCreateWithoutLogEntryInput, LogEntryHistoryUncheckedCreateWithoutLogEntryInput> | LogEntryHistoryCreateWithoutLogEntryInput[] | LogEntryHistoryUncheckedCreateWithoutLogEntryInput[]
    connectOrCreate?: LogEntryHistoryCreateOrConnectWithoutLogEntryInput | LogEntryHistoryCreateOrConnectWithoutLogEntryInput[]
    upsert?: LogEntryHistoryUpsertWithWhereUniqueWithoutLogEntryInput | LogEntryHistoryUpsertWithWhereUniqueWithoutLogEntryInput[]
    createMany?: LogEntryHistoryCreateManyLogEntryInputEnvelope
    set?: LogEntryHistoryWhereUniqueInput | LogEntryHistoryWhereUniqueInput[]
    disconnect?: LogEntryHistoryWhereUniqueInput | LogEntryHistoryWhereUniqueInput[]
    delete?: LogEntryHistoryWhereUniqueInput | LogEntryHistoryWhereUniqueInput[]
    connect?: LogEntryHistoryWhereUniqueInput | LogEntryHistoryWhereUniqueInput[]
    update?: LogEntryHistoryUpdateWithWhereUniqueWithoutLogEntryInput | LogEntryHistoryUpdateWithWhereUniqueWithoutLogEntryInput[]
    updateMany?: LogEntryHistoryUpdateManyWithWhereWithoutLogEntryInput | LogEntryHistoryUpdateManyWithWhereWithoutLogEntryInput[]
    deleteMany?: LogEntryHistoryScalarWhereInput | LogEntryHistoryScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<UserCreateWithoutAssignedToInput, UserUncheckedCreateWithoutAssignedToInput> | UserCreateWithoutAssignedToInput[] | UserUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAssignedToInput | UserCreateOrConnectWithoutAssignedToInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAssignedToInput | UserUpsertWithWhereUniqueWithoutAssignedToInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAssignedToInput | UserUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAssignedToInput | UserUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutLogEntryNestedInput = {
    create?: XOR<CommentCreateWithoutLogEntryInput, CommentUncheckedCreateWithoutLogEntryInput> | CommentCreateWithoutLogEntryInput[] | CommentUncheckedCreateWithoutLogEntryInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutLogEntryInput | CommentCreateOrConnectWithoutLogEntryInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutLogEntryInput | CommentUpsertWithWhereUniqueWithoutLogEntryInput[]
    createMany?: CommentCreateManyLogEntryInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutLogEntryInput | CommentUpdateWithWhereUniqueWithoutLogEntryInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutLogEntryInput | CommentUpdateManyWithWhereWithoutLogEntryInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutLogEntryNestedInput = {
    create?: XOR<AttachmentCreateWithoutLogEntryInput, AttachmentUncheckedCreateWithoutLogEntryInput> | AttachmentCreateWithoutLogEntryInput[] | AttachmentUncheckedCreateWithoutLogEntryInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutLogEntryInput | AttachmentCreateOrConnectWithoutLogEntryInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutLogEntryInput | AttachmentUpsertWithWhereUniqueWithoutLogEntryInput[]
    createMany?: AttachmentCreateManyLogEntryInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutLogEntryInput | AttachmentUpdateWithWhereUniqueWithoutLogEntryInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutLogEntryInput | AttachmentUpdateManyWithWhereWithoutLogEntryInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type SignatureUncheckedUpdateManyWithoutLogEntryNestedInput = {
    create?: XOR<SignatureCreateWithoutLogEntryInput, SignatureUncheckedCreateWithoutLogEntryInput> | SignatureCreateWithoutLogEntryInput[] | SignatureUncheckedCreateWithoutLogEntryInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutLogEntryInput | SignatureCreateOrConnectWithoutLogEntryInput[]
    upsert?: SignatureUpsertWithWhereUniqueWithoutLogEntryInput | SignatureUpsertWithWhereUniqueWithoutLogEntryInput[]
    createMany?: SignatureCreateManyLogEntryInputEnvelope
    set?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    disconnect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    delete?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    update?: SignatureUpdateWithWhereUniqueWithoutLogEntryInput | SignatureUpdateWithWhereUniqueWithoutLogEntryInput[]
    updateMany?: SignatureUpdateManyWithWhereWithoutLogEntryInput | SignatureUpdateManyWithWhereWithoutLogEntryInput[]
    deleteMany?: SignatureScalarWhereInput | SignatureScalarWhereInput[]
  }

  export type LogEntryHistoryUncheckedUpdateManyWithoutLogEntryNestedInput = {
    create?: XOR<LogEntryHistoryCreateWithoutLogEntryInput, LogEntryHistoryUncheckedCreateWithoutLogEntryInput> | LogEntryHistoryCreateWithoutLogEntryInput[] | LogEntryHistoryUncheckedCreateWithoutLogEntryInput[]
    connectOrCreate?: LogEntryHistoryCreateOrConnectWithoutLogEntryInput | LogEntryHistoryCreateOrConnectWithoutLogEntryInput[]
    upsert?: LogEntryHistoryUpsertWithWhereUniqueWithoutLogEntryInput | LogEntryHistoryUpsertWithWhereUniqueWithoutLogEntryInput[]
    createMany?: LogEntryHistoryCreateManyLogEntryInputEnvelope
    set?: LogEntryHistoryWhereUniqueInput | LogEntryHistoryWhereUniqueInput[]
    disconnect?: LogEntryHistoryWhereUniqueInput | LogEntryHistoryWhereUniqueInput[]
    delete?: LogEntryHistoryWhereUniqueInput | LogEntryHistoryWhereUniqueInput[]
    connect?: LogEntryHistoryWhereUniqueInput | LogEntryHistoryWhereUniqueInput[]
    update?: LogEntryHistoryUpdateWithWhereUniqueWithoutLogEntryInput | LogEntryHistoryUpdateWithWhereUniqueWithoutLogEntryInput[]
    updateMany?: LogEntryHistoryUpdateManyWithWhereWithoutLogEntryInput | LogEntryHistoryUpdateManyWithWhereWithoutLogEntryInput[]
    deleteMany?: LogEntryHistoryScalarWhereInput | LogEntryHistoryScalarWhereInput[]
  }

  export type LogEntryCreateNestedOneWithoutHistoryInput = {
    create?: XOR<LogEntryCreateWithoutHistoryInput, LogEntryUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: LogEntryCreateOrConnectWithoutHistoryInput
    connect?: LogEntryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLogEntryHistoryInput = {
    create?: XOR<UserCreateWithoutLogEntryHistoryInput, UserUncheckedCreateWithoutLogEntryHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogEntryHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type LogEntryUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<LogEntryCreateWithoutHistoryInput, LogEntryUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: LogEntryCreateOrConnectWithoutHistoryInput
    upsert?: LogEntryUpsertWithoutHistoryInput
    connect?: LogEntryWhereUniqueInput
    update?: XOR<XOR<LogEntryUpdateToOneWithWhereWithoutHistoryInput, LogEntryUpdateWithoutHistoryInput>, LogEntryUncheckedUpdateWithoutHistoryInput>
  }

  export type UserUpdateOneWithoutLogEntryHistoryNestedInput = {
    create?: XOR<UserCreateWithoutLogEntryHistoryInput, UserUncheckedCreateWithoutLogEntryHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogEntryHistoryInput
    upsert?: UserUpsertWithoutLogEntryHistoryInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogEntryHistoryInput, UserUpdateWithoutLogEntryHistoryInput>, UserUncheckedUpdateWithoutLogEntryHistoryInput>
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type LogEntryCreateNestedOneWithoutCommentsInput = {
    create?: XOR<LogEntryCreateWithoutCommentsInput, LogEntryUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: LogEntryCreateOrConnectWithoutCommentsInput
    connect?: LogEntryWhereUniqueInput
  }

  export type DrawingCreateNestedOneWithoutCommentsInput = {
    create?: XOR<DrawingCreateWithoutCommentsInput, DrawingUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: DrawingCreateOrConnectWithoutCommentsInput
    connect?: DrawingWhereUniqueInput
  }

  export type AttachmentCreateNestedManyWithoutCommentInput = {
    create?: XOR<AttachmentCreateWithoutCommentInput, AttachmentUncheckedCreateWithoutCommentInput> | AttachmentCreateWithoutCommentInput[] | AttachmentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutCommentInput | AttachmentCreateOrConnectWithoutCommentInput[]
    createMany?: AttachmentCreateManyCommentInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<AttachmentCreateWithoutCommentInput, AttachmentUncheckedCreateWithoutCommentInput> | AttachmentCreateWithoutCommentInput[] | AttachmentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutCommentInput | AttachmentCreateOrConnectWithoutCommentInput[]
    createMany?: AttachmentCreateManyCommentInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type LogEntryUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<LogEntryCreateWithoutCommentsInput, LogEntryUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: LogEntryCreateOrConnectWithoutCommentsInput
    upsert?: LogEntryUpsertWithoutCommentsInput
    disconnect?: LogEntryWhereInput | boolean
    delete?: LogEntryWhereInput | boolean
    connect?: LogEntryWhereUniqueInput
    update?: XOR<XOR<LogEntryUpdateToOneWithWhereWithoutCommentsInput, LogEntryUpdateWithoutCommentsInput>, LogEntryUncheckedUpdateWithoutCommentsInput>
  }

  export type DrawingUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<DrawingCreateWithoutCommentsInput, DrawingUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: DrawingCreateOrConnectWithoutCommentsInput
    upsert?: DrawingUpsertWithoutCommentsInput
    disconnect?: DrawingWhereInput | boolean
    delete?: DrawingWhereInput | boolean
    connect?: DrawingWhereUniqueInput
    update?: XOR<XOR<DrawingUpdateToOneWithWhereWithoutCommentsInput, DrawingUpdateWithoutCommentsInput>, DrawingUncheckedUpdateWithoutCommentsInput>
  }

  export type AttachmentUpdateManyWithoutCommentNestedInput = {
    create?: XOR<AttachmentCreateWithoutCommentInput, AttachmentUncheckedCreateWithoutCommentInput> | AttachmentCreateWithoutCommentInput[] | AttachmentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutCommentInput | AttachmentCreateOrConnectWithoutCommentInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutCommentInput | AttachmentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: AttachmentCreateManyCommentInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutCommentInput | AttachmentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutCommentInput | AttachmentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<AttachmentCreateWithoutCommentInput, AttachmentUncheckedCreateWithoutCommentInput> | AttachmentCreateWithoutCommentInput[] | AttachmentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutCommentInput | AttachmentCreateOrConnectWithoutCommentInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutCommentInput | AttachmentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: AttachmentCreateManyCommentInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutCommentInput | AttachmentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutCommentInput | AttachmentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSignaturesInput = {
    create?: XOR<UserCreateWithoutSignaturesInput, UserUncheckedCreateWithoutSignaturesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSignaturesInput
    connect?: UserWhereUniqueInput
  }

  export type LogEntryCreateNestedOneWithoutSignaturesInput = {
    create?: XOR<LogEntryCreateWithoutSignaturesInput, LogEntryUncheckedCreateWithoutSignaturesInput>
    connectOrCreate?: LogEntryCreateOrConnectWithoutSignaturesInput
    connect?: LogEntryWhereUniqueInput
  }

  export type ActaCreateNestedOneWithoutSignaturesInput = {
    create?: XOR<ActaCreateWithoutSignaturesInput, ActaUncheckedCreateWithoutSignaturesInput>
    connectOrCreate?: ActaCreateOrConnectWithoutSignaturesInput
    connect?: ActaWhereUniqueInput
  }

  export type ReportCreateNestedOneWithoutSignaturesInput = {
    create?: XOR<ReportCreateWithoutSignaturesInput, ReportUncheckedCreateWithoutSignaturesInput>
    connectOrCreate?: ReportCreateOrConnectWithoutSignaturesInput
    connect?: ReportWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSignaturesNestedInput = {
    create?: XOR<UserCreateWithoutSignaturesInput, UserUncheckedCreateWithoutSignaturesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSignaturesInput
    upsert?: UserUpsertWithoutSignaturesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSignaturesInput, UserUpdateWithoutSignaturesInput>, UserUncheckedUpdateWithoutSignaturesInput>
  }

  export type LogEntryUpdateOneWithoutSignaturesNestedInput = {
    create?: XOR<LogEntryCreateWithoutSignaturesInput, LogEntryUncheckedCreateWithoutSignaturesInput>
    connectOrCreate?: LogEntryCreateOrConnectWithoutSignaturesInput
    upsert?: LogEntryUpsertWithoutSignaturesInput
    disconnect?: LogEntryWhereInput | boolean
    delete?: LogEntryWhereInput | boolean
    connect?: LogEntryWhereUniqueInput
    update?: XOR<XOR<LogEntryUpdateToOneWithWhereWithoutSignaturesInput, LogEntryUpdateWithoutSignaturesInput>, LogEntryUncheckedUpdateWithoutSignaturesInput>
  }

  export type ActaUpdateOneWithoutSignaturesNestedInput = {
    create?: XOR<ActaCreateWithoutSignaturesInput, ActaUncheckedCreateWithoutSignaturesInput>
    connectOrCreate?: ActaCreateOrConnectWithoutSignaturesInput
    upsert?: ActaUpsertWithoutSignaturesInput
    disconnect?: ActaWhereInput | boolean
    delete?: ActaWhereInput | boolean
    connect?: ActaWhereUniqueInput
    update?: XOR<XOR<ActaUpdateToOneWithWhereWithoutSignaturesInput, ActaUpdateWithoutSignaturesInput>, ActaUncheckedUpdateWithoutSignaturesInput>
  }

  export type ReportUpdateOneWithoutSignaturesNestedInput = {
    create?: XOR<ReportCreateWithoutSignaturesInput, ReportUncheckedCreateWithoutSignaturesInput>
    connectOrCreate?: ReportCreateOrConnectWithoutSignaturesInput
    upsert?: ReportUpsertWithoutSignaturesInput
    disconnect?: ReportWhereInput | boolean
    delete?: ReportWhereInput | boolean
    connect?: ReportWhereUniqueInput
    update?: XOR<XOR<ReportUpdateToOneWithWhereWithoutSignaturesInput, ReportUpdateWithoutSignaturesInput>, ReportUncheckedUpdateWithoutSignaturesInput>
  }

  export type LogEntryCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<LogEntryCreateWithoutAttachmentsInput, LogEntryUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: LogEntryCreateOrConnectWithoutAttachmentsInput
    connect?: LogEntryWhereUniqueInput
  }

  export type CommunicationCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<CommunicationCreateWithoutAttachmentsInput, CommunicationUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: CommunicationCreateOrConnectWithoutAttachmentsInput
    connect?: CommunicationWhereUniqueInput
  }

  export type ActaCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<ActaCreateWithoutAttachmentsInput, ActaUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: ActaCreateOrConnectWithoutAttachmentsInput
    connect?: ActaWhereUniqueInput
  }

  export type CostActaCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<CostActaCreateWithoutAttachmentsInput, CostActaUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: CostActaCreateOrConnectWithoutAttachmentsInput
    connect?: CostActaWhereUniqueInput
  }

  export type ReportCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<ReportCreateWithoutAttachmentsInput, ReportUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: ReportCreateOrConnectWithoutAttachmentsInput
    connect?: ReportWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<CommentCreateWithoutAttachmentsInput, CommentUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutAttachmentsInput
    connect?: CommentWhereUniqueInput
  }

  export type ContractModificationCreateNestedOneWithoutAttachmentInput = {
    create?: XOR<ContractModificationCreateWithoutAttachmentInput, ContractModificationUncheckedCreateWithoutAttachmentInput>
    connectOrCreate?: ContractModificationCreateOrConnectWithoutAttachmentInput
    connect?: ContractModificationWhereUniqueInput
  }

  export type WorkActaCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<WorkActaCreateWithoutAttachmentsInput, WorkActaUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: WorkActaCreateOrConnectWithoutAttachmentsInput
    connect?: WorkActaWhereUniqueInput
  }

  export type WeeklyReportCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<WeeklyReportCreateWithoutAttachmentsInput, WeeklyReportUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: WeeklyReportCreateOrConnectWithoutAttachmentsInput
    connect?: WeeklyReportWhereUniqueInput
  }

  export type PhotoEntryCreateNestedOneWithoutAttachmentInput = {
    create?: XOR<PhotoEntryCreateWithoutAttachmentInput, PhotoEntryUncheckedCreateWithoutAttachmentInput>
    connectOrCreate?: PhotoEntryCreateOrConnectWithoutAttachmentInput
    connect?: PhotoEntryWhereUniqueInput
  }

  export type ContractModificationUncheckedCreateNestedOneWithoutAttachmentInput = {
    create?: XOR<ContractModificationCreateWithoutAttachmentInput, ContractModificationUncheckedCreateWithoutAttachmentInput>
    connectOrCreate?: ContractModificationCreateOrConnectWithoutAttachmentInput
    connect?: ContractModificationWhereUniqueInput
  }

  export type PhotoEntryUncheckedCreateNestedOneWithoutAttachmentInput = {
    create?: XOR<PhotoEntryCreateWithoutAttachmentInput, PhotoEntryUncheckedCreateWithoutAttachmentInput>
    connectOrCreate?: PhotoEntryCreateOrConnectWithoutAttachmentInput
    connect?: PhotoEntryWhereUniqueInput
  }

  export type LogEntryUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<LogEntryCreateWithoutAttachmentsInput, LogEntryUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: LogEntryCreateOrConnectWithoutAttachmentsInput
    upsert?: LogEntryUpsertWithoutAttachmentsInput
    disconnect?: LogEntryWhereInput | boolean
    delete?: LogEntryWhereInput | boolean
    connect?: LogEntryWhereUniqueInput
    update?: XOR<XOR<LogEntryUpdateToOneWithWhereWithoutAttachmentsInput, LogEntryUpdateWithoutAttachmentsInput>, LogEntryUncheckedUpdateWithoutAttachmentsInput>
  }

  export type CommunicationUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<CommunicationCreateWithoutAttachmentsInput, CommunicationUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: CommunicationCreateOrConnectWithoutAttachmentsInput
    upsert?: CommunicationUpsertWithoutAttachmentsInput
    disconnect?: CommunicationWhereInput | boolean
    delete?: CommunicationWhereInput | boolean
    connect?: CommunicationWhereUniqueInput
    update?: XOR<XOR<CommunicationUpdateToOneWithWhereWithoutAttachmentsInput, CommunicationUpdateWithoutAttachmentsInput>, CommunicationUncheckedUpdateWithoutAttachmentsInput>
  }

  export type ActaUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<ActaCreateWithoutAttachmentsInput, ActaUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: ActaCreateOrConnectWithoutAttachmentsInput
    upsert?: ActaUpsertWithoutAttachmentsInput
    disconnect?: ActaWhereInput | boolean
    delete?: ActaWhereInput | boolean
    connect?: ActaWhereUniqueInput
    update?: XOR<XOR<ActaUpdateToOneWithWhereWithoutAttachmentsInput, ActaUpdateWithoutAttachmentsInput>, ActaUncheckedUpdateWithoutAttachmentsInput>
  }

  export type CostActaUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<CostActaCreateWithoutAttachmentsInput, CostActaUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: CostActaCreateOrConnectWithoutAttachmentsInput
    upsert?: CostActaUpsertWithoutAttachmentsInput
    disconnect?: CostActaWhereInput | boolean
    delete?: CostActaWhereInput | boolean
    connect?: CostActaWhereUniqueInput
    update?: XOR<XOR<CostActaUpdateToOneWithWhereWithoutAttachmentsInput, CostActaUpdateWithoutAttachmentsInput>, CostActaUncheckedUpdateWithoutAttachmentsInput>
  }

  export type ReportUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<ReportCreateWithoutAttachmentsInput, ReportUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: ReportCreateOrConnectWithoutAttachmentsInput
    upsert?: ReportUpsertWithoutAttachmentsInput
    disconnect?: ReportWhereInput | boolean
    delete?: ReportWhereInput | boolean
    connect?: ReportWhereUniqueInput
    update?: XOR<XOR<ReportUpdateToOneWithWhereWithoutAttachmentsInput, ReportUpdateWithoutAttachmentsInput>, ReportUncheckedUpdateWithoutAttachmentsInput>
  }

  export type CommentUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<CommentCreateWithoutAttachmentsInput, CommentUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutAttachmentsInput
    upsert?: CommentUpsertWithoutAttachmentsInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutAttachmentsInput, CommentUpdateWithoutAttachmentsInput>, CommentUncheckedUpdateWithoutAttachmentsInput>
  }

  export type ContractModificationUpdateOneWithoutAttachmentNestedInput = {
    create?: XOR<ContractModificationCreateWithoutAttachmentInput, ContractModificationUncheckedCreateWithoutAttachmentInput>
    connectOrCreate?: ContractModificationCreateOrConnectWithoutAttachmentInput
    upsert?: ContractModificationUpsertWithoutAttachmentInput
    disconnect?: ContractModificationWhereInput | boolean
    delete?: ContractModificationWhereInput | boolean
    connect?: ContractModificationWhereUniqueInput
    update?: XOR<XOR<ContractModificationUpdateToOneWithWhereWithoutAttachmentInput, ContractModificationUpdateWithoutAttachmentInput>, ContractModificationUncheckedUpdateWithoutAttachmentInput>
  }

  export type WorkActaUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<WorkActaCreateWithoutAttachmentsInput, WorkActaUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: WorkActaCreateOrConnectWithoutAttachmentsInput
    upsert?: WorkActaUpsertWithoutAttachmentsInput
    disconnect?: WorkActaWhereInput | boolean
    delete?: WorkActaWhereInput | boolean
    connect?: WorkActaWhereUniqueInput
    update?: XOR<XOR<WorkActaUpdateToOneWithWhereWithoutAttachmentsInput, WorkActaUpdateWithoutAttachmentsInput>, WorkActaUncheckedUpdateWithoutAttachmentsInput>
  }

  export type WeeklyReportUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<WeeklyReportCreateWithoutAttachmentsInput, WeeklyReportUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: WeeklyReportCreateOrConnectWithoutAttachmentsInput
    upsert?: WeeklyReportUpsertWithoutAttachmentsInput
    disconnect?: WeeklyReportWhereInput | boolean
    delete?: WeeklyReportWhereInput | boolean
    connect?: WeeklyReportWhereUniqueInput
    update?: XOR<XOR<WeeklyReportUpdateToOneWithWhereWithoutAttachmentsInput, WeeklyReportUpdateWithoutAttachmentsInput>, WeeklyReportUncheckedUpdateWithoutAttachmentsInput>
  }

  export type PhotoEntryUpdateOneWithoutAttachmentNestedInput = {
    create?: XOR<PhotoEntryCreateWithoutAttachmentInput, PhotoEntryUncheckedCreateWithoutAttachmentInput>
    connectOrCreate?: PhotoEntryCreateOrConnectWithoutAttachmentInput
    upsert?: PhotoEntryUpsertWithoutAttachmentInput
    disconnect?: PhotoEntryWhereInput | boolean
    delete?: PhotoEntryWhereInput | boolean
    connect?: PhotoEntryWhereUniqueInput
    update?: XOR<XOR<PhotoEntryUpdateToOneWithWhereWithoutAttachmentInput, PhotoEntryUpdateWithoutAttachmentInput>, PhotoEntryUncheckedUpdateWithoutAttachmentInput>
  }

  export type ContractModificationUncheckedUpdateOneWithoutAttachmentNestedInput = {
    create?: XOR<ContractModificationCreateWithoutAttachmentInput, ContractModificationUncheckedCreateWithoutAttachmentInput>
    connectOrCreate?: ContractModificationCreateOrConnectWithoutAttachmentInput
    upsert?: ContractModificationUpsertWithoutAttachmentInput
    disconnect?: ContractModificationWhereInput | boolean
    delete?: ContractModificationWhereInput | boolean
    connect?: ContractModificationWhereUniqueInput
    update?: XOR<XOR<ContractModificationUpdateToOneWithWhereWithoutAttachmentInput, ContractModificationUpdateWithoutAttachmentInput>, ContractModificationUncheckedUpdateWithoutAttachmentInput>
  }

  export type PhotoEntryUncheckedUpdateOneWithoutAttachmentNestedInput = {
    create?: XOR<PhotoEntryCreateWithoutAttachmentInput, PhotoEntryUncheckedCreateWithoutAttachmentInput>
    connectOrCreate?: PhotoEntryCreateOrConnectWithoutAttachmentInput
    upsert?: PhotoEntryUpsertWithoutAttachmentInput
    disconnect?: PhotoEntryWhereInput | boolean
    delete?: PhotoEntryWhereInput | boolean
    connect?: PhotoEntryWhereUniqueInput
    update?: XOR<XOR<PhotoEntryUpdateToOneWithWhereWithoutAttachmentInput, PhotoEntryUpdateWithoutAttachmentInput>, PhotoEntryUncheckedUpdateWithoutAttachmentInput>
  }

  export type AttachmentCreateNestedManyWithoutActaInput = {
    create?: XOR<AttachmentCreateWithoutActaInput, AttachmentUncheckedCreateWithoutActaInput> | AttachmentCreateWithoutActaInput[] | AttachmentUncheckedCreateWithoutActaInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutActaInput | AttachmentCreateOrConnectWithoutActaInput[]
    createMany?: AttachmentCreateManyActaInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type SignatureCreateNestedManyWithoutActaInput = {
    create?: XOR<SignatureCreateWithoutActaInput, SignatureUncheckedCreateWithoutActaInput> | SignatureCreateWithoutActaInput[] | SignatureUncheckedCreateWithoutActaInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutActaInput | SignatureCreateOrConnectWithoutActaInput[]
    createMany?: SignatureCreateManyActaInputEnvelope
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
  }

  export type CommitmentCreateNestedManyWithoutActaInput = {
    create?: XOR<CommitmentCreateWithoutActaInput, CommitmentUncheckedCreateWithoutActaInput> | CommitmentCreateWithoutActaInput[] | CommitmentUncheckedCreateWithoutActaInput[]
    connectOrCreate?: CommitmentCreateOrConnectWithoutActaInput | CommitmentCreateOrConnectWithoutActaInput[]
    createMany?: CommitmentCreateManyActaInputEnvelope
    connect?: CommitmentWhereUniqueInput | CommitmentWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutActaInput = {
    create?: XOR<AttachmentCreateWithoutActaInput, AttachmentUncheckedCreateWithoutActaInput> | AttachmentCreateWithoutActaInput[] | AttachmentUncheckedCreateWithoutActaInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutActaInput | AttachmentCreateOrConnectWithoutActaInput[]
    createMany?: AttachmentCreateManyActaInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type SignatureUncheckedCreateNestedManyWithoutActaInput = {
    create?: XOR<SignatureCreateWithoutActaInput, SignatureUncheckedCreateWithoutActaInput> | SignatureCreateWithoutActaInput[] | SignatureUncheckedCreateWithoutActaInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutActaInput | SignatureCreateOrConnectWithoutActaInput[]
    createMany?: SignatureCreateManyActaInputEnvelope
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
  }

  export type CommitmentUncheckedCreateNestedManyWithoutActaInput = {
    create?: XOR<CommitmentCreateWithoutActaInput, CommitmentUncheckedCreateWithoutActaInput> | CommitmentCreateWithoutActaInput[] | CommitmentUncheckedCreateWithoutActaInput[]
    connectOrCreate?: CommitmentCreateOrConnectWithoutActaInput | CommitmentCreateOrConnectWithoutActaInput[]
    createMany?: CommitmentCreateManyActaInputEnvelope
    connect?: CommitmentWhereUniqueInput | CommitmentWhereUniqueInput[]
  }

  export type EnumActaAreaFieldUpdateOperationsInput = {
    set?: $Enums.ActaArea
  }

  export type EnumActaStatusFieldUpdateOperationsInput = {
    set?: $Enums.ActaStatus
  }

  export type AttachmentUpdateManyWithoutActaNestedInput = {
    create?: XOR<AttachmentCreateWithoutActaInput, AttachmentUncheckedCreateWithoutActaInput> | AttachmentCreateWithoutActaInput[] | AttachmentUncheckedCreateWithoutActaInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutActaInput | AttachmentCreateOrConnectWithoutActaInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutActaInput | AttachmentUpsertWithWhereUniqueWithoutActaInput[]
    createMany?: AttachmentCreateManyActaInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutActaInput | AttachmentUpdateWithWhereUniqueWithoutActaInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutActaInput | AttachmentUpdateManyWithWhereWithoutActaInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type SignatureUpdateManyWithoutActaNestedInput = {
    create?: XOR<SignatureCreateWithoutActaInput, SignatureUncheckedCreateWithoutActaInput> | SignatureCreateWithoutActaInput[] | SignatureUncheckedCreateWithoutActaInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutActaInput | SignatureCreateOrConnectWithoutActaInput[]
    upsert?: SignatureUpsertWithWhereUniqueWithoutActaInput | SignatureUpsertWithWhereUniqueWithoutActaInput[]
    createMany?: SignatureCreateManyActaInputEnvelope
    set?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    disconnect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    delete?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    update?: SignatureUpdateWithWhereUniqueWithoutActaInput | SignatureUpdateWithWhereUniqueWithoutActaInput[]
    updateMany?: SignatureUpdateManyWithWhereWithoutActaInput | SignatureUpdateManyWithWhereWithoutActaInput[]
    deleteMany?: SignatureScalarWhereInput | SignatureScalarWhereInput[]
  }

  export type CommitmentUpdateManyWithoutActaNestedInput = {
    create?: XOR<CommitmentCreateWithoutActaInput, CommitmentUncheckedCreateWithoutActaInput> | CommitmentCreateWithoutActaInput[] | CommitmentUncheckedCreateWithoutActaInput[]
    connectOrCreate?: CommitmentCreateOrConnectWithoutActaInput | CommitmentCreateOrConnectWithoutActaInput[]
    upsert?: CommitmentUpsertWithWhereUniqueWithoutActaInput | CommitmentUpsertWithWhereUniqueWithoutActaInput[]
    createMany?: CommitmentCreateManyActaInputEnvelope
    set?: CommitmentWhereUniqueInput | CommitmentWhereUniqueInput[]
    disconnect?: CommitmentWhereUniqueInput | CommitmentWhereUniqueInput[]
    delete?: CommitmentWhereUniqueInput | CommitmentWhereUniqueInput[]
    connect?: CommitmentWhereUniqueInput | CommitmentWhereUniqueInput[]
    update?: CommitmentUpdateWithWhereUniqueWithoutActaInput | CommitmentUpdateWithWhereUniqueWithoutActaInput[]
    updateMany?: CommitmentUpdateManyWithWhereWithoutActaInput | CommitmentUpdateManyWithWhereWithoutActaInput[]
    deleteMany?: CommitmentScalarWhereInput | CommitmentScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutActaNestedInput = {
    create?: XOR<AttachmentCreateWithoutActaInput, AttachmentUncheckedCreateWithoutActaInput> | AttachmentCreateWithoutActaInput[] | AttachmentUncheckedCreateWithoutActaInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutActaInput | AttachmentCreateOrConnectWithoutActaInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutActaInput | AttachmentUpsertWithWhereUniqueWithoutActaInput[]
    createMany?: AttachmentCreateManyActaInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutActaInput | AttachmentUpdateWithWhereUniqueWithoutActaInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutActaInput | AttachmentUpdateManyWithWhereWithoutActaInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type SignatureUncheckedUpdateManyWithoutActaNestedInput = {
    create?: XOR<SignatureCreateWithoutActaInput, SignatureUncheckedCreateWithoutActaInput> | SignatureCreateWithoutActaInput[] | SignatureUncheckedCreateWithoutActaInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutActaInput | SignatureCreateOrConnectWithoutActaInput[]
    upsert?: SignatureUpsertWithWhereUniqueWithoutActaInput | SignatureUpsertWithWhereUniqueWithoutActaInput[]
    createMany?: SignatureCreateManyActaInputEnvelope
    set?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    disconnect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    delete?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    update?: SignatureUpdateWithWhereUniqueWithoutActaInput | SignatureUpdateWithWhereUniqueWithoutActaInput[]
    updateMany?: SignatureUpdateManyWithWhereWithoutActaInput | SignatureUpdateManyWithWhereWithoutActaInput[]
    deleteMany?: SignatureScalarWhereInput | SignatureScalarWhereInput[]
  }

  export type CommitmentUncheckedUpdateManyWithoutActaNestedInput = {
    create?: XOR<CommitmentCreateWithoutActaInput, CommitmentUncheckedCreateWithoutActaInput> | CommitmentCreateWithoutActaInput[] | CommitmentUncheckedCreateWithoutActaInput[]
    connectOrCreate?: CommitmentCreateOrConnectWithoutActaInput | CommitmentCreateOrConnectWithoutActaInput[]
    upsert?: CommitmentUpsertWithWhereUniqueWithoutActaInput | CommitmentUpsertWithWhereUniqueWithoutActaInput[]
    createMany?: CommitmentCreateManyActaInputEnvelope
    set?: CommitmentWhereUniqueInput | CommitmentWhereUniqueInput[]
    disconnect?: CommitmentWhereUniqueInput | CommitmentWhereUniqueInput[]
    delete?: CommitmentWhereUniqueInput | CommitmentWhereUniqueInput[]
    connect?: CommitmentWhereUniqueInput | CommitmentWhereUniqueInput[]
    update?: CommitmentUpdateWithWhereUniqueWithoutActaInput | CommitmentUpdateWithWhereUniqueWithoutActaInput[]
    updateMany?: CommitmentUpdateManyWithWhereWithoutActaInput | CommitmentUpdateManyWithWhereWithoutActaInput[]
    deleteMany?: CommitmentScalarWhereInput | CommitmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutResponsibleForInput = {
    create?: XOR<UserCreateWithoutResponsibleForInput, UserUncheckedCreateWithoutResponsibleForInput>
    connectOrCreate?: UserCreateOrConnectWithoutResponsibleForInput
    connect?: UserWhereUniqueInput
  }

  export type ActaCreateNestedOneWithoutCommitmentsInput = {
    create?: XOR<ActaCreateWithoutCommitmentsInput, ActaUncheckedCreateWithoutCommitmentsInput>
    connectOrCreate?: ActaCreateOrConnectWithoutCommitmentsInput
    connect?: ActaWhereUniqueInput
  }

  export type EnumCommitmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.CommitmentStatus
  }

  export type UserUpdateOneRequiredWithoutResponsibleForNestedInput = {
    create?: XOR<UserCreateWithoutResponsibleForInput, UserUncheckedCreateWithoutResponsibleForInput>
    connectOrCreate?: UserCreateOrConnectWithoutResponsibleForInput
    upsert?: UserUpsertWithoutResponsibleForInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResponsibleForInput, UserUpdateWithoutResponsibleForInput>, UserUncheckedUpdateWithoutResponsibleForInput>
  }

  export type ActaUpdateOneRequiredWithoutCommitmentsNestedInput = {
    create?: XOR<ActaCreateWithoutCommitmentsInput, ActaUncheckedCreateWithoutCommitmentsInput>
    connectOrCreate?: ActaCreateOrConnectWithoutCommitmentsInput
    upsert?: ActaUpsertWithoutCommitmentsInput
    connect?: ActaWhereUniqueInput
    update?: XOR<XOR<ActaUpdateToOneWithWhereWithoutCommitmentsInput, ActaUpdateWithoutCommitmentsInput>, ActaUncheckedUpdateWithoutCommitmentsInput>
  }

  export type ObservationCreateNestedManyWithoutCostActaInput = {
    create?: XOR<ObservationCreateWithoutCostActaInput, ObservationUncheckedCreateWithoutCostActaInput> | ObservationCreateWithoutCostActaInput[] | ObservationUncheckedCreateWithoutCostActaInput[]
    connectOrCreate?: ObservationCreateOrConnectWithoutCostActaInput | ObservationCreateOrConnectWithoutCostActaInput[]
    createMany?: ObservationCreateManyCostActaInputEnvelope
    connect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
  }

  export type AttachmentCreateNestedManyWithoutCostActaInput = {
    create?: XOR<AttachmentCreateWithoutCostActaInput, AttachmentUncheckedCreateWithoutCostActaInput> | AttachmentCreateWithoutCostActaInput[] | AttachmentUncheckedCreateWithoutCostActaInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutCostActaInput | AttachmentCreateOrConnectWithoutCostActaInput[]
    createMany?: AttachmentCreateManyCostActaInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type ObservationUncheckedCreateNestedManyWithoutCostActaInput = {
    create?: XOR<ObservationCreateWithoutCostActaInput, ObservationUncheckedCreateWithoutCostActaInput> | ObservationCreateWithoutCostActaInput[] | ObservationUncheckedCreateWithoutCostActaInput[]
    connectOrCreate?: ObservationCreateOrConnectWithoutCostActaInput | ObservationCreateOrConnectWithoutCostActaInput[]
    createMany?: ObservationCreateManyCostActaInputEnvelope
    connect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutCostActaInput = {
    create?: XOR<AttachmentCreateWithoutCostActaInput, AttachmentUncheckedCreateWithoutCostActaInput> | AttachmentCreateWithoutCostActaInput[] | AttachmentUncheckedCreateWithoutCostActaInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutCostActaInput | AttachmentCreateOrConnectWithoutCostActaInput[]
    createMany?: AttachmentCreateManyCostActaInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type EnumCostActaStatusFieldUpdateOperationsInput = {
    set?: $Enums.CostActaStatus
  }

  export type ObservationUpdateManyWithoutCostActaNestedInput = {
    create?: XOR<ObservationCreateWithoutCostActaInput, ObservationUncheckedCreateWithoutCostActaInput> | ObservationCreateWithoutCostActaInput[] | ObservationUncheckedCreateWithoutCostActaInput[]
    connectOrCreate?: ObservationCreateOrConnectWithoutCostActaInput | ObservationCreateOrConnectWithoutCostActaInput[]
    upsert?: ObservationUpsertWithWhereUniqueWithoutCostActaInput | ObservationUpsertWithWhereUniqueWithoutCostActaInput[]
    createMany?: ObservationCreateManyCostActaInputEnvelope
    set?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    disconnect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    delete?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    connect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    update?: ObservationUpdateWithWhereUniqueWithoutCostActaInput | ObservationUpdateWithWhereUniqueWithoutCostActaInput[]
    updateMany?: ObservationUpdateManyWithWhereWithoutCostActaInput | ObservationUpdateManyWithWhereWithoutCostActaInput[]
    deleteMany?: ObservationScalarWhereInput | ObservationScalarWhereInput[]
  }

  export type AttachmentUpdateManyWithoutCostActaNestedInput = {
    create?: XOR<AttachmentCreateWithoutCostActaInput, AttachmentUncheckedCreateWithoutCostActaInput> | AttachmentCreateWithoutCostActaInput[] | AttachmentUncheckedCreateWithoutCostActaInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutCostActaInput | AttachmentCreateOrConnectWithoutCostActaInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutCostActaInput | AttachmentUpsertWithWhereUniqueWithoutCostActaInput[]
    createMany?: AttachmentCreateManyCostActaInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutCostActaInput | AttachmentUpdateWithWhereUniqueWithoutCostActaInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutCostActaInput | AttachmentUpdateManyWithWhereWithoutCostActaInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type ObservationUncheckedUpdateManyWithoutCostActaNestedInput = {
    create?: XOR<ObservationCreateWithoutCostActaInput, ObservationUncheckedCreateWithoutCostActaInput> | ObservationCreateWithoutCostActaInput[] | ObservationUncheckedCreateWithoutCostActaInput[]
    connectOrCreate?: ObservationCreateOrConnectWithoutCostActaInput | ObservationCreateOrConnectWithoutCostActaInput[]
    upsert?: ObservationUpsertWithWhereUniqueWithoutCostActaInput | ObservationUpsertWithWhereUniqueWithoutCostActaInput[]
    createMany?: ObservationCreateManyCostActaInputEnvelope
    set?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    disconnect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    delete?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    connect?: ObservationWhereUniqueInput | ObservationWhereUniqueInput[]
    update?: ObservationUpdateWithWhereUniqueWithoutCostActaInput | ObservationUpdateWithWhereUniqueWithoutCostActaInput[]
    updateMany?: ObservationUpdateManyWithWhereWithoutCostActaInput | ObservationUpdateManyWithWhereWithoutCostActaInput[]
    deleteMany?: ObservationScalarWhereInput | ObservationScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutCostActaNestedInput = {
    create?: XOR<AttachmentCreateWithoutCostActaInput, AttachmentUncheckedCreateWithoutCostActaInput> | AttachmentCreateWithoutCostActaInput[] | AttachmentUncheckedCreateWithoutCostActaInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutCostActaInput | AttachmentCreateOrConnectWithoutCostActaInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutCostActaInput | AttachmentUpsertWithWhereUniqueWithoutCostActaInput[]
    createMany?: AttachmentCreateManyCostActaInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutCostActaInput | AttachmentUpdateWithWhereUniqueWithoutCostActaInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutCostActaInput | AttachmentUpdateManyWithWhereWithoutCostActaInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutObservationsInput = {
    create?: XOR<UserCreateWithoutObservationsInput, UserUncheckedCreateWithoutObservationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutObservationsInput
    connect?: UserWhereUniqueInput
  }

  export type CostActaCreateNestedOneWithoutObservationsInput = {
    create?: XOR<CostActaCreateWithoutObservationsInput, CostActaUncheckedCreateWithoutObservationsInput>
    connectOrCreate?: CostActaCreateOrConnectWithoutObservationsInput
    connect?: CostActaWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutObservationsNestedInput = {
    create?: XOR<UserCreateWithoutObservationsInput, UserUncheckedCreateWithoutObservationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutObservationsInput
    upsert?: UserUpsertWithoutObservationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutObservationsInput, UserUpdateWithoutObservationsInput>, UserUncheckedUpdateWithoutObservationsInput>
  }

  export type CostActaUpdateOneRequiredWithoutObservationsNestedInput = {
    create?: XOR<CostActaCreateWithoutObservationsInput, CostActaUncheckedCreateWithoutObservationsInput>
    connectOrCreate?: CostActaCreateOrConnectWithoutObservationsInput
    upsert?: CostActaUpsertWithoutObservationsInput
    connect?: CostActaWhereUniqueInput
    update?: XOR<XOR<CostActaUpdateToOneWithWhereWithoutObservationsInput, CostActaUpdateWithoutObservationsInput>, CostActaUncheckedUpdateWithoutObservationsInput>
  }

  export type UserCreateNestedOneWithoutReportsInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    connect?: UserWhereUniqueInput
  }

  export type AttachmentCreateNestedManyWithoutReportInput = {
    create?: XOR<AttachmentCreateWithoutReportInput, AttachmentUncheckedCreateWithoutReportInput> | AttachmentCreateWithoutReportInput[] | AttachmentUncheckedCreateWithoutReportInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutReportInput | AttachmentCreateOrConnectWithoutReportInput[]
    createMany?: AttachmentCreateManyReportInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type SignatureCreateNestedManyWithoutReportInput = {
    create?: XOR<SignatureCreateWithoutReportInput, SignatureUncheckedCreateWithoutReportInput> | SignatureCreateWithoutReportInput[] | SignatureUncheckedCreateWithoutReportInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutReportInput | SignatureCreateOrConnectWithoutReportInput[]
    createMany?: SignatureCreateManyReportInputEnvelope
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutReportInput = {
    create?: XOR<AttachmentCreateWithoutReportInput, AttachmentUncheckedCreateWithoutReportInput> | AttachmentCreateWithoutReportInput[] | AttachmentUncheckedCreateWithoutReportInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutReportInput | AttachmentCreateOrConnectWithoutReportInput[]
    createMany?: AttachmentCreateManyReportInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type SignatureUncheckedCreateNestedManyWithoutReportInput = {
    create?: XOR<SignatureCreateWithoutReportInput, SignatureUncheckedCreateWithoutReportInput> | SignatureCreateWithoutReportInput[] | SignatureUncheckedCreateWithoutReportInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutReportInput | SignatureCreateOrConnectWithoutReportInput[]
    createMany?: SignatureCreateManyReportInputEnvelope
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
  }

  export type EnumReportScopeFieldUpdateOperationsInput = {
    set?: $Enums.ReportScope
  }

  export type EnumReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReportStatus
  }

  export type UserUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    upsert?: UserUpsertWithoutReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportsInput, UserUpdateWithoutReportsInput>, UserUncheckedUpdateWithoutReportsInput>
  }

  export type AttachmentUpdateManyWithoutReportNestedInput = {
    create?: XOR<AttachmentCreateWithoutReportInput, AttachmentUncheckedCreateWithoutReportInput> | AttachmentCreateWithoutReportInput[] | AttachmentUncheckedCreateWithoutReportInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutReportInput | AttachmentCreateOrConnectWithoutReportInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutReportInput | AttachmentUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: AttachmentCreateManyReportInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutReportInput | AttachmentUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutReportInput | AttachmentUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type SignatureUpdateManyWithoutReportNestedInput = {
    create?: XOR<SignatureCreateWithoutReportInput, SignatureUncheckedCreateWithoutReportInput> | SignatureCreateWithoutReportInput[] | SignatureUncheckedCreateWithoutReportInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutReportInput | SignatureCreateOrConnectWithoutReportInput[]
    upsert?: SignatureUpsertWithWhereUniqueWithoutReportInput | SignatureUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: SignatureCreateManyReportInputEnvelope
    set?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    disconnect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    delete?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    update?: SignatureUpdateWithWhereUniqueWithoutReportInput | SignatureUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: SignatureUpdateManyWithWhereWithoutReportInput | SignatureUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: SignatureScalarWhereInput | SignatureScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutReportNestedInput = {
    create?: XOR<AttachmentCreateWithoutReportInput, AttachmentUncheckedCreateWithoutReportInput> | AttachmentCreateWithoutReportInput[] | AttachmentUncheckedCreateWithoutReportInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutReportInput | AttachmentCreateOrConnectWithoutReportInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutReportInput | AttachmentUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: AttachmentCreateManyReportInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutReportInput | AttachmentUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutReportInput | AttachmentUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type SignatureUncheckedUpdateManyWithoutReportNestedInput = {
    create?: XOR<SignatureCreateWithoutReportInput, SignatureUncheckedCreateWithoutReportInput> | SignatureCreateWithoutReportInput[] | SignatureUncheckedCreateWithoutReportInput[]
    connectOrCreate?: SignatureCreateOrConnectWithoutReportInput | SignatureCreateOrConnectWithoutReportInput[]
    upsert?: SignatureUpsertWithWhereUniqueWithoutReportInput | SignatureUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: SignatureCreateManyReportInputEnvelope
    set?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    disconnect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    delete?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    connect?: SignatureWhereUniqueInput | SignatureWhereUniqueInput[]
    update?: SignatureUpdateWithWhereUniqueWithoutReportInput | SignatureUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: SignatureUpdateManyWithWhereWithoutReportInput | SignatureUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: SignatureScalarWhereInput | SignatureScalarWhereInput[]
  }

  export type DrawingVersionCreateNestedManyWithoutDrawingInput = {
    create?: XOR<DrawingVersionCreateWithoutDrawingInput, DrawingVersionUncheckedCreateWithoutDrawingInput> | DrawingVersionCreateWithoutDrawingInput[] | DrawingVersionUncheckedCreateWithoutDrawingInput[]
    connectOrCreate?: DrawingVersionCreateOrConnectWithoutDrawingInput | DrawingVersionCreateOrConnectWithoutDrawingInput[]
    createMany?: DrawingVersionCreateManyDrawingInputEnvelope
    connect?: DrawingVersionWhereUniqueInput | DrawingVersionWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutDrawingInput = {
    create?: XOR<CommentCreateWithoutDrawingInput, CommentUncheckedCreateWithoutDrawingInput> | CommentCreateWithoutDrawingInput[] | CommentUncheckedCreateWithoutDrawingInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutDrawingInput | CommentCreateOrConnectWithoutDrawingInput[]
    createMany?: CommentCreateManyDrawingInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type DrawingVersionUncheckedCreateNestedManyWithoutDrawingInput = {
    create?: XOR<DrawingVersionCreateWithoutDrawingInput, DrawingVersionUncheckedCreateWithoutDrawingInput> | DrawingVersionCreateWithoutDrawingInput[] | DrawingVersionUncheckedCreateWithoutDrawingInput[]
    connectOrCreate?: DrawingVersionCreateOrConnectWithoutDrawingInput | DrawingVersionCreateOrConnectWithoutDrawingInput[]
    createMany?: DrawingVersionCreateManyDrawingInputEnvelope
    connect?: DrawingVersionWhereUniqueInput | DrawingVersionWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutDrawingInput = {
    create?: XOR<CommentCreateWithoutDrawingInput, CommentUncheckedCreateWithoutDrawingInput> | CommentCreateWithoutDrawingInput[] | CommentUncheckedCreateWithoutDrawingInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutDrawingInput | CommentCreateOrConnectWithoutDrawingInput[]
    createMany?: CommentCreateManyDrawingInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type EnumDrawingDisciplineFieldUpdateOperationsInput = {
    set?: $Enums.DrawingDiscipline
  }

  export type EnumDrawingStatusFieldUpdateOperationsInput = {
    set?: $Enums.DrawingStatus
  }

  export type DrawingVersionUpdateManyWithoutDrawingNestedInput = {
    create?: XOR<DrawingVersionCreateWithoutDrawingInput, DrawingVersionUncheckedCreateWithoutDrawingInput> | DrawingVersionCreateWithoutDrawingInput[] | DrawingVersionUncheckedCreateWithoutDrawingInput[]
    connectOrCreate?: DrawingVersionCreateOrConnectWithoutDrawingInput | DrawingVersionCreateOrConnectWithoutDrawingInput[]
    upsert?: DrawingVersionUpsertWithWhereUniqueWithoutDrawingInput | DrawingVersionUpsertWithWhereUniqueWithoutDrawingInput[]
    createMany?: DrawingVersionCreateManyDrawingInputEnvelope
    set?: DrawingVersionWhereUniqueInput | DrawingVersionWhereUniqueInput[]
    disconnect?: DrawingVersionWhereUniqueInput | DrawingVersionWhereUniqueInput[]
    delete?: DrawingVersionWhereUniqueInput | DrawingVersionWhereUniqueInput[]
    connect?: DrawingVersionWhereUniqueInput | DrawingVersionWhereUniqueInput[]
    update?: DrawingVersionUpdateWithWhereUniqueWithoutDrawingInput | DrawingVersionUpdateWithWhereUniqueWithoutDrawingInput[]
    updateMany?: DrawingVersionUpdateManyWithWhereWithoutDrawingInput | DrawingVersionUpdateManyWithWhereWithoutDrawingInput[]
    deleteMany?: DrawingVersionScalarWhereInput | DrawingVersionScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutDrawingNestedInput = {
    create?: XOR<CommentCreateWithoutDrawingInput, CommentUncheckedCreateWithoutDrawingInput> | CommentCreateWithoutDrawingInput[] | CommentUncheckedCreateWithoutDrawingInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutDrawingInput | CommentCreateOrConnectWithoutDrawingInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutDrawingInput | CommentUpsertWithWhereUniqueWithoutDrawingInput[]
    createMany?: CommentCreateManyDrawingInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutDrawingInput | CommentUpdateWithWhereUniqueWithoutDrawingInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutDrawingInput | CommentUpdateManyWithWhereWithoutDrawingInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type DrawingVersionUncheckedUpdateManyWithoutDrawingNestedInput = {
    create?: XOR<DrawingVersionCreateWithoutDrawingInput, DrawingVersionUncheckedCreateWithoutDrawingInput> | DrawingVersionCreateWithoutDrawingInput[] | DrawingVersionUncheckedCreateWithoutDrawingInput[]
    connectOrCreate?: DrawingVersionCreateOrConnectWithoutDrawingInput | DrawingVersionCreateOrConnectWithoutDrawingInput[]
    upsert?: DrawingVersionUpsertWithWhereUniqueWithoutDrawingInput | DrawingVersionUpsertWithWhereUniqueWithoutDrawingInput[]
    createMany?: DrawingVersionCreateManyDrawingInputEnvelope
    set?: DrawingVersionWhereUniqueInput | DrawingVersionWhereUniqueInput[]
    disconnect?: DrawingVersionWhereUniqueInput | DrawingVersionWhereUniqueInput[]
    delete?: DrawingVersionWhereUniqueInput | DrawingVersionWhereUniqueInput[]
    connect?: DrawingVersionWhereUniqueInput | DrawingVersionWhereUniqueInput[]
    update?: DrawingVersionUpdateWithWhereUniqueWithoutDrawingInput | DrawingVersionUpdateWithWhereUniqueWithoutDrawingInput[]
    updateMany?: DrawingVersionUpdateManyWithWhereWithoutDrawingInput | DrawingVersionUpdateManyWithWhereWithoutDrawingInput[]
    deleteMany?: DrawingVersionScalarWhereInput | DrawingVersionScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutDrawingNestedInput = {
    create?: XOR<CommentCreateWithoutDrawingInput, CommentUncheckedCreateWithoutDrawingInput> | CommentCreateWithoutDrawingInput[] | CommentUncheckedCreateWithoutDrawingInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutDrawingInput | CommentCreateOrConnectWithoutDrawingInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutDrawingInput | CommentUpsertWithWhereUniqueWithoutDrawingInput[]
    createMany?: CommentCreateManyDrawingInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutDrawingInput | CommentUpdateWithWhereUniqueWithoutDrawingInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutDrawingInput | CommentUpdateManyWithWhereWithoutDrawingInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDrawingVersionsInput = {
    create?: XOR<UserCreateWithoutDrawingVersionsInput, UserUncheckedCreateWithoutDrawingVersionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDrawingVersionsInput
    connect?: UserWhereUniqueInput
  }

  export type DrawingCreateNestedOneWithoutVersionsInput = {
    create?: XOR<DrawingCreateWithoutVersionsInput, DrawingUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: DrawingCreateOrConnectWithoutVersionsInput
    connect?: DrawingWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDrawingVersionsNestedInput = {
    create?: XOR<UserCreateWithoutDrawingVersionsInput, UserUncheckedCreateWithoutDrawingVersionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDrawingVersionsInput
    upsert?: UserUpsertWithoutDrawingVersionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDrawingVersionsInput, UserUpdateWithoutDrawingVersionsInput>, UserUncheckedUpdateWithoutDrawingVersionsInput>
  }

  export type DrawingUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<DrawingCreateWithoutVersionsInput, DrawingUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: DrawingCreateOrConnectWithoutVersionsInput
    upsert?: DrawingUpsertWithoutVersionsInput
    connect?: DrawingWhereUniqueInput
    update?: XOR<XOR<DrawingUpdateToOneWithWhereWithoutVersionsInput, DrawingUpdateWithoutVersionsInput>, DrawingUncheckedUpdateWithoutVersionsInput>
  }

  export type UserCreateNestedOneWithoutPhotoEntriesInput = {
    create?: XOR<UserCreateWithoutPhotoEntriesInput, UserUncheckedCreateWithoutPhotoEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPhotoEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type ControlPointCreateNestedOneWithoutPhotosInput = {
    create?: XOR<ControlPointCreateWithoutPhotosInput, ControlPointUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ControlPointCreateOrConnectWithoutPhotosInput
    connect?: ControlPointWhereUniqueInput
  }

  export type AttachmentCreateNestedOneWithoutPhotoEntryInput = {
    create?: XOR<AttachmentCreateWithoutPhotoEntryInput, AttachmentUncheckedCreateWithoutPhotoEntryInput>
    connectOrCreate?: AttachmentCreateOrConnectWithoutPhotoEntryInput
    connect?: AttachmentWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPhotoEntriesNestedInput = {
    create?: XOR<UserCreateWithoutPhotoEntriesInput, UserUncheckedCreateWithoutPhotoEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPhotoEntriesInput
    upsert?: UserUpsertWithoutPhotoEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPhotoEntriesInput, UserUpdateWithoutPhotoEntriesInput>, UserUncheckedUpdateWithoutPhotoEntriesInput>
  }

  export type ControlPointUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<ControlPointCreateWithoutPhotosInput, ControlPointUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ControlPointCreateOrConnectWithoutPhotosInput
    upsert?: ControlPointUpsertWithoutPhotosInput
    connect?: ControlPointWhereUniqueInput
    update?: XOR<XOR<ControlPointUpdateToOneWithWhereWithoutPhotosInput, ControlPointUpdateWithoutPhotosInput>, ControlPointUncheckedUpdateWithoutPhotosInput>
  }

  export type AttachmentUpdateOneWithoutPhotoEntryNestedInput = {
    create?: XOR<AttachmentCreateWithoutPhotoEntryInput, AttachmentUncheckedCreateWithoutPhotoEntryInput>
    connectOrCreate?: AttachmentCreateOrConnectWithoutPhotoEntryInput
    upsert?: AttachmentUpsertWithoutPhotoEntryInput
    disconnect?: AttachmentWhereInput | boolean
    delete?: AttachmentWhereInput | boolean
    connect?: AttachmentWhereUniqueInput
    update?: XOR<XOR<AttachmentUpdateToOneWithWhereWithoutPhotoEntryInput, AttachmentUpdateWithoutPhotoEntryInput>, AttachmentUncheckedUpdateWithoutPhotoEntryInput>
  }

  export type PhotoEntryCreateNestedManyWithoutControlPointInput = {
    create?: XOR<PhotoEntryCreateWithoutControlPointInput, PhotoEntryUncheckedCreateWithoutControlPointInput> | PhotoEntryCreateWithoutControlPointInput[] | PhotoEntryUncheckedCreateWithoutControlPointInput[]
    connectOrCreate?: PhotoEntryCreateOrConnectWithoutControlPointInput | PhotoEntryCreateOrConnectWithoutControlPointInput[]
    createMany?: PhotoEntryCreateManyControlPointInputEnvelope
    connect?: PhotoEntryWhereUniqueInput | PhotoEntryWhereUniqueInput[]
  }

  export type PhotoEntryUncheckedCreateNestedManyWithoutControlPointInput = {
    create?: XOR<PhotoEntryCreateWithoutControlPointInput, PhotoEntryUncheckedCreateWithoutControlPointInput> | PhotoEntryCreateWithoutControlPointInput[] | PhotoEntryUncheckedCreateWithoutControlPointInput[]
    connectOrCreate?: PhotoEntryCreateOrConnectWithoutControlPointInput | PhotoEntryCreateOrConnectWithoutControlPointInput[]
    createMany?: PhotoEntryCreateManyControlPointInputEnvelope
    connect?: PhotoEntryWhereUniqueInput | PhotoEntryWhereUniqueInput[]
  }

  export type PhotoEntryUpdateManyWithoutControlPointNestedInput = {
    create?: XOR<PhotoEntryCreateWithoutControlPointInput, PhotoEntryUncheckedCreateWithoutControlPointInput> | PhotoEntryCreateWithoutControlPointInput[] | PhotoEntryUncheckedCreateWithoutControlPointInput[]
    connectOrCreate?: PhotoEntryCreateOrConnectWithoutControlPointInput | PhotoEntryCreateOrConnectWithoutControlPointInput[]
    upsert?: PhotoEntryUpsertWithWhereUniqueWithoutControlPointInput | PhotoEntryUpsertWithWhereUniqueWithoutControlPointInput[]
    createMany?: PhotoEntryCreateManyControlPointInputEnvelope
    set?: PhotoEntryWhereUniqueInput | PhotoEntryWhereUniqueInput[]
    disconnect?: PhotoEntryWhereUniqueInput | PhotoEntryWhereUniqueInput[]
    delete?: PhotoEntryWhereUniqueInput | PhotoEntryWhereUniqueInput[]
    connect?: PhotoEntryWhereUniqueInput | PhotoEntryWhereUniqueInput[]
    update?: PhotoEntryUpdateWithWhereUniqueWithoutControlPointInput | PhotoEntryUpdateWithWhereUniqueWithoutControlPointInput[]
    updateMany?: PhotoEntryUpdateManyWithWhereWithoutControlPointInput | PhotoEntryUpdateManyWithWhereWithoutControlPointInput[]
    deleteMany?: PhotoEntryScalarWhereInput | PhotoEntryScalarWhereInput[]
  }

  export type PhotoEntryUncheckedUpdateManyWithoutControlPointNestedInput = {
    create?: XOR<PhotoEntryCreateWithoutControlPointInput, PhotoEntryUncheckedCreateWithoutControlPointInput> | PhotoEntryCreateWithoutControlPointInput[] | PhotoEntryUncheckedCreateWithoutControlPointInput[]
    connectOrCreate?: PhotoEntryCreateOrConnectWithoutControlPointInput | PhotoEntryCreateOrConnectWithoutControlPointInput[]
    upsert?: PhotoEntryUpsertWithWhereUniqueWithoutControlPointInput | PhotoEntryUpsertWithWhereUniqueWithoutControlPointInput[]
    createMany?: PhotoEntryCreateManyControlPointInputEnvelope
    set?: PhotoEntryWhereUniqueInput | PhotoEntryWhereUniqueInput[]
    disconnect?: PhotoEntryWhereUniqueInput | PhotoEntryWhereUniqueInput[]
    delete?: PhotoEntryWhereUniqueInput | PhotoEntryWhereUniqueInput[]
    connect?: PhotoEntryWhereUniqueInput | PhotoEntryWhereUniqueInput[]
    update?: PhotoEntryUpdateWithWhereUniqueWithoutControlPointInput | PhotoEntryUpdateWithWhereUniqueWithoutControlPointInput[]
    updateMany?: PhotoEntryUpdateManyWithWhereWithoutControlPointInput | PhotoEntryUpdateManyWithWhereWithoutControlPointInput[]
    deleteMany?: PhotoEntryScalarWhereInput | PhotoEntryScalarWhereInput[]
  }

  export type WorkActaItemCreateNestedManyWithoutContractItemInput = {
    create?: XOR<WorkActaItemCreateWithoutContractItemInput, WorkActaItemUncheckedCreateWithoutContractItemInput> | WorkActaItemCreateWithoutContractItemInput[] | WorkActaItemUncheckedCreateWithoutContractItemInput[]
    connectOrCreate?: WorkActaItemCreateOrConnectWithoutContractItemInput | WorkActaItemCreateOrConnectWithoutContractItemInput[]
    createMany?: WorkActaItemCreateManyContractItemInputEnvelope
    connect?: WorkActaItemWhereUniqueInput | WorkActaItemWhereUniqueInput[]
  }

  export type WorkActaItemUncheckedCreateNestedManyWithoutContractItemInput = {
    create?: XOR<WorkActaItemCreateWithoutContractItemInput, WorkActaItemUncheckedCreateWithoutContractItemInput> | WorkActaItemCreateWithoutContractItemInput[] | WorkActaItemUncheckedCreateWithoutContractItemInput[]
    connectOrCreate?: WorkActaItemCreateOrConnectWithoutContractItemInput | WorkActaItemCreateOrConnectWithoutContractItemInput[]
    createMany?: WorkActaItemCreateManyContractItemInputEnvelope
    connect?: WorkActaItemWhereUniqueInput | WorkActaItemWhereUniqueInput[]
  }

  export type WorkActaItemUpdateManyWithoutContractItemNestedInput = {
    create?: XOR<WorkActaItemCreateWithoutContractItemInput, WorkActaItemUncheckedCreateWithoutContractItemInput> | WorkActaItemCreateWithoutContractItemInput[] | WorkActaItemUncheckedCreateWithoutContractItemInput[]
    connectOrCreate?: WorkActaItemCreateOrConnectWithoutContractItemInput | WorkActaItemCreateOrConnectWithoutContractItemInput[]
    upsert?: WorkActaItemUpsertWithWhereUniqueWithoutContractItemInput | WorkActaItemUpsertWithWhereUniqueWithoutContractItemInput[]
    createMany?: WorkActaItemCreateManyContractItemInputEnvelope
    set?: WorkActaItemWhereUniqueInput | WorkActaItemWhereUniqueInput[]
    disconnect?: WorkActaItemWhereUniqueInput | WorkActaItemWhereUniqueInput[]
    delete?: WorkActaItemWhereUniqueInput | WorkActaItemWhereUniqueInput[]
    connect?: WorkActaItemWhereUniqueInput | WorkActaItemWhereUniqueInput[]
    update?: WorkActaItemUpdateWithWhereUniqueWithoutContractItemInput | WorkActaItemUpdateWithWhereUniqueWithoutContractItemInput[]
    updateMany?: WorkActaItemUpdateManyWithWhereWithoutContractItemInput | WorkActaItemUpdateManyWithWhereWithoutContractItemInput[]
    deleteMany?: WorkActaItemScalarWhereInput | WorkActaItemScalarWhereInput[]
  }

  export type WorkActaItemUncheckedUpdateManyWithoutContractItemNestedInput = {
    create?: XOR<WorkActaItemCreateWithoutContractItemInput, WorkActaItemUncheckedCreateWithoutContractItemInput> | WorkActaItemCreateWithoutContractItemInput[] | WorkActaItemUncheckedCreateWithoutContractItemInput[]
    connectOrCreate?: WorkActaItemCreateOrConnectWithoutContractItemInput | WorkActaItemCreateOrConnectWithoutContractItemInput[]
    upsert?: WorkActaItemUpsertWithWhereUniqueWithoutContractItemInput | WorkActaItemUpsertWithWhereUniqueWithoutContractItemInput[]
    createMany?: WorkActaItemCreateManyContractItemInputEnvelope
    set?: WorkActaItemWhereUniqueInput | WorkActaItemWhereUniqueInput[]
    disconnect?: WorkActaItemWhereUniqueInput | WorkActaItemWhereUniqueInput[]
    delete?: WorkActaItemWhereUniqueInput | WorkActaItemWhereUniqueInput[]
    connect?: WorkActaItemWhereUniqueInput | WorkActaItemWhereUniqueInput[]
    update?: WorkActaItemUpdateWithWhereUniqueWithoutContractItemInput | WorkActaItemUpdateWithWhereUniqueWithoutContractItemInput[]
    updateMany?: WorkActaItemUpdateManyWithWhereWithoutContractItemInput | WorkActaItemUpdateManyWithWhereWithoutContractItemInput[]
    deleteMany?: WorkActaItemScalarWhereInput | WorkActaItemScalarWhereInput[]
  }

  export type WorkActaItemCreateNestedManyWithoutWorkActaInput = {
    create?: XOR<WorkActaItemCreateWithoutWorkActaInput, WorkActaItemUncheckedCreateWithoutWorkActaInput> | WorkActaItemCreateWithoutWorkActaInput[] | WorkActaItemUncheckedCreateWithoutWorkActaInput[]
    connectOrCreate?: WorkActaItemCreateOrConnectWithoutWorkActaInput | WorkActaItemCreateOrConnectWithoutWorkActaInput[]
    createMany?: WorkActaItemCreateManyWorkActaInputEnvelope
    connect?: WorkActaItemWhereUniqueInput | WorkActaItemWhereUniqueInput[]
  }

  export type AttachmentCreateNestedManyWithoutWorkActaInput = {
    create?: XOR<AttachmentCreateWithoutWorkActaInput, AttachmentUncheckedCreateWithoutWorkActaInput> | AttachmentCreateWithoutWorkActaInput[] | AttachmentUncheckedCreateWithoutWorkActaInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutWorkActaInput | AttachmentCreateOrConnectWithoutWorkActaInput[]
    createMany?: AttachmentCreateManyWorkActaInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type WorkActaItemUncheckedCreateNestedManyWithoutWorkActaInput = {
    create?: XOR<WorkActaItemCreateWithoutWorkActaInput, WorkActaItemUncheckedCreateWithoutWorkActaInput> | WorkActaItemCreateWithoutWorkActaInput[] | WorkActaItemUncheckedCreateWithoutWorkActaInput[]
    connectOrCreate?: WorkActaItemCreateOrConnectWithoutWorkActaInput | WorkActaItemCreateOrConnectWithoutWorkActaInput[]
    createMany?: WorkActaItemCreateManyWorkActaInputEnvelope
    connect?: WorkActaItemWhereUniqueInput | WorkActaItemWhereUniqueInput[]
  }

  export type AttachmentUncheckedCreateNestedManyWithoutWorkActaInput = {
    create?: XOR<AttachmentCreateWithoutWorkActaInput, AttachmentUncheckedCreateWithoutWorkActaInput> | AttachmentCreateWithoutWorkActaInput[] | AttachmentUncheckedCreateWithoutWorkActaInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutWorkActaInput | AttachmentCreateOrConnectWithoutWorkActaInput[]
    createMany?: AttachmentCreateManyWorkActaInputEnvelope
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
  }

  export type EnumWorkActaStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkActaStatus
  }

  export type WorkActaItemUpdateManyWithoutWorkActaNestedInput = {
    create?: XOR<WorkActaItemCreateWithoutWorkActaInput, WorkActaItemUncheckedCreateWithoutWorkActaInput> | WorkActaItemCreateWithoutWorkActaInput[] | WorkActaItemUncheckedCreateWithoutWorkActaInput[]
    connectOrCreate?: WorkActaItemCreateOrConnectWithoutWorkActaInput | WorkActaItemCreateOrConnectWithoutWorkActaInput[]
    upsert?: WorkActaItemUpsertWithWhereUniqueWithoutWorkActaInput | WorkActaItemUpsertWithWhereUniqueWithoutWorkActaInput[]
    createMany?: WorkActaItemCreateManyWorkActaInputEnvelope
    set?: WorkActaItemWhereUniqueInput | WorkActaItemWhereUniqueInput[]
    disconnect?: WorkActaItemWhereUniqueInput | WorkActaItemWhereUniqueInput[]
    delete?: WorkActaItemWhereUniqueInput | WorkActaItemWhereUniqueInput[]
    connect?: WorkActaItemWhereUniqueInput | WorkActaItemWhereUniqueInput[]
    update?: WorkActaItemUpdateWithWhereUniqueWithoutWorkActaInput | WorkActaItemUpdateWithWhereUniqueWithoutWorkActaInput[]
    updateMany?: WorkActaItemUpdateManyWithWhereWithoutWorkActaInput | WorkActaItemUpdateManyWithWhereWithoutWorkActaInput[]
    deleteMany?: WorkActaItemScalarWhereInput | WorkActaItemScalarWhereInput[]
  }

  export type AttachmentUpdateManyWithoutWorkActaNestedInput = {
    create?: XOR<AttachmentCreateWithoutWorkActaInput, AttachmentUncheckedCreateWithoutWorkActaInput> | AttachmentCreateWithoutWorkActaInput[] | AttachmentUncheckedCreateWithoutWorkActaInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutWorkActaInput | AttachmentCreateOrConnectWithoutWorkActaInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutWorkActaInput | AttachmentUpsertWithWhereUniqueWithoutWorkActaInput[]
    createMany?: AttachmentCreateManyWorkActaInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutWorkActaInput | AttachmentUpdateWithWhereUniqueWithoutWorkActaInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutWorkActaInput | AttachmentUpdateManyWithWhereWithoutWorkActaInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type WorkActaItemUncheckedUpdateManyWithoutWorkActaNestedInput = {
    create?: XOR<WorkActaItemCreateWithoutWorkActaInput, WorkActaItemUncheckedCreateWithoutWorkActaInput> | WorkActaItemCreateWithoutWorkActaInput[] | WorkActaItemUncheckedCreateWithoutWorkActaInput[]
    connectOrCreate?: WorkActaItemCreateOrConnectWithoutWorkActaInput | WorkActaItemCreateOrConnectWithoutWorkActaInput[]
    upsert?: WorkActaItemUpsertWithWhereUniqueWithoutWorkActaInput | WorkActaItemUpsertWithWhereUniqueWithoutWorkActaInput[]
    createMany?: WorkActaItemCreateManyWorkActaInputEnvelope
    set?: WorkActaItemWhereUniqueInput | WorkActaItemWhereUniqueInput[]
    disconnect?: WorkActaItemWhereUniqueInput | WorkActaItemWhereUniqueInput[]
    delete?: WorkActaItemWhereUniqueInput | WorkActaItemWhereUniqueInput[]
    connect?: WorkActaItemWhereUniqueInput | WorkActaItemWhereUniqueInput[]
    update?: WorkActaItemUpdateWithWhereUniqueWithoutWorkActaInput | WorkActaItemUpdateWithWhereUniqueWithoutWorkActaInput[]
    updateMany?: WorkActaItemUpdateManyWithWhereWithoutWorkActaInput | WorkActaItemUpdateManyWithWhereWithoutWorkActaInput[]
    deleteMany?: WorkActaItemScalarWhereInput | WorkActaItemScalarWhereInput[]
  }

  export type AttachmentUncheckedUpdateManyWithoutWorkActaNestedInput = {
    create?: XOR<AttachmentCreateWithoutWorkActaInput, AttachmentUncheckedCreateWithoutWorkActaInput> | AttachmentCreateWithoutWorkActaInput[] | AttachmentUncheckedCreateWithoutWorkActaInput[]
    connectOrCreate?: AttachmentCreateOrConnectWithoutWorkActaInput | AttachmentCreateOrConnectWithoutWorkActaInput[]
    upsert?: AttachmentUpsertWithWhereUniqueWithoutWorkActaInput | AttachmentUpsertWithWhereUniqueWithoutWorkActaInput[]
    createMany?: AttachmentCreateManyWorkActaInputEnvelope
    set?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    disconnect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    delete?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    connect?: AttachmentWhereUniqueInput | AttachmentWhereUniqueInput[]
    update?: AttachmentUpdateWithWhereUniqueWithoutWorkActaInput | AttachmentUpdateWithWhereUniqueWithoutWorkActaInput[]
    updateMany?: AttachmentUpdateManyWithWhereWithoutWorkActaInput | AttachmentUpdateManyWithWhereWithoutWorkActaInput[]
    deleteMany?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
  }

  export type WorkActaCreateNestedOneWithoutItemsInput = {
    create?: XOR<WorkActaCreateWithoutItemsInput, WorkActaUncheckedCreateWithoutItemsInput>
    connectOrCreate?: WorkActaCreateOrConnectWithoutItemsInput
    connect?: WorkActaWhereUniqueInput
  }

  export type ContractItemCreateNestedOneWithoutWorkActaItemsInput = {
    create?: XOR<ContractItemCreateWithoutWorkActaItemsInput, ContractItemUncheckedCreateWithoutWorkActaItemsInput>
    connectOrCreate?: ContractItemCreateOrConnectWithoutWorkActaItemsInput
    connect?: ContractItemWhereUniqueInput
  }

  export type WorkActaUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<WorkActaCreateWithoutItemsInput, WorkActaUncheckedCreateWithoutItemsInput>
    connectOrCreate?: WorkActaCreateOrConnectWithoutItemsInput
    upsert?: WorkActaUpsertWithoutItemsInput
    connect?: WorkActaWhereUniqueInput
    update?: XOR<XOR<WorkActaUpdateToOneWithWhereWithoutItemsInput, WorkActaUpdateWithoutItemsInput>, WorkActaUncheckedUpdateWithoutItemsInput>
  }

  export type ContractItemUpdateOneRequiredWithoutWorkActaItemsNestedInput = {
    create?: XOR<ContractItemCreateWithoutWorkActaItemsInput, ContractItemUncheckedCreateWithoutWorkActaItemsInput>
    connectOrCreate?: ContractItemCreateOrConnectWithoutWorkActaItemsInput
    upsert?: ContractItemUpsertWithoutWorkActaItemsInput
    connect?: ContractItemWhereUniqueInput
    update?: XOR<XOR<ContractItemUpdateToOneWithWhereWithoutWorkActaItemsInput, ContractItemUpdateWithoutWorkActaItemsInput>, ContractItemUncheckedUpdateWithoutWorkActaItemsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumAppRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.AppRole | EnumAppRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AppRole[]
    notIn?: $Enums.AppRole[]
    not?: NestedEnumAppRoleFilter<$PrismaModel> | $Enums.AppRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumAppRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppRole | EnumAppRoleFieldRefInput<$PrismaModel>
    in?: $Enums.AppRole[]
    notIn?: $Enums.AppRole[]
    not?: NestedEnumAppRoleWithAggregatesFilter<$PrismaModel> | $Enums.AppRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppRoleFilter<$PrismaModel>
    _max?: NestedEnumAppRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumDeliveryMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryMethod | EnumDeliveryMethodFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryMethod[]
    notIn?: $Enums.DeliveryMethod[]
    not?: NestedEnumDeliveryMethodFilter<$PrismaModel> | $Enums.DeliveryMethod
  }

  export type NestedEnumCommunicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationStatus | EnumCommunicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationStatus[]
    notIn?: $Enums.CommunicationStatus[]
    not?: NestedEnumCommunicationStatusFilter<$PrismaModel> | $Enums.CommunicationStatus
  }

  export type NestedEnumDeliveryMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryMethod | EnumDeliveryMethodFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryMethod[]
    notIn?: $Enums.DeliveryMethod[]
    not?: NestedEnumDeliveryMethodWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryMethodFilter<$PrismaModel>
    _max?: NestedEnumDeliveryMethodFilter<$PrismaModel>
  }

  export type NestedEnumCommunicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommunicationStatus | EnumCommunicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommunicationStatus[]
    notIn?: $Enums.CommunicationStatus[]
    not?: NestedEnumCommunicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.CommunicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommunicationStatusFilter<$PrismaModel>
    _max?: NestedEnumCommunicationStatusFilter<$PrismaModel>
  }

  export type NestedEnumModificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ModificationType | EnumModificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ModificationType[]
    notIn?: $Enums.ModificationType[]
    not?: NestedEnumModificationTypeFilter<$PrismaModel> | $Enums.ModificationType
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumModificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModificationType | EnumModificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ModificationType[]
    notIn?: $Enums.ModificationType[]
    not?: NestedEnumModificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ModificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModificationTypeFilter<$PrismaModel>
    _max?: NestedEnumModificationTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumEntryTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EntryType | EnumEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntryType[]
    notIn?: $Enums.EntryType[]
    not?: NestedEnumEntryTypeFilter<$PrismaModel> | $Enums.EntryType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumEntryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EntryStatus | EnumEntryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EntryStatus[]
    notIn?: $Enums.EntryStatus[]
    not?: NestedEnumEntryStatusFilter<$PrismaModel> | $Enums.EntryStatus
  }

  export type NestedEnumEntryTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntryType | EnumEntryTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntryType[]
    notIn?: $Enums.EntryType[]
    not?: NestedEnumEntryTypeWithAggregatesFilter<$PrismaModel> | $Enums.EntryType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntryTypeFilter<$PrismaModel>
    _max?: NestedEnumEntryTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumEntryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntryStatus | EnumEntryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EntryStatus[]
    notIn?: $Enums.EntryStatus[]
    not?: NestedEnumEntryStatusWithAggregatesFilter<$PrismaModel> | $Enums.EntryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntryStatusFilter<$PrismaModel>
    _max?: NestedEnumEntryStatusFilter<$PrismaModel>
  }

  export type NestedEnumActaAreaFilter<$PrismaModel = never> = {
    equals?: $Enums.ActaArea | EnumActaAreaFieldRefInput<$PrismaModel>
    in?: $Enums.ActaArea[]
    notIn?: $Enums.ActaArea[]
    not?: NestedEnumActaAreaFilter<$PrismaModel> | $Enums.ActaArea
  }

  export type NestedEnumActaStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ActaStatus | EnumActaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActaStatus[]
    notIn?: $Enums.ActaStatus[]
    not?: NestedEnumActaStatusFilter<$PrismaModel> | $Enums.ActaStatus
  }

  export type NestedEnumActaAreaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActaArea | EnumActaAreaFieldRefInput<$PrismaModel>
    in?: $Enums.ActaArea[]
    notIn?: $Enums.ActaArea[]
    not?: NestedEnumActaAreaWithAggregatesFilter<$PrismaModel> | $Enums.ActaArea
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActaAreaFilter<$PrismaModel>
    _max?: NestedEnumActaAreaFilter<$PrismaModel>
  }

  export type NestedEnumActaStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActaStatus | EnumActaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActaStatus[]
    notIn?: $Enums.ActaStatus[]
    not?: NestedEnumActaStatusWithAggregatesFilter<$PrismaModel> | $Enums.ActaStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActaStatusFilter<$PrismaModel>
    _max?: NestedEnumActaStatusFilter<$PrismaModel>
  }

  export type NestedEnumCommitmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CommitmentStatus | EnumCommitmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommitmentStatus[]
    notIn?: $Enums.CommitmentStatus[]
    not?: NestedEnumCommitmentStatusFilter<$PrismaModel> | $Enums.CommitmentStatus
  }

  export type NestedEnumCommitmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommitmentStatus | EnumCommitmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommitmentStatus[]
    notIn?: $Enums.CommitmentStatus[]
    not?: NestedEnumCommitmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.CommitmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommitmentStatusFilter<$PrismaModel>
    _max?: NestedEnumCommitmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumCostActaStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CostActaStatus | EnumCostActaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CostActaStatus[]
    notIn?: $Enums.CostActaStatus[]
    not?: NestedEnumCostActaStatusFilter<$PrismaModel> | $Enums.CostActaStatus
  }

  export type NestedEnumCostActaStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CostActaStatus | EnumCostActaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CostActaStatus[]
    notIn?: $Enums.CostActaStatus[]
    not?: NestedEnumCostActaStatusWithAggregatesFilter<$PrismaModel> | $Enums.CostActaStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCostActaStatusFilter<$PrismaModel>
    _max?: NestedEnumCostActaStatusFilter<$PrismaModel>
  }

  export type NestedEnumReportScopeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportScope | EnumReportScopeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportScope[]
    notIn?: $Enums.ReportScope[]
    not?: NestedEnumReportScopeFilter<$PrismaModel> | $Enums.ReportScope
  }

  export type NestedEnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[]
    notIn?: $Enums.ReportStatus[]
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type NestedEnumReportScopeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportScope | EnumReportScopeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportScope[]
    notIn?: $Enums.ReportScope[]
    not?: NestedEnumReportScopeWithAggregatesFilter<$PrismaModel> | $Enums.ReportScope
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportScopeFilter<$PrismaModel>
    _max?: NestedEnumReportScopeFilter<$PrismaModel>
  }

  export type NestedEnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[]
    notIn?: $Enums.ReportStatus[]
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type NestedEnumDrawingDisciplineFilter<$PrismaModel = never> = {
    equals?: $Enums.DrawingDiscipline | EnumDrawingDisciplineFieldRefInput<$PrismaModel>
    in?: $Enums.DrawingDiscipline[]
    notIn?: $Enums.DrawingDiscipline[]
    not?: NestedEnumDrawingDisciplineFilter<$PrismaModel> | $Enums.DrawingDiscipline
  }

  export type NestedEnumDrawingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DrawingStatus | EnumDrawingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DrawingStatus[]
    notIn?: $Enums.DrawingStatus[]
    not?: NestedEnumDrawingStatusFilter<$PrismaModel> | $Enums.DrawingStatus
  }

  export type NestedEnumDrawingDisciplineWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DrawingDiscipline | EnumDrawingDisciplineFieldRefInput<$PrismaModel>
    in?: $Enums.DrawingDiscipline[]
    notIn?: $Enums.DrawingDiscipline[]
    not?: NestedEnumDrawingDisciplineWithAggregatesFilter<$PrismaModel> | $Enums.DrawingDiscipline
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDrawingDisciplineFilter<$PrismaModel>
    _max?: NestedEnumDrawingDisciplineFilter<$PrismaModel>
  }

  export type NestedEnumDrawingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DrawingStatus | EnumDrawingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DrawingStatus[]
    notIn?: $Enums.DrawingStatus[]
    not?: NestedEnumDrawingStatusWithAggregatesFilter<$PrismaModel> | $Enums.DrawingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDrawingStatusFilter<$PrismaModel>
    _max?: NestedEnumDrawingStatusFilter<$PrismaModel>
  }

  export type NestedEnumWorkActaStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkActaStatus | EnumWorkActaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkActaStatus[]
    notIn?: $Enums.WorkActaStatus[]
    not?: NestedEnumWorkActaStatusFilter<$PrismaModel> | $Enums.WorkActaStatus
  }

  export type NestedEnumWorkActaStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkActaStatus | EnumWorkActaStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkActaStatus[]
    notIn?: $Enums.WorkActaStatus[]
    not?: NestedEnumWorkActaStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkActaStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkActaStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkActaStatusFilter<$PrismaModel>
  }

  export type LogEntryCreateWithoutAuthorInput = {
    id?: string
    folioNumber?: number
    title: string
    description: string
    type: $Enums.EntryType
    subject: string
    location: string
    activityStartDate: Date | string
    activityEndDate: Date | string
    isConfidential?: boolean
    status: $Enums.EntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutLogEntriesInput
    assignees?: UserCreateNestedManyWithoutAssignedToInput
    comments?: CommentCreateNestedManyWithoutLogEntryInput
    attachments?: AttachmentCreateNestedManyWithoutLogEntryInput
    signatures?: SignatureCreateNestedManyWithoutLogEntryInput
    history?: LogEntryHistoryCreateNestedManyWithoutLogEntryInput
  }

  export type LogEntryUncheckedCreateWithoutAuthorInput = {
    id?: string
    folioNumber?: number
    title: string
    description: string
    type: $Enums.EntryType
    subject: string
    location: string
    activityStartDate: Date | string
    activityEndDate: Date | string
    isConfidential?: boolean
    status: $Enums.EntryStatus
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignees?: UserUncheckedCreateNestedManyWithoutAssignedToInput
    comments?: CommentUncheckedCreateNestedManyWithoutLogEntryInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutLogEntryInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutLogEntryInput
    history?: LogEntryHistoryUncheckedCreateNestedManyWithoutLogEntryInput
  }

  export type LogEntryCreateOrConnectWithoutAuthorInput = {
    where: LogEntryWhereUniqueInput
    create: XOR<LogEntryCreateWithoutAuthorInput, LogEntryUncheckedCreateWithoutAuthorInput>
  }

  export type LogEntryCreateManyAuthorInputEnvelope = {
    data: LogEntryCreateManyAuthorInput | LogEntryCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type LogEntryCreateWithoutAssigneesInput = {
    id?: string
    folioNumber?: number
    title: string
    description: string
    type: $Enums.EntryType
    subject: string
    location: string
    activityStartDate: Date | string
    activityEndDate: Date | string
    isConfidential?: boolean
    status: $Enums.EntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutLogEntriesInput
    project: ProjectCreateNestedOneWithoutLogEntriesInput
    comments?: CommentCreateNestedManyWithoutLogEntryInput
    attachments?: AttachmentCreateNestedManyWithoutLogEntryInput
    signatures?: SignatureCreateNestedManyWithoutLogEntryInput
    history?: LogEntryHistoryCreateNestedManyWithoutLogEntryInput
  }

  export type LogEntryUncheckedCreateWithoutAssigneesInput = {
    id?: string
    folioNumber?: number
    title: string
    description: string
    type: $Enums.EntryType
    subject: string
    location: string
    activityStartDate: Date | string
    activityEndDate: Date | string
    isConfidential?: boolean
    status: $Enums.EntryStatus
    authorId: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutLogEntryInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutLogEntryInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutLogEntryInput
    history?: LogEntryHistoryUncheckedCreateNestedManyWithoutLogEntryInput
  }

  export type LogEntryCreateOrConnectWithoutAssigneesInput = {
    where: LogEntryWhereUniqueInput
    create: XOR<LogEntryCreateWithoutAssigneesInput, LogEntryUncheckedCreateWithoutAssigneesInput>
  }

  export type CommentCreateWithoutAuthorInput = {
    id?: string
    content: string
    timestamp?: Date | string
    logEntry?: LogEntryCreateNestedOneWithoutCommentsInput
    drawing?: DrawingCreateNestedOneWithoutCommentsInput
    attachments?: AttachmentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    content: string
    timestamp?: Date | string
    logEntryId?: string | null
    drawingId?: string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: CommentCreateManyAuthorInput | CommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type SignatureCreateWithoutSignerInput = {
    id?: string
    signedAt?: Date | string
    logEntry?: LogEntryCreateNestedOneWithoutSignaturesInput
    acta?: ActaCreateNestedOneWithoutSignaturesInput
    report?: ReportCreateNestedOneWithoutSignaturesInput
  }

  export type SignatureUncheckedCreateWithoutSignerInput = {
    id?: string
    signedAt?: Date | string
    logEntryId?: string | null
    actaId?: string | null
    reportId?: string | null
  }

  export type SignatureCreateOrConnectWithoutSignerInput = {
    where: SignatureWhereUniqueInput
    create: XOR<SignatureCreateWithoutSignerInput, SignatureUncheckedCreateWithoutSignerInput>
  }

  export type SignatureCreateManySignerInputEnvelope = {
    data: SignatureCreateManySignerInput | SignatureCreateManySignerInput[]
    skipDuplicates?: boolean
  }

  export type CommunicationCreateWithoutUploaderInput = {
    id?: string
    radicado: string
    subject: string
    description: string
    senderEntity: string
    senderName: string
    senderTitle: string
    recipientEntity: string
    recipientName: string
    recipientTitle: string
    signerName: string
    sentDate: Date | string
    dueDate?: Date | string | null
    deliveryMethod: $Enums.DeliveryMethod
    notes?: string | null
    status: $Enums.CommunicationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CommunicationCreateNestedOneWithoutRepliesInput
    replies?: CommunicationCreateNestedManyWithoutParentInput
    statusHistory?: CommunicationStatusHistoryCreateNestedManyWithoutCommunicationInput
    attachments?: AttachmentCreateNestedManyWithoutCommunicationInput
  }

  export type CommunicationUncheckedCreateWithoutUploaderInput = {
    id?: string
    radicado: string
    subject: string
    description: string
    senderEntity: string
    senderName: string
    senderTitle: string
    recipientEntity: string
    recipientName: string
    recipientTitle: string
    signerName: string
    sentDate: Date | string
    dueDate?: Date | string | null
    deliveryMethod: $Enums.DeliveryMethod
    notes?: string | null
    status: $Enums.CommunicationStatus
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommunicationUncheckedCreateNestedManyWithoutParentInput
    statusHistory?: CommunicationStatusHistoryUncheckedCreateNestedManyWithoutCommunicationInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutCommunicationInput
  }

  export type CommunicationCreateOrConnectWithoutUploaderInput = {
    where: CommunicationWhereUniqueInput
    create: XOR<CommunicationCreateWithoutUploaderInput, CommunicationUncheckedCreateWithoutUploaderInput>
  }

  export type CommunicationCreateManyUploaderInputEnvelope = {
    data: CommunicationCreateManyUploaderInput | CommunicationCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type CommunicationStatusHistoryCreateWithoutUserInput = {
    id?: string
    status: string
    timestamp?: Date | string
    communication: CommunicationCreateNestedOneWithoutStatusHistoryInput
  }

  export type CommunicationStatusHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    status: string
    timestamp?: Date | string
    communicationId: string
  }

  export type CommunicationStatusHistoryCreateOrConnectWithoutUserInput = {
    where: CommunicationStatusHistoryWhereUniqueInput
    create: XOR<CommunicationStatusHistoryCreateWithoutUserInput, CommunicationStatusHistoryUncheckedCreateWithoutUserInput>
  }

  export type CommunicationStatusHistoryCreateManyUserInputEnvelope = {
    data: CommunicationStatusHistoryCreateManyUserInput | CommunicationStatusHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PhotoEntryCreateWithoutAuthorInput = {
    id?: string
    url: string
    date?: Date | string
    notes?: string | null
    controlPoint: ControlPointCreateNestedOneWithoutPhotosInput
    attachment?: AttachmentCreateNestedOneWithoutPhotoEntryInput
  }

  export type PhotoEntryUncheckedCreateWithoutAuthorInput = {
    id?: string
    url: string
    date?: Date | string
    notes?: string | null
    controlPointId: string
    attachmentId?: string | null
  }

  export type PhotoEntryCreateOrConnectWithoutAuthorInput = {
    where: PhotoEntryWhereUniqueInput
    create: XOR<PhotoEntryCreateWithoutAuthorInput, PhotoEntryUncheckedCreateWithoutAuthorInput>
  }

  export type PhotoEntryCreateManyAuthorInputEnvelope = {
    data: PhotoEntryCreateManyAuthorInput | PhotoEntryCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CommitmentCreateWithoutResponsibleInput = {
    id?: string
    description: string
    dueDate: Date | string
    status: $Enums.CommitmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    acta: ActaCreateNestedOneWithoutCommitmentsInput
  }

  export type CommitmentUncheckedCreateWithoutResponsibleInput = {
    id?: string
    description: string
    dueDate: Date | string
    status: $Enums.CommitmentStatus
    actaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommitmentCreateOrConnectWithoutResponsibleInput = {
    where: CommitmentWhereUniqueInput
    create: XOR<CommitmentCreateWithoutResponsibleInput, CommitmentUncheckedCreateWithoutResponsibleInput>
  }

  export type CommitmentCreateManyResponsibleInputEnvelope = {
    data: CommitmentCreateManyResponsibleInput | CommitmentCreateManyResponsibleInput[]
    skipDuplicates?: boolean
  }

  export type ObservationCreateWithoutAuthorInput = {
    id?: string
    text: string
    timestamp?: Date | string
    costActa: CostActaCreateNestedOneWithoutObservationsInput
  }

  export type ObservationUncheckedCreateWithoutAuthorInput = {
    id?: string
    text: string
    timestamp?: Date | string
    costActaId: string
  }

  export type ObservationCreateOrConnectWithoutAuthorInput = {
    where: ObservationWhereUniqueInput
    create: XOR<ObservationCreateWithoutAuthorInput, ObservationUncheckedCreateWithoutAuthorInput>
  }

  export type ObservationCreateManyAuthorInputEnvelope = {
    data: ObservationCreateManyAuthorInput | ObservationCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutAuthorInput = {
    id?: string
    type: string
    reportScope: $Enums.ReportScope
    number: string
    period: string
    submissionDate: Date | string
    summary: string
    status: $Enums.ReportStatus
    requiredSignatoriesJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentCreateNestedManyWithoutReportInput
    signatures?: SignatureCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutAuthorInput = {
    id?: string
    type: string
    reportScope: $Enums.ReportScope
    number: string
    period: string
    submissionDate: Date | string
    summary: string
    status: $Enums.ReportStatus
    requiredSignatoriesJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutReportInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutAuthorInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutAuthorInput, ReportUncheckedCreateWithoutAuthorInput>
  }

  export type ReportCreateManyAuthorInputEnvelope = {
    data: ReportCreateManyAuthorInput | ReportCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type DrawingVersionCreateWithoutUploaderInput = {
    id?: string
    versionNumber: number
    fileName: string
    url: string
    size: number
    uploadDate?: Date | string
    drawing: DrawingCreateNestedOneWithoutVersionsInput
  }

  export type DrawingVersionUncheckedCreateWithoutUploaderInput = {
    id?: string
    versionNumber: number
    fileName: string
    url: string
    size: number
    uploadDate?: Date | string
    drawingId: string
  }

  export type DrawingVersionCreateOrConnectWithoutUploaderInput = {
    where: DrawingVersionWhereUniqueInput
    create: XOR<DrawingVersionCreateWithoutUploaderInput, DrawingVersionUncheckedCreateWithoutUploaderInput>
  }

  export type DrawingVersionCreateManyUploaderInputEnvelope = {
    data: DrawingVersionCreateManyUploaderInput | DrawingVersionCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type LogEntryHistoryCreateWithoutUserInput = {
    id?: string
    fieldName: string
    oldValue?: string | null
    newValue?: string | null
    timestamp?: Date | string
    logEntry: LogEntryCreateNestedOneWithoutHistoryInput
  }

  export type LogEntryHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    fieldName: string
    oldValue?: string | null
    newValue?: string | null
    timestamp?: Date | string
    logEntryId: string
  }

  export type LogEntryHistoryCreateOrConnectWithoutUserInput = {
    where: LogEntryHistoryWhereUniqueInput
    create: XOR<LogEntryHistoryCreateWithoutUserInput, LogEntryHistoryUncheckedCreateWithoutUserInput>
  }

  export type LogEntryHistoryCreateManyUserInputEnvelope = {
    data: LogEntryHistoryCreateManyUserInput | LogEntryHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LogEntryUpsertWithWhereUniqueWithoutAuthorInput = {
    where: LogEntryWhereUniqueInput
    update: XOR<LogEntryUpdateWithoutAuthorInput, LogEntryUncheckedUpdateWithoutAuthorInput>
    create: XOR<LogEntryCreateWithoutAuthorInput, LogEntryUncheckedCreateWithoutAuthorInput>
  }

  export type LogEntryUpdateWithWhereUniqueWithoutAuthorInput = {
    where: LogEntryWhereUniqueInput
    data: XOR<LogEntryUpdateWithoutAuthorInput, LogEntryUncheckedUpdateWithoutAuthorInput>
  }

  export type LogEntryUpdateManyWithWhereWithoutAuthorInput = {
    where: LogEntryScalarWhereInput
    data: XOR<LogEntryUpdateManyMutationInput, LogEntryUncheckedUpdateManyWithoutAuthorInput>
  }

  export type LogEntryScalarWhereInput = {
    AND?: LogEntryScalarWhereInput | LogEntryScalarWhereInput[]
    OR?: LogEntryScalarWhereInput[]
    NOT?: LogEntryScalarWhereInput | LogEntryScalarWhereInput[]
    id?: StringFilter<"LogEntry"> | string
    folioNumber?: IntFilter<"LogEntry"> | number
    title?: StringFilter<"LogEntry"> | string
    description?: StringFilter<"LogEntry"> | string
    type?: EnumEntryTypeFilter<"LogEntry"> | $Enums.EntryType
    subject?: StringFilter<"LogEntry"> | string
    location?: StringFilter<"LogEntry"> | string
    activityStartDate?: DateTimeFilter<"LogEntry"> | Date | string
    activityEndDate?: DateTimeFilter<"LogEntry"> | Date | string
    isConfidential?: BoolFilter<"LogEntry"> | boolean
    status?: EnumEntryStatusFilter<"LogEntry"> | $Enums.EntryStatus
    authorId?: StringFilter<"LogEntry"> | string
    projectId?: StringFilter<"LogEntry"> | string
    createdAt?: DateTimeFilter<"LogEntry"> | Date | string
    updatedAt?: DateTimeFilter<"LogEntry"> | Date | string
  }

  export type LogEntryUpsertWithWhereUniqueWithoutAssigneesInput = {
    where: LogEntryWhereUniqueInput
    update: XOR<LogEntryUpdateWithoutAssigneesInput, LogEntryUncheckedUpdateWithoutAssigneesInput>
    create: XOR<LogEntryCreateWithoutAssigneesInput, LogEntryUncheckedCreateWithoutAssigneesInput>
  }

  export type LogEntryUpdateWithWhereUniqueWithoutAssigneesInput = {
    where: LogEntryWhereUniqueInput
    data: XOR<LogEntryUpdateWithoutAssigneesInput, LogEntryUncheckedUpdateWithoutAssigneesInput>
  }

  export type LogEntryUpdateManyWithWhereWithoutAssigneesInput = {
    where: LogEntryScalarWhereInput
    data: XOR<LogEntryUpdateManyMutationInput, LogEntryUncheckedUpdateManyWithoutAssigneesInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    timestamp?: DateTimeFilter<"Comment"> | Date | string
    authorId?: StringFilter<"Comment"> | string
    logEntryId?: StringNullableFilter<"Comment"> | string | null
    drawingId?: StringNullableFilter<"Comment"> | string | null
  }

  export type SignatureUpsertWithWhereUniqueWithoutSignerInput = {
    where: SignatureWhereUniqueInput
    update: XOR<SignatureUpdateWithoutSignerInput, SignatureUncheckedUpdateWithoutSignerInput>
    create: XOR<SignatureCreateWithoutSignerInput, SignatureUncheckedCreateWithoutSignerInput>
  }

  export type SignatureUpdateWithWhereUniqueWithoutSignerInput = {
    where: SignatureWhereUniqueInput
    data: XOR<SignatureUpdateWithoutSignerInput, SignatureUncheckedUpdateWithoutSignerInput>
  }

  export type SignatureUpdateManyWithWhereWithoutSignerInput = {
    where: SignatureScalarWhereInput
    data: XOR<SignatureUpdateManyMutationInput, SignatureUncheckedUpdateManyWithoutSignerInput>
  }

  export type SignatureScalarWhereInput = {
    AND?: SignatureScalarWhereInput | SignatureScalarWhereInput[]
    OR?: SignatureScalarWhereInput[]
    NOT?: SignatureScalarWhereInput | SignatureScalarWhereInput[]
    id?: StringFilter<"Signature"> | string
    signedAt?: DateTimeFilter<"Signature"> | Date | string
    signerId?: StringFilter<"Signature"> | string
    logEntryId?: StringNullableFilter<"Signature"> | string | null
    actaId?: StringNullableFilter<"Signature"> | string | null
    reportId?: StringNullableFilter<"Signature"> | string | null
  }

  export type CommunicationUpsertWithWhereUniqueWithoutUploaderInput = {
    where: CommunicationWhereUniqueInput
    update: XOR<CommunicationUpdateWithoutUploaderInput, CommunicationUncheckedUpdateWithoutUploaderInput>
    create: XOR<CommunicationCreateWithoutUploaderInput, CommunicationUncheckedCreateWithoutUploaderInput>
  }

  export type CommunicationUpdateWithWhereUniqueWithoutUploaderInput = {
    where: CommunicationWhereUniqueInput
    data: XOR<CommunicationUpdateWithoutUploaderInput, CommunicationUncheckedUpdateWithoutUploaderInput>
  }

  export type CommunicationUpdateManyWithWhereWithoutUploaderInput = {
    where: CommunicationScalarWhereInput
    data: XOR<CommunicationUpdateManyMutationInput, CommunicationUncheckedUpdateManyWithoutUploaderInput>
  }

  export type CommunicationScalarWhereInput = {
    AND?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
    OR?: CommunicationScalarWhereInput[]
    NOT?: CommunicationScalarWhereInput | CommunicationScalarWhereInput[]
    id?: StringFilter<"Communication"> | string
    radicado?: StringFilter<"Communication"> | string
    subject?: StringFilter<"Communication"> | string
    description?: StringFilter<"Communication"> | string
    senderEntity?: StringFilter<"Communication"> | string
    senderName?: StringFilter<"Communication"> | string
    senderTitle?: StringFilter<"Communication"> | string
    recipientEntity?: StringFilter<"Communication"> | string
    recipientName?: StringFilter<"Communication"> | string
    recipientTitle?: StringFilter<"Communication"> | string
    signerName?: StringFilter<"Communication"> | string
    sentDate?: DateTimeFilter<"Communication"> | Date | string
    dueDate?: DateTimeNullableFilter<"Communication"> | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFilter<"Communication"> | $Enums.DeliveryMethod
    notes?: StringNullableFilter<"Communication"> | string | null
    status?: EnumCommunicationStatusFilter<"Communication"> | $Enums.CommunicationStatus
    uploaderId?: StringFilter<"Communication"> | string
    parentId?: StringNullableFilter<"Communication"> | string | null
    createdAt?: DateTimeFilter<"Communication"> | Date | string
    updatedAt?: DateTimeFilter<"Communication"> | Date | string
  }

  export type CommunicationStatusHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunicationStatusHistoryWhereUniqueInput
    update: XOR<CommunicationStatusHistoryUpdateWithoutUserInput, CommunicationStatusHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<CommunicationStatusHistoryCreateWithoutUserInput, CommunicationStatusHistoryUncheckedCreateWithoutUserInput>
  }

  export type CommunicationStatusHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunicationStatusHistoryWhereUniqueInput
    data: XOR<CommunicationStatusHistoryUpdateWithoutUserInput, CommunicationStatusHistoryUncheckedUpdateWithoutUserInput>
  }

  export type CommunicationStatusHistoryUpdateManyWithWhereWithoutUserInput = {
    where: CommunicationStatusHistoryScalarWhereInput
    data: XOR<CommunicationStatusHistoryUpdateManyMutationInput, CommunicationStatusHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type CommunicationStatusHistoryScalarWhereInput = {
    AND?: CommunicationStatusHistoryScalarWhereInput | CommunicationStatusHistoryScalarWhereInput[]
    OR?: CommunicationStatusHistoryScalarWhereInput[]
    NOT?: CommunicationStatusHistoryScalarWhereInput | CommunicationStatusHistoryScalarWhereInput[]
    id?: StringFilter<"CommunicationStatusHistory"> | string
    status?: StringFilter<"CommunicationStatusHistory"> | string
    timestamp?: DateTimeFilter<"CommunicationStatusHistory"> | Date | string
    communicationId?: StringFilter<"CommunicationStatusHistory"> | string
    userId?: StringFilter<"CommunicationStatusHistory"> | string
  }

  export type PhotoEntryUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PhotoEntryWhereUniqueInput
    update: XOR<PhotoEntryUpdateWithoutAuthorInput, PhotoEntryUncheckedUpdateWithoutAuthorInput>
    create: XOR<PhotoEntryCreateWithoutAuthorInput, PhotoEntryUncheckedCreateWithoutAuthorInput>
  }

  export type PhotoEntryUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PhotoEntryWhereUniqueInput
    data: XOR<PhotoEntryUpdateWithoutAuthorInput, PhotoEntryUncheckedUpdateWithoutAuthorInput>
  }

  export type PhotoEntryUpdateManyWithWhereWithoutAuthorInput = {
    where: PhotoEntryScalarWhereInput
    data: XOR<PhotoEntryUpdateManyMutationInput, PhotoEntryUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PhotoEntryScalarWhereInput = {
    AND?: PhotoEntryScalarWhereInput | PhotoEntryScalarWhereInput[]
    OR?: PhotoEntryScalarWhereInput[]
    NOT?: PhotoEntryScalarWhereInput | PhotoEntryScalarWhereInput[]
    id?: StringFilter<"PhotoEntry"> | string
    url?: StringFilter<"PhotoEntry"> | string
    date?: DateTimeFilter<"PhotoEntry"> | Date | string
    notes?: StringNullableFilter<"PhotoEntry"> | string | null
    authorId?: StringFilter<"PhotoEntry"> | string
    controlPointId?: StringFilter<"PhotoEntry"> | string
    attachmentId?: StringNullableFilter<"PhotoEntry"> | string | null
  }

  export type CommitmentUpsertWithWhereUniqueWithoutResponsibleInput = {
    where: CommitmentWhereUniqueInput
    update: XOR<CommitmentUpdateWithoutResponsibleInput, CommitmentUncheckedUpdateWithoutResponsibleInput>
    create: XOR<CommitmentCreateWithoutResponsibleInput, CommitmentUncheckedCreateWithoutResponsibleInput>
  }

  export type CommitmentUpdateWithWhereUniqueWithoutResponsibleInput = {
    where: CommitmentWhereUniqueInput
    data: XOR<CommitmentUpdateWithoutResponsibleInput, CommitmentUncheckedUpdateWithoutResponsibleInput>
  }

  export type CommitmentUpdateManyWithWhereWithoutResponsibleInput = {
    where: CommitmentScalarWhereInput
    data: XOR<CommitmentUpdateManyMutationInput, CommitmentUncheckedUpdateManyWithoutResponsibleInput>
  }

  export type CommitmentScalarWhereInput = {
    AND?: CommitmentScalarWhereInput | CommitmentScalarWhereInput[]
    OR?: CommitmentScalarWhereInput[]
    NOT?: CommitmentScalarWhereInput | CommitmentScalarWhereInput[]
    id?: StringFilter<"Commitment"> | string
    description?: StringFilter<"Commitment"> | string
    dueDate?: DateTimeFilter<"Commitment"> | Date | string
    status?: EnumCommitmentStatusFilter<"Commitment"> | $Enums.CommitmentStatus
    responsibleId?: StringFilter<"Commitment"> | string
    actaId?: StringFilter<"Commitment"> | string
    createdAt?: DateTimeFilter<"Commitment"> | Date | string
    updatedAt?: DateTimeFilter<"Commitment"> | Date | string
  }

  export type ObservationUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ObservationWhereUniqueInput
    update: XOR<ObservationUpdateWithoutAuthorInput, ObservationUncheckedUpdateWithoutAuthorInput>
    create: XOR<ObservationCreateWithoutAuthorInput, ObservationUncheckedCreateWithoutAuthorInput>
  }

  export type ObservationUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ObservationWhereUniqueInput
    data: XOR<ObservationUpdateWithoutAuthorInput, ObservationUncheckedUpdateWithoutAuthorInput>
  }

  export type ObservationUpdateManyWithWhereWithoutAuthorInput = {
    where: ObservationScalarWhereInput
    data: XOR<ObservationUpdateManyMutationInput, ObservationUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ObservationScalarWhereInput = {
    AND?: ObservationScalarWhereInput | ObservationScalarWhereInput[]
    OR?: ObservationScalarWhereInput[]
    NOT?: ObservationScalarWhereInput | ObservationScalarWhereInput[]
    id?: StringFilter<"Observation"> | string
    text?: StringFilter<"Observation"> | string
    timestamp?: DateTimeFilter<"Observation"> | Date | string
    authorId?: StringFilter<"Observation"> | string
    costActaId?: StringFilter<"Observation"> | string
  }

  export type ReportUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutAuthorInput, ReportUncheckedUpdateWithoutAuthorInput>
    create: XOR<ReportCreateWithoutAuthorInput, ReportUncheckedCreateWithoutAuthorInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutAuthorInput, ReportUncheckedUpdateWithoutAuthorInput>
  }

  export type ReportUpdateManyWithWhereWithoutAuthorInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    type?: StringFilter<"Report"> | string
    reportScope?: EnumReportScopeFilter<"Report"> | $Enums.ReportScope
    number?: StringFilter<"Report"> | string
    period?: StringFilter<"Report"> | string
    submissionDate?: DateTimeFilter<"Report"> | Date | string
    summary?: StringFilter<"Report"> | string
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    authorId?: StringFilter<"Report"> | string
    requiredSignatoriesJson?: StringNullableFilter<"Report"> | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
  }

  export type DrawingVersionUpsertWithWhereUniqueWithoutUploaderInput = {
    where: DrawingVersionWhereUniqueInput
    update: XOR<DrawingVersionUpdateWithoutUploaderInput, DrawingVersionUncheckedUpdateWithoutUploaderInput>
    create: XOR<DrawingVersionCreateWithoutUploaderInput, DrawingVersionUncheckedCreateWithoutUploaderInput>
  }

  export type DrawingVersionUpdateWithWhereUniqueWithoutUploaderInput = {
    where: DrawingVersionWhereUniqueInput
    data: XOR<DrawingVersionUpdateWithoutUploaderInput, DrawingVersionUncheckedUpdateWithoutUploaderInput>
  }

  export type DrawingVersionUpdateManyWithWhereWithoutUploaderInput = {
    where: DrawingVersionScalarWhereInput
    data: XOR<DrawingVersionUpdateManyMutationInput, DrawingVersionUncheckedUpdateManyWithoutUploaderInput>
  }

  export type DrawingVersionScalarWhereInput = {
    AND?: DrawingVersionScalarWhereInput | DrawingVersionScalarWhereInput[]
    OR?: DrawingVersionScalarWhereInput[]
    NOT?: DrawingVersionScalarWhereInput | DrawingVersionScalarWhereInput[]
    id?: StringFilter<"DrawingVersion"> | string
    versionNumber?: IntFilter<"DrawingVersion"> | number
    fileName?: StringFilter<"DrawingVersion"> | string
    url?: StringFilter<"DrawingVersion"> | string
    size?: IntFilter<"DrawingVersion"> | number
    uploadDate?: DateTimeFilter<"DrawingVersion"> | Date | string
    uploaderId?: StringFilter<"DrawingVersion"> | string
    drawingId?: StringFilter<"DrawingVersion"> | string
  }

  export type LogEntryHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: LogEntryHistoryWhereUniqueInput
    update: XOR<LogEntryHistoryUpdateWithoutUserInput, LogEntryHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<LogEntryHistoryCreateWithoutUserInput, LogEntryHistoryUncheckedCreateWithoutUserInput>
  }

  export type LogEntryHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: LogEntryHistoryWhereUniqueInput
    data: XOR<LogEntryHistoryUpdateWithoutUserInput, LogEntryHistoryUncheckedUpdateWithoutUserInput>
  }

  export type LogEntryHistoryUpdateManyWithWhereWithoutUserInput = {
    where: LogEntryHistoryScalarWhereInput
    data: XOR<LogEntryHistoryUpdateManyMutationInput, LogEntryHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type LogEntryHistoryScalarWhereInput = {
    AND?: LogEntryHistoryScalarWhereInput | LogEntryHistoryScalarWhereInput[]
    OR?: LogEntryHistoryScalarWhereInput[]
    NOT?: LogEntryHistoryScalarWhereInput | LogEntryHistoryScalarWhereInput[]
    id?: StringFilter<"LogEntryHistory"> | string
    fieldName?: StringFilter<"LogEntryHistory"> | string
    oldValue?: StringNullableFilter<"LogEntryHistory"> | string | null
    newValue?: StringNullableFilter<"LogEntryHistory"> | string | null
    timestamp?: DateTimeFilter<"LogEntryHistory"> | Date | string
    logEntryId?: StringFilter<"LogEntryHistory"> | string
    userId?: StringNullableFilter<"LogEntryHistory"> | string | null
  }

  export type KeyPersonnelCreateWithoutProjectInput = {
    id?: string
    name: string
    role: string
    company: string
    email: string
    phone: string
  }

  export type KeyPersonnelUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    role: string
    company: string
    email: string
    phone: string
  }

  export type KeyPersonnelCreateOrConnectWithoutProjectInput = {
    where: KeyPersonnelWhereUniqueInput
    create: XOR<KeyPersonnelCreateWithoutProjectInput, KeyPersonnelUncheckedCreateWithoutProjectInput>
  }

  export type KeyPersonnelCreateManyProjectInputEnvelope = {
    data: KeyPersonnelCreateManyProjectInput | KeyPersonnelCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type LogEntryCreateWithoutProjectInput = {
    id?: string
    folioNumber?: number
    title: string
    description: string
    type: $Enums.EntryType
    subject: string
    location: string
    activityStartDate: Date | string
    activityEndDate: Date | string
    isConfidential?: boolean
    status: $Enums.EntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutLogEntriesInput
    assignees?: UserCreateNestedManyWithoutAssignedToInput
    comments?: CommentCreateNestedManyWithoutLogEntryInput
    attachments?: AttachmentCreateNestedManyWithoutLogEntryInput
    signatures?: SignatureCreateNestedManyWithoutLogEntryInput
    history?: LogEntryHistoryCreateNestedManyWithoutLogEntryInput
  }

  export type LogEntryUncheckedCreateWithoutProjectInput = {
    id?: string
    folioNumber?: number
    title: string
    description: string
    type: $Enums.EntryType
    subject: string
    location: string
    activityStartDate: Date | string
    activityEndDate: Date | string
    isConfidential?: boolean
    status: $Enums.EntryStatus
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignees?: UserUncheckedCreateNestedManyWithoutAssignedToInput
    comments?: CommentUncheckedCreateNestedManyWithoutLogEntryInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutLogEntryInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutLogEntryInput
    history?: LogEntryHistoryUncheckedCreateNestedManyWithoutLogEntryInput
  }

  export type LogEntryCreateOrConnectWithoutProjectInput = {
    where: LogEntryWhereUniqueInput
    create: XOR<LogEntryCreateWithoutProjectInput, LogEntryUncheckedCreateWithoutProjectInput>
  }

  export type LogEntryCreateManyProjectInputEnvelope = {
    data: LogEntryCreateManyProjectInput | LogEntryCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type KeyPersonnelUpsertWithWhereUniqueWithoutProjectInput = {
    where: KeyPersonnelWhereUniqueInput
    update: XOR<KeyPersonnelUpdateWithoutProjectInput, KeyPersonnelUncheckedUpdateWithoutProjectInput>
    create: XOR<KeyPersonnelCreateWithoutProjectInput, KeyPersonnelUncheckedCreateWithoutProjectInput>
  }

  export type KeyPersonnelUpdateWithWhereUniqueWithoutProjectInput = {
    where: KeyPersonnelWhereUniqueInput
    data: XOR<KeyPersonnelUpdateWithoutProjectInput, KeyPersonnelUncheckedUpdateWithoutProjectInput>
  }

  export type KeyPersonnelUpdateManyWithWhereWithoutProjectInput = {
    where: KeyPersonnelScalarWhereInput
    data: XOR<KeyPersonnelUpdateManyMutationInput, KeyPersonnelUncheckedUpdateManyWithoutProjectInput>
  }

  export type KeyPersonnelScalarWhereInput = {
    AND?: KeyPersonnelScalarWhereInput | KeyPersonnelScalarWhereInput[]
    OR?: KeyPersonnelScalarWhereInput[]
    NOT?: KeyPersonnelScalarWhereInput | KeyPersonnelScalarWhereInput[]
    id?: StringFilter<"KeyPersonnel"> | string
    name?: StringFilter<"KeyPersonnel"> | string
    role?: StringFilter<"KeyPersonnel"> | string
    company?: StringFilter<"KeyPersonnel"> | string
    email?: StringFilter<"KeyPersonnel"> | string
    phone?: StringFilter<"KeyPersonnel"> | string
    projectId?: StringFilter<"KeyPersonnel"> | string
  }

  export type LogEntryUpsertWithWhereUniqueWithoutProjectInput = {
    where: LogEntryWhereUniqueInput
    update: XOR<LogEntryUpdateWithoutProjectInput, LogEntryUncheckedUpdateWithoutProjectInput>
    create: XOR<LogEntryCreateWithoutProjectInput, LogEntryUncheckedCreateWithoutProjectInput>
  }

  export type LogEntryUpdateWithWhereUniqueWithoutProjectInput = {
    where: LogEntryWhereUniqueInput
    data: XOR<LogEntryUpdateWithoutProjectInput, LogEntryUncheckedUpdateWithoutProjectInput>
  }

  export type LogEntryUpdateManyWithWhereWithoutProjectInput = {
    where: LogEntryScalarWhereInput
    data: XOR<LogEntryUpdateManyMutationInput, LogEntryUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectCreateWithoutKeyPersonnelInput = {
    id?: string
    name: string
    contractId: string
    object: string
    contractorName: string
    supervisorName: string
    initialValue: number
    startDate: Date | string
    initialEndDate: Date | string
    interventoriaContractId: string
    interventoriaInitialValue: number
    technicalSupervisorName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutKeyPersonnelInput = {
    id?: string
    name: string
    contractId: string
    object: string
    contractorName: string
    supervisorName: string
    initialValue: number
    startDate: Date | string
    initialEndDate: Date | string
    interventoriaContractId: string
    interventoriaInitialValue: number
    technicalSupervisorName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutKeyPersonnelInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutKeyPersonnelInput, ProjectUncheckedCreateWithoutKeyPersonnelInput>
  }

  export type ProjectUpsertWithoutKeyPersonnelInput = {
    update: XOR<ProjectUpdateWithoutKeyPersonnelInput, ProjectUncheckedUpdateWithoutKeyPersonnelInput>
    create: XOR<ProjectCreateWithoutKeyPersonnelInput, ProjectUncheckedCreateWithoutKeyPersonnelInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutKeyPersonnelInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutKeyPersonnelInput, ProjectUncheckedUpdateWithoutKeyPersonnelInput>
  }

  export type ProjectUpdateWithoutKeyPersonnelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    object?: StringFieldUpdateOperationsInput | string
    contractorName?: StringFieldUpdateOperationsInput | string
    supervisorName?: StringFieldUpdateOperationsInput | string
    initialValue?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interventoriaContractId?: StringFieldUpdateOperationsInput | string
    interventoriaInitialValue?: FloatFieldUpdateOperationsInput | number
    technicalSupervisorName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutKeyPersonnelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    object?: StringFieldUpdateOperationsInput | string
    contractorName?: StringFieldUpdateOperationsInput | string
    supervisorName?: StringFieldUpdateOperationsInput | string
    initialValue?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interventoriaContractId?: StringFieldUpdateOperationsInput | string
    interventoriaInitialValue?: FloatFieldUpdateOperationsInput | number
    technicalSupervisorName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserCreateWithoutCommunicationsInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryCreateNestedManyWithoutAuthorInput
    assignedTo?: LogEntryCreateNestedManyWithoutAssigneesInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    signatures?: SignatureCreateNestedManyWithoutSignerInput
    statusChanges?: CommunicationStatusHistoryCreateNestedManyWithoutUserInput
    photoEntries?: PhotoEntryCreateNestedManyWithoutAuthorInput
    responsibleFor?: CommitmentCreateNestedManyWithoutResponsibleInput
    observations?: ObservationCreateNestedManyWithoutAuthorInput
    reports?: ReportCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionCreateNestedManyWithoutUploaderInput
    logEntryHistory?: LogEntryHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunicationsInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryUncheckedCreateNestedManyWithoutAuthorInput
    assignedTo?: LogEntryUncheckedCreateNestedManyWithoutAssigneesInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutSignerInput
    statusChanges?: CommunicationStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    photoEntries?: PhotoEntryUncheckedCreateNestedManyWithoutAuthorInput
    responsibleFor?: CommitmentUncheckedCreateNestedManyWithoutResponsibleInput
    observations?: ObservationUncheckedCreateNestedManyWithoutAuthorInput
    reports?: ReportUncheckedCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionUncheckedCreateNestedManyWithoutUploaderInput
    logEntryHistory?: LogEntryHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommunicationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommunicationsInput, UserUncheckedCreateWithoutCommunicationsInput>
  }

  export type CommunicationCreateWithoutRepliesInput = {
    id?: string
    radicado: string
    subject: string
    description: string
    senderEntity: string
    senderName: string
    senderTitle: string
    recipientEntity: string
    recipientName: string
    recipientTitle: string
    signerName: string
    sentDate: Date | string
    dueDate?: Date | string | null
    deliveryMethod: $Enums.DeliveryMethod
    notes?: string | null
    status: $Enums.CommunicationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    uploader: UserCreateNestedOneWithoutCommunicationsInput
    parent?: CommunicationCreateNestedOneWithoutRepliesInput
    statusHistory?: CommunicationStatusHistoryCreateNestedManyWithoutCommunicationInput
    attachments?: AttachmentCreateNestedManyWithoutCommunicationInput
  }

  export type CommunicationUncheckedCreateWithoutRepliesInput = {
    id?: string
    radicado: string
    subject: string
    description: string
    senderEntity: string
    senderName: string
    senderTitle: string
    recipientEntity: string
    recipientName: string
    recipientTitle: string
    signerName: string
    sentDate: Date | string
    dueDate?: Date | string | null
    deliveryMethod: $Enums.DeliveryMethod
    notes?: string | null
    status: $Enums.CommunicationStatus
    uploaderId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: CommunicationStatusHistoryUncheckedCreateNestedManyWithoutCommunicationInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutCommunicationInput
  }

  export type CommunicationCreateOrConnectWithoutRepliesInput = {
    where: CommunicationWhereUniqueInput
    create: XOR<CommunicationCreateWithoutRepliesInput, CommunicationUncheckedCreateWithoutRepliesInput>
  }

  export type CommunicationCreateWithoutParentInput = {
    id?: string
    radicado: string
    subject: string
    description: string
    senderEntity: string
    senderName: string
    senderTitle: string
    recipientEntity: string
    recipientName: string
    recipientTitle: string
    signerName: string
    sentDate: Date | string
    dueDate?: Date | string | null
    deliveryMethod: $Enums.DeliveryMethod
    notes?: string | null
    status: $Enums.CommunicationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    uploader: UserCreateNestedOneWithoutCommunicationsInput
    replies?: CommunicationCreateNestedManyWithoutParentInput
    statusHistory?: CommunicationStatusHistoryCreateNestedManyWithoutCommunicationInput
    attachments?: AttachmentCreateNestedManyWithoutCommunicationInput
  }

  export type CommunicationUncheckedCreateWithoutParentInput = {
    id?: string
    radicado: string
    subject: string
    description: string
    senderEntity: string
    senderName: string
    senderTitle: string
    recipientEntity: string
    recipientName: string
    recipientTitle: string
    signerName: string
    sentDate: Date | string
    dueDate?: Date | string | null
    deliveryMethod: $Enums.DeliveryMethod
    notes?: string | null
    status: $Enums.CommunicationStatus
    uploaderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommunicationUncheckedCreateNestedManyWithoutParentInput
    statusHistory?: CommunicationStatusHistoryUncheckedCreateNestedManyWithoutCommunicationInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutCommunicationInput
  }

  export type CommunicationCreateOrConnectWithoutParentInput = {
    where: CommunicationWhereUniqueInput
    create: XOR<CommunicationCreateWithoutParentInput, CommunicationUncheckedCreateWithoutParentInput>
  }

  export type CommunicationCreateManyParentInputEnvelope = {
    data: CommunicationCreateManyParentInput | CommunicationCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type CommunicationStatusHistoryCreateWithoutCommunicationInput = {
    id?: string
    status: string
    timestamp?: Date | string
    user: UserCreateNestedOneWithoutStatusChangesInput
  }

  export type CommunicationStatusHistoryUncheckedCreateWithoutCommunicationInput = {
    id?: string
    status: string
    timestamp?: Date | string
    userId: string
  }

  export type CommunicationStatusHistoryCreateOrConnectWithoutCommunicationInput = {
    where: CommunicationStatusHistoryWhereUniqueInput
    create: XOR<CommunicationStatusHistoryCreateWithoutCommunicationInput, CommunicationStatusHistoryUncheckedCreateWithoutCommunicationInput>
  }

  export type CommunicationStatusHistoryCreateManyCommunicationInputEnvelope = {
    data: CommunicationStatusHistoryCreateManyCommunicationInput | CommunicationStatusHistoryCreateManyCommunicationInput[]
    skipDuplicates?: boolean
  }

  export type AttachmentCreateWithoutCommunicationInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    createdAt?: Date | string
    logEntry?: LogEntryCreateNestedOneWithoutAttachmentsInput
    acta?: ActaCreateNestedOneWithoutAttachmentsInput
    costActa?: CostActaCreateNestedOneWithoutAttachmentsInput
    report?: ReportCreateNestedOneWithoutAttachmentsInput
    comment?: CommentCreateNestedOneWithoutAttachmentsInput
    contractMod?: ContractModificationCreateNestedOneWithoutAttachmentInput
    workActa?: WorkActaCreateNestedOneWithoutAttachmentsInput
    weeklyReport?: WeeklyReportCreateNestedOneWithoutAttachmentsInput
    photoEntry?: PhotoEntryCreateNestedOneWithoutAttachmentInput
  }

  export type AttachmentUncheckedCreateWithoutCommunicationInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    logEntryId?: string | null
    actaId?: string | null
    costActaId?: string | null
    reportId?: string | null
    commentId?: string | null
    workActaId?: string | null
    weeklyReportId?: string | null
    createdAt?: Date | string
    contractMod?: ContractModificationUncheckedCreateNestedOneWithoutAttachmentInput
    photoEntry?: PhotoEntryUncheckedCreateNestedOneWithoutAttachmentInput
  }

  export type AttachmentCreateOrConnectWithoutCommunicationInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutCommunicationInput, AttachmentUncheckedCreateWithoutCommunicationInput>
  }

  export type AttachmentCreateManyCommunicationInputEnvelope = {
    data: AttachmentCreateManyCommunicationInput | AttachmentCreateManyCommunicationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCommunicationsInput = {
    update: XOR<UserUpdateWithoutCommunicationsInput, UserUncheckedUpdateWithoutCommunicationsInput>
    create: XOR<UserCreateWithoutCommunicationsInput, UserUncheckedCreateWithoutCommunicationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommunicationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommunicationsInput, UserUncheckedUpdateWithoutCommunicationsInput>
  }

  export type UserUpdateWithoutCommunicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUpdateManyWithoutAuthorNestedInput
    assignedTo?: LogEntryUpdateManyWithoutAssigneesNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    signatures?: SignatureUpdateManyWithoutSignerNestedInput
    statusChanges?: CommunicationStatusHistoryUpdateManyWithoutUserNestedInput
    photoEntries?: PhotoEntryUpdateManyWithoutAuthorNestedInput
    responsibleFor?: CommitmentUpdateManyWithoutResponsibleNestedInput
    observations?: ObservationUpdateManyWithoutAuthorNestedInput
    reports?: ReportUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUpdateManyWithoutUploaderNestedInput
    logEntryHistory?: LogEntryHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommunicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTo?: LogEntryUncheckedUpdateManyWithoutAssigneesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutSignerNestedInput
    statusChanges?: CommunicationStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    photoEntries?: PhotoEntryUncheckedUpdateManyWithoutAuthorNestedInput
    responsibleFor?: CommitmentUncheckedUpdateManyWithoutResponsibleNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutAuthorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUncheckedUpdateManyWithoutUploaderNestedInput
    logEntryHistory?: LogEntryHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommunicationUpsertWithoutRepliesInput = {
    update: XOR<CommunicationUpdateWithoutRepliesInput, CommunicationUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommunicationCreateWithoutRepliesInput, CommunicationUncheckedCreateWithoutRepliesInput>
    where?: CommunicationWhereInput
  }

  export type CommunicationUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommunicationWhereInput
    data: XOR<CommunicationUpdateWithoutRepliesInput, CommunicationUncheckedUpdateWithoutRepliesInput>
  }

  export type CommunicationUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    radicado?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    senderEntity?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderTitle?: StringFieldUpdateOperationsInput | string
    recipientEntity?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientTitle?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommunicationStatusFieldUpdateOperationsInput | $Enums.CommunicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneRequiredWithoutCommunicationsNestedInput
    parent?: CommunicationUpdateOneWithoutRepliesNestedInput
    statusHistory?: CommunicationStatusHistoryUpdateManyWithoutCommunicationNestedInput
    attachments?: AttachmentUpdateManyWithoutCommunicationNestedInput
  }

  export type CommunicationUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    radicado?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    senderEntity?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderTitle?: StringFieldUpdateOperationsInput | string
    recipientEntity?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientTitle?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommunicationStatusFieldUpdateOperationsInput | $Enums.CommunicationStatus
    uploaderId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: CommunicationStatusHistoryUncheckedUpdateManyWithoutCommunicationNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutCommunicationNestedInput
  }

  export type CommunicationUpsertWithWhereUniqueWithoutParentInput = {
    where: CommunicationWhereUniqueInput
    update: XOR<CommunicationUpdateWithoutParentInput, CommunicationUncheckedUpdateWithoutParentInput>
    create: XOR<CommunicationCreateWithoutParentInput, CommunicationUncheckedCreateWithoutParentInput>
  }

  export type CommunicationUpdateWithWhereUniqueWithoutParentInput = {
    where: CommunicationWhereUniqueInput
    data: XOR<CommunicationUpdateWithoutParentInput, CommunicationUncheckedUpdateWithoutParentInput>
  }

  export type CommunicationUpdateManyWithWhereWithoutParentInput = {
    where: CommunicationScalarWhereInput
    data: XOR<CommunicationUpdateManyMutationInput, CommunicationUncheckedUpdateManyWithoutParentInput>
  }

  export type CommunicationStatusHistoryUpsertWithWhereUniqueWithoutCommunicationInput = {
    where: CommunicationStatusHistoryWhereUniqueInput
    update: XOR<CommunicationStatusHistoryUpdateWithoutCommunicationInput, CommunicationStatusHistoryUncheckedUpdateWithoutCommunicationInput>
    create: XOR<CommunicationStatusHistoryCreateWithoutCommunicationInput, CommunicationStatusHistoryUncheckedCreateWithoutCommunicationInput>
  }

  export type CommunicationStatusHistoryUpdateWithWhereUniqueWithoutCommunicationInput = {
    where: CommunicationStatusHistoryWhereUniqueInput
    data: XOR<CommunicationStatusHistoryUpdateWithoutCommunicationInput, CommunicationStatusHistoryUncheckedUpdateWithoutCommunicationInput>
  }

  export type CommunicationStatusHistoryUpdateManyWithWhereWithoutCommunicationInput = {
    where: CommunicationStatusHistoryScalarWhereInput
    data: XOR<CommunicationStatusHistoryUpdateManyMutationInput, CommunicationStatusHistoryUncheckedUpdateManyWithoutCommunicationInput>
  }

  export type AttachmentUpsertWithWhereUniqueWithoutCommunicationInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutCommunicationInput, AttachmentUncheckedUpdateWithoutCommunicationInput>
    create: XOR<AttachmentCreateWithoutCommunicationInput, AttachmentUncheckedCreateWithoutCommunicationInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutCommunicationInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutCommunicationInput, AttachmentUncheckedUpdateWithoutCommunicationInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutCommunicationInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutCommunicationInput>
  }

  export type AttachmentScalarWhereInput = {
    AND?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    OR?: AttachmentScalarWhereInput[]
    NOT?: AttachmentScalarWhereInput | AttachmentScalarWhereInput[]
    id?: StringFilter<"Attachment"> | string
    fileName?: StringFilter<"Attachment"> | string
    url?: StringFilter<"Attachment"> | string
    size?: IntFilter<"Attachment"> | number
    type?: StringFilter<"Attachment"> | string
    logEntryId?: StringNullableFilter<"Attachment"> | string | null
    communicationId?: StringNullableFilter<"Attachment"> | string | null
    actaId?: StringNullableFilter<"Attachment"> | string | null
    costActaId?: StringNullableFilter<"Attachment"> | string | null
    reportId?: StringNullableFilter<"Attachment"> | string | null
    commentId?: StringNullableFilter<"Attachment"> | string | null
    workActaId?: StringNullableFilter<"Attachment"> | string | null
    weeklyReportId?: StringNullableFilter<"Attachment"> | string | null
    createdAt?: DateTimeFilter<"Attachment"> | Date | string
  }

  export type CommunicationCreateWithoutStatusHistoryInput = {
    id?: string
    radicado: string
    subject: string
    description: string
    senderEntity: string
    senderName: string
    senderTitle: string
    recipientEntity: string
    recipientName: string
    recipientTitle: string
    signerName: string
    sentDate: Date | string
    dueDate?: Date | string | null
    deliveryMethod: $Enums.DeliveryMethod
    notes?: string | null
    status: $Enums.CommunicationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    uploader: UserCreateNestedOneWithoutCommunicationsInput
    parent?: CommunicationCreateNestedOneWithoutRepliesInput
    replies?: CommunicationCreateNestedManyWithoutParentInput
    attachments?: AttachmentCreateNestedManyWithoutCommunicationInput
  }

  export type CommunicationUncheckedCreateWithoutStatusHistoryInput = {
    id?: string
    radicado: string
    subject: string
    description: string
    senderEntity: string
    senderName: string
    senderTitle: string
    recipientEntity: string
    recipientName: string
    recipientTitle: string
    signerName: string
    sentDate: Date | string
    dueDate?: Date | string | null
    deliveryMethod: $Enums.DeliveryMethod
    notes?: string | null
    status: $Enums.CommunicationStatus
    uploaderId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommunicationUncheckedCreateNestedManyWithoutParentInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutCommunicationInput
  }

  export type CommunicationCreateOrConnectWithoutStatusHistoryInput = {
    where: CommunicationWhereUniqueInput
    create: XOR<CommunicationCreateWithoutStatusHistoryInput, CommunicationUncheckedCreateWithoutStatusHistoryInput>
  }

  export type UserCreateWithoutStatusChangesInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryCreateNestedManyWithoutAuthorInput
    assignedTo?: LogEntryCreateNestedManyWithoutAssigneesInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    signatures?: SignatureCreateNestedManyWithoutSignerInput
    communications?: CommunicationCreateNestedManyWithoutUploaderInput
    photoEntries?: PhotoEntryCreateNestedManyWithoutAuthorInput
    responsibleFor?: CommitmentCreateNestedManyWithoutResponsibleInput
    observations?: ObservationCreateNestedManyWithoutAuthorInput
    reports?: ReportCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionCreateNestedManyWithoutUploaderInput
    logEntryHistory?: LogEntryHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStatusChangesInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryUncheckedCreateNestedManyWithoutAuthorInput
    assignedTo?: LogEntryUncheckedCreateNestedManyWithoutAssigneesInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutSignerInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUploaderInput
    photoEntries?: PhotoEntryUncheckedCreateNestedManyWithoutAuthorInput
    responsibleFor?: CommitmentUncheckedCreateNestedManyWithoutResponsibleInput
    observations?: ObservationUncheckedCreateNestedManyWithoutAuthorInput
    reports?: ReportUncheckedCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionUncheckedCreateNestedManyWithoutUploaderInput
    logEntryHistory?: LogEntryHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStatusChangesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStatusChangesInput, UserUncheckedCreateWithoutStatusChangesInput>
  }

  export type CommunicationUpsertWithoutStatusHistoryInput = {
    update: XOR<CommunicationUpdateWithoutStatusHistoryInput, CommunicationUncheckedUpdateWithoutStatusHistoryInput>
    create: XOR<CommunicationCreateWithoutStatusHistoryInput, CommunicationUncheckedCreateWithoutStatusHistoryInput>
    where?: CommunicationWhereInput
  }

  export type CommunicationUpdateToOneWithWhereWithoutStatusHistoryInput = {
    where?: CommunicationWhereInput
    data: XOR<CommunicationUpdateWithoutStatusHistoryInput, CommunicationUncheckedUpdateWithoutStatusHistoryInput>
  }

  export type CommunicationUpdateWithoutStatusHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    radicado?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    senderEntity?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderTitle?: StringFieldUpdateOperationsInput | string
    recipientEntity?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientTitle?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommunicationStatusFieldUpdateOperationsInput | $Enums.CommunicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneRequiredWithoutCommunicationsNestedInput
    parent?: CommunicationUpdateOneWithoutRepliesNestedInput
    replies?: CommunicationUpdateManyWithoutParentNestedInput
    attachments?: AttachmentUpdateManyWithoutCommunicationNestedInput
  }

  export type CommunicationUncheckedUpdateWithoutStatusHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    radicado?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    senderEntity?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderTitle?: StringFieldUpdateOperationsInput | string
    recipientEntity?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientTitle?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommunicationStatusFieldUpdateOperationsInput | $Enums.CommunicationStatus
    uploaderId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommunicationUncheckedUpdateManyWithoutParentNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutCommunicationNestedInput
  }

  export type UserUpsertWithoutStatusChangesInput = {
    update: XOR<UserUpdateWithoutStatusChangesInput, UserUncheckedUpdateWithoutStatusChangesInput>
    create: XOR<UserCreateWithoutStatusChangesInput, UserUncheckedCreateWithoutStatusChangesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStatusChangesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStatusChangesInput, UserUncheckedUpdateWithoutStatusChangesInput>
  }

  export type UserUpdateWithoutStatusChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUpdateManyWithoutAuthorNestedInput
    assignedTo?: LogEntryUpdateManyWithoutAssigneesNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    signatures?: SignatureUpdateManyWithoutSignerNestedInput
    communications?: CommunicationUpdateManyWithoutUploaderNestedInput
    photoEntries?: PhotoEntryUpdateManyWithoutAuthorNestedInput
    responsibleFor?: CommitmentUpdateManyWithoutResponsibleNestedInput
    observations?: ObservationUpdateManyWithoutAuthorNestedInput
    reports?: ReportUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUpdateManyWithoutUploaderNestedInput
    logEntryHistory?: LogEntryHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStatusChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTo?: LogEntryUncheckedUpdateManyWithoutAssigneesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutSignerNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUploaderNestedInput
    photoEntries?: PhotoEntryUncheckedUpdateManyWithoutAuthorNestedInput
    responsibleFor?: CommitmentUncheckedUpdateManyWithoutResponsibleNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutAuthorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUncheckedUpdateManyWithoutUploaderNestedInput
    logEntryHistory?: LogEntryHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AttachmentCreateWithoutContractModInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    createdAt?: Date | string
    logEntry?: LogEntryCreateNestedOneWithoutAttachmentsInput
    communication?: CommunicationCreateNestedOneWithoutAttachmentsInput
    acta?: ActaCreateNestedOneWithoutAttachmentsInput
    costActa?: CostActaCreateNestedOneWithoutAttachmentsInput
    report?: ReportCreateNestedOneWithoutAttachmentsInput
    comment?: CommentCreateNestedOneWithoutAttachmentsInput
    workActa?: WorkActaCreateNestedOneWithoutAttachmentsInput
    weeklyReport?: WeeklyReportCreateNestedOneWithoutAttachmentsInput
    photoEntry?: PhotoEntryCreateNestedOneWithoutAttachmentInput
  }

  export type AttachmentUncheckedCreateWithoutContractModInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    logEntryId?: string | null
    communicationId?: string | null
    actaId?: string | null
    costActaId?: string | null
    reportId?: string | null
    commentId?: string | null
    workActaId?: string | null
    weeklyReportId?: string | null
    createdAt?: Date | string
    photoEntry?: PhotoEntryUncheckedCreateNestedOneWithoutAttachmentInput
  }

  export type AttachmentCreateOrConnectWithoutContractModInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutContractModInput, AttachmentUncheckedCreateWithoutContractModInput>
  }

  export type AttachmentUpsertWithoutContractModInput = {
    update: XOR<AttachmentUpdateWithoutContractModInput, AttachmentUncheckedUpdateWithoutContractModInput>
    create: XOR<AttachmentCreateWithoutContractModInput, AttachmentUncheckedCreateWithoutContractModInput>
    where?: AttachmentWhereInput
  }

  export type AttachmentUpdateToOneWithWhereWithoutContractModInput = {
    where?: AttachmentWhereInput
    data: XOR<AttachmentUpdateWithoutContractModInput, AttachmentUncheckedUpdateWithoutContractModInput>
  }

  export type AttachmentUpdateWithoutContractModInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntry?: LogEntryUpdateOneWithoutAttachmentsNestedInput
    communication?: CommunicationUpdateOneWithoutAttachmentsNestedInput
    acta?: ActaUpdateOneWithoutAttachmentsNestedInput
    costActa?: CostActaUpdateOneWithoutAttachmentsNestedInput
    report?: ReportUpdateOneWithoutAttachmentsNestedInput
    comment?: CommentUpdateOneWithoutAttachmentsNestedInput
    workActa?: WorkActaUpdateOneWithoutAttachmentsNestedInput
    weeklyReport?: WeeklyReportUpdateOneWithoutAttachmentsNestedInput
    photoEntry?: PhotoEntryUpdateOneWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutContractModInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    communicationId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    costActaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    workActaId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyReportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photoEntry?: PhotoEntryUncheckedUpdateOneWithoutAttachmentNestedInput
  }

  export type AttachmentCreateWithoutWeeklyReportInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    createdAt?: Date | string
    logEntry?: LogEntryCreateNestedOneWithoutAttachmentsInput
    communication?: CommunicationCreateNestedOneWithoutAttachmentsInput
    acta?: ActaCreateNestedOneWithoutAttachmentsInput
    costActa?: CostActaCreateNestedOneWithoutAttachmentsInput
    report?: ReportCreateNestedOneWithoutAttachmentsInput
    comment?: CommentCreateNestedOneWithoutAttachmentsInput
    contractMod?: ContractModificationCreateNestedOneWithoutAttachmentInput
    workActa?: WorkActaCreateNestedOneWithoutAttachmentsInput
    photoEntry?: PhotoEntryCreateNestedOneWithoutAttachmentInput
  }

  export type AttachmentUncheckedCreateWithoutWeeklyReportInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    logEntryId?: string | null
    communicationId?: string | null
    actaId?: string | null
    costActaId?: string | null
    reportId?: string | null
    commentId?: string | null
    workActaId?: string | null
    createdAt?: Date | string
    contractMod?: ContractModificationUncheckedCreateNestedOneWithoutAttachmentInput
    photoEntry?: PhotoEntryUncheckedCreateNestedOneWithoutAttachmentInput
  }

  export type AttachmentCreateOrConnectWithoutWeeklyReportInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutWeeklyReportInput, AttachmentUncheckedCreateWithoutWeeklyReportInput>
  }

  export type AttachmentCreateManyWeeklyReportInputEnvelope = {
    data: AttachmentCreateManyWeeklyReportInput | AttachmentCreateManyWeeklyReportInput[]
    skipDuplicates?: boolean
  }

  export type AttachmentUpsertWithWhereUniqueWithoutWeeklyReportInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutWeeklyReportInput, AttachmentUncheckedUpdateWithoutWeeklyReportInput>
    create: XOR<AttachmentCreateWithoutWeeklyReportInput, AttachmentUncheckedCreateWithoutWeeklyReportInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutWeeklyReportInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutWeeklyReportInput, AttachmentUncheckedUpdateWithoutWeeklyReportInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutWeeklyReportInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutWeeklyReportInput>
  }

  export type UserCreateWithoutLogEntriesInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: LogEntryCreateNestedManyWithoutAssigneesInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    signatures?: SignatureCreateNestedManyWithoutSignerInput
    communications?: CommunicationCreateNestedManyWithoutUploaderInput
    statusChanges?: CommunicationStatusHistoryCreateNestedManyWithoutUserInput
    photoEntries?: PhotoEntryCreateNestedManyWithoutAuthorInput
    responsibleFor?: CommitmentCreateNestedManyWithoutResponsibleInput
    observations?: ObservationCreateNestedManyWithoutAuthorInput
    reports?: ReportCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionCreateNestedManyWithoutUploaderInput
    logEntryHistory?: LogEntryHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLogEntriesInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo?: LogEntryUncheckedCreateNestedManyWithoutAssigneesInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutSignerInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUploaderInput
    statusChanges?: CommunicationStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    photoEntries?: PhotoEntryUncheckedCreateNestedManyWithoutAuthorInput
    responsibleFor?: CommitmentUncheckedCreateNestedManyWithoutResponsibleInput
    observations?: ObservationUncheckedCreateNestedManyWithoutAuthorInput
    reports?: ReportUncheckedCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionUncheckedCreateNestedManyWithoutUploaderInput
    logEntryHistory?: LogEntryHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLogEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogEntriesInput, UserUncheckedCreateWithoutLogEntriesInput>
  }

  export type ProjectCreateWithoutLogEntriesInput = {
    id?: string
    name: string
    contractId: string
    object: string
    contractorName: string
    supervisorName: string
    initialValue: number
    startDate: Date | string
    initialEndDate: Date | string
    interventoriaContractId: string
    interventoriaInitialValue: number
    technicalSupervisorName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    keyPersonnel?: KeyPersonnelCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutLogEntriesInput = {
    id?: string
    name: string
    contractId: string
    object: string
    contractorName: string
    supervisorName: string
    initialValue: number
    startDate: Date | string
    initialEndDate: Date | string
    interventoriaContractId: string
    interventoriaInitialValue: number
    technicalSupervisorName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    keyPersonnel?: KeyPersonnelUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutLogEntriesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutLogEntriesInput, ProjectUncheckedCreateWithoutLogEntriesInput>
  }

  export type UserCreateWithoutAssignedToInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    signatures?: SignatureCreateNestedManyWithoutSignerInput
    communications?: CommunicationCreateNestedManyWithoutUploaderInput
    statusChanges?: CommunicationStatusHistoryCreateNestedManyWithoutUserInput
    photoEntries?: PhotoEntryCreateNestedManyWithoutAuthorInput
    responsibleFor?: CommitmentCreateNestedManyWithoutResponsibleInput
    observations?: ObservationCreateNestedManyWithoutAuthorInput
    reports?: ReportCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionCreateNestedManyWithoutUploaderInput
    logEntryHistory?: LogEntryHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedToInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutSignerInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUploaderInput
    statusChanges?: CommunicationStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    photoEntries?: PhotoEntryUncheckedCreateNestedManyWithoutAuthorInput
    responsibleFor?: CommitmentUncheckedCreateNestedManyWithoutResponsibleInput
    observations?: ObservationUncheckedCreateNestedManyWithoutAuthorInput
    reports?: ReportUncheckedCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionUncheckedCreateNestedManyWithoutUploaderInput
    logEntryHistory?: LogEntryHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedToInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedToInput, UserUncheckedCreateWithoutAssignedToInput>
  }

  export type CommentCreateWithoutLogEntryInput = {
    id?: string
    content: string
    timestamp?: Date | string
    author: UserCreateNestedOneWithoutCommentsInput
    drawing?: DrawingCreateNestedOneWithoutCommentsInput
    attachments?: AttachmentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutLogEntryInput = {
    id?: string
    content: string
    timestamp?: Date | string
    authorId: string
    drawingId?: string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutLogEntryInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutLogEntryInput, CommentUncheckedCreateWithoutLogEntryInput>
  }

  export type CommentCreateManyLogEntryInputEnvelope = {
    data: CommentCreateManyLogEntryInput | CommentCreateManyLogEntryInput[]
    skipDuplicates?: boolean
  }

  export type AttachmentCreateWithoutLogEntryInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    createdAt?: Date | string
    communication?: CommunicationCreateNestedOneWithoutAttachmentsInput
    acta?: ActaCreateNestedOneWithoutAttachmentsInput
    costActa?: CostActaCreateNestedOneWithoutAttachmentsInput
    report?: ReportCreateNestedOneWithoutAttachmentsInput
    comment?: CommentCreateNestedOneWithoutAttachmentsInput
    contractMod?: ContractModificationCreateNestedOneWithoutAttachmentInput
    workActa?: WorkActaCreateNestedOneWithoutAttachmentsInput
    weeklyReport?: WeeklyReportCreateNestedOneWithoutAttachmentsInput
    photoEntry?: PhotoEntryCreateNestedOneWithoutAttachmentInput
  }

  export type AttachmentUncheckedCreateWithoutLogEntryInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    communicationId?: string | null
    actaId?: string | null
    costActaId?: string | null
    reportId?: string | null
    commentId?: string | null
    workActaId?: string | null
    weeklyReportId?: string | null
    createdAt?: Date | string
    contractMod?: ContractModificationUncheckedCreateNestedOneWithoutAttachmentInput
    photoEntry?: PhotoEntryUncheckedCreateNestedOneWithoutAttachmentInput
  }

  export type AttachmentCreateOrConnectWithoutLogEntryInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutLogEntryInput, AttachmentUncheckedCreateWithoutLogEntryInput>
  }

  export type AttachmentCreateManyLogEntryInputEnvelope = {
    data: AttachmentCreateManyLogEntryInput | AttachmentCreateManyLogEntryInput[]
    skipDuplicates?: boolean
  }

  export type SignatureCreateWithoutLogEntryInput = {
    id?: string
    signedAt?: Date | string
    signer: UserCreateNestedOneWithoutSignaturesInput
    acta?: ActaCreateNestedOneWithoutSignaturesInput
    report?: ReportCreateNestedOneWithoutSignaturesInput
  }

  export type SignatureUncheckedCreateWithoutLogEntryInput = {
    id?: string
    signedAt?: Date | string
    signerId: string
    actaId?: string | null
    reportId?: string | null
  }

  export type SignatureCreateOrConnectWithoutLogEntryInput = {
    where: SignatureWhereUniqueInput
    create: XOR<SignatureCreateWithoutLogEntryInput, SignatureUncheckedCreateWithoutLogEntryInput>
  }

  export type SignatureCreateManyLogEntryInputEnvelope = {
    data: SignatureCreateManyLogEntryInput | SignatureCreateManyLogEntryInput[]
    skipDuplicates?: boolean
  }

  export type LogEntryHistoryCreateWithoutLogEntryInput = {
    id?: string
    fieldName: string
    oldValue?: string | null
    newValue?: string | null
    timestamp?: Date | string
    user?: UserCreateNestedOneWithoutLogEntryHistoryInput
  }

  export type LogEntryHistoryUncheckedCreateWithoutLogEntryInput = {
    id?: string
    fieldName: string
    oldValue?: string | null
    newValue?: string | null
    timestamp?: Date | string
    userId?: string | null
  }

  export type LogEntryHistoryCreateOrConnectWithoutLogEntryInput = {
    where: LogEntryHistoryWhereUniqueInput
    create: XOR<LogEntryHistoryCreateWithoutLogEntryInput, LogEntryHistoryUncheckedCreateWithoutLogEntryInput>
  }

  export type LogEntryHistoryCreateManyLogEntryInputEnvelope = {
    data: LogEntryHistoryCreateManyLogEntryInput | LogEntryHistoryCreateManyLogEntryInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLogEntriesInput = {
    update: XOR<UserUpdateWithoutLogEntriesInput, UserUncheckedUpdateWithoutLogEntriesInput>
    create: XOR<UserCreateWithoutLogEntriesInput, UserUncheckedCreateWithoutLogEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogEntriesInput, UserUncheckedUpdateWithoutLogEntriesInput>
  }

  export type UserUpdateWithoutLogEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: LogEntryUpdateManyWithoutAssigneesNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    signatures?: SignatureUpdateManyWithoutSignerNestedInput
    communications?: CommunicationUpdateManyWithoutUploaderNestedInput
    statusChanges?: CommunicationStatusHistoryUpdateManyWithoutUserNestedInput
    photoEntries?: PhotoEntryUpdateManyWithoutAuthorNestedInput
    responsibleFor?: CommitmentUpdateManyWithoutResponsibleNestedInput
    observations?: ObservationUpdateManyWithoutAuthorNestedInput
    reports?: ReportUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUpdateManyWithoutUploaderNestedInput
    logEntryHistory?: LogEntryHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLogEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: LogEntryUncheckedUpdateManyWithoutAssigneesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutSignerNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUploaderNestedInput
    statusChanges?: CommunicationStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    photoEntries?: PhotoEntryUncheckedUpdateManyWithoutAuthorNestedInput
    responsibleFor?: CommitmentUncheckedUpdateManyWithoutResponsibleNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutAuthorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUncheckedUpdateManyWithoutUploaderNestedInput
    logEntryHistory?: LogEntryHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectUpsertWithoutLogEntriesInput = {
    update: XOR<ProjectUpdateWithoutLogEntriesInput, ProjectUncheckedUpdateWithoutLogEntriesInput>
    create: XOR<ProjectCreateWithoutLogEntriesInput, ProjectUncheckedCreateWithoutLogEntriesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutLogEntriesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutLogEntriesInput, ProjectUncheckedUpdateWithoutLogEntriesInput>
  }

  export type ProjectUpdateWithoutLogEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    object?: StringFieldUpdateOperationsInput | string
    contractorName?: StringFieldUpdateOperationsInput | string
    supervisorName?: StringFieldUpdateOperationsInput | string
    initialValue?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interventoriaContractId?: StringFieldUpdateOperationsInput | string
    interventoriaInitialValue?: FloatFieldUpdateOperationsInput | number
    technicalSupervisorName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keyPersonnel?: KeyPersonnelUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutLogEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    object?: StringFieldUpdateOperationsInput | string
    contractorName?: StringFieldUpdateOperationsInput | string
    supervisorName?: StringFieldUpdateOperationsInput | string
    initialValue?: FloatFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    initialEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interventoriaContractId?: StringFieldUpdateOperationsInput | string
    interventoriaInitialValue?: FloatFieldUpdateOperationsInput | number
    technicalSupervisorName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keyPersonnel?: KeyPersonnelUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAssignedToInput, UserUncheckedUpdateWithoutAssignedToInput>
    create: XOR<UserCreateWithoutAssignedToInput, UserUncheckedCreateWithoutAssignedToInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAssignedToInput, UserUncheckedUpdateWithoutAssignedToInput>
  }

  export type UserUpdateManyWithWhereWithoutAssignedToInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    projectRole?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    appRole?: EnumAppRoleFilter<"User"> | $Enums.AppRole
    avatarUrl?: StringNullableFilter<"User"> | string | null
    status?: StringFilter<"User"> | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    tokenVersion?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutLogEntryInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutLogEntryInput, CommentUncheckedUpdateWithoutLogEntryInput>
    create: XOR<CommentCreateWithoutLogEntryInput, CommentUncheckedCreateWithoutLogEntryInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutLogEntryInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutLogEntryInput, CommentUncheckedUpdateWithoutLogEntryInput>
  }

  export type CommentUpdateManyWithWhereWithoutLogEntryInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutLogEntryInput>
  }

  export type AttachmentUpsertWithWhereUniqueWithoutLogEntryInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutLogEntryInput, AttachmentUncheckedUpdateWithoutLogEntryInput>
    create: XOR<AttachmentCreateWithoutLogEntryInput, AttachmentUncheckedCreateWithoutLogEntryInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutLogEntryInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutLogEntryInput, AttachmentUncheckedUpdateWithoutLogEntryInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutLogEntryInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutLogEntryInput>
  }

  export type SignatureUpsertWithWhereUniqueWithoutLogEntryInput = {
    where: SignatureWhereUniqueInput
    update: XOR<SignatureUpdateWithoutLogEntryInput, SignatureUncheckedUpdateWithoutLogEntryInput>
    create: XOR<SignatureCreateWithoutLogEntryInput, SignatureUncheckedCreateWithoutLogEntryInput>
  }

  export type SignatureUpdateWithWhereUniqueWithoutLogEntryInput = {
    where: SignatureWhereUniqueInput
    data: XOR<SignatureUpdateWithoutLogEntryInput, SignatureUncheckedUpdateWithoutLogEntryInput>
  }

  export type SignatureUpdateManyWithWhereWithoutLogEntryInput = {
    where: SignatureScalarWhereInput
    data: XOR<SignatureUpdateManyMutationInput, SignatureUncheckedUpdateManyWithoutLogEntryInput>
  }

  export type LogEntryHistoryUpsertWithWhereUniqueWithoutLogEntryInput = {
    where: LogEntryHistoryWhereUniqueInput
    update: XOR<LogEntryHistoryUpdateWithoutLogEntryInput, LogEntryHistoryUncheckedUpdateWithoutLogEntryInput>
    create: XOR<LogEntryHistoryCreateWithoutLogEntryInput, LogEntryHistoryUncheckedCreateWithoutLogEntryInput>
  }

  export type LogEntryHistoryUpdateWithWhereUniqueWithoutLogEntryInput = {
    where: LogEntryHistoryWhereUniqueInput
    data: XOR<LogEntryHistoryUpdateWithoutLogEntryInput, LogEntryHistoryUncheckedUpdateWithoutLogEntryInput>
  }

  export type LogEntryHistoryUpdateManyWithWhereWithoutLogEntryInput = {
    where: LogEntryHistoryScalarWhereInput
    data: XOR<LogEntryHistoryUpdateManyMutationInput, LogEntryHistoryUncheckedUpdateManyWithoutLogEntryInput>
  }

  export type LogEntryCreateWithoutHistoryInput = {
    id?: string
    folioNumber?: number
    title: string
    description: string
    type: $Enums.EntryType
    subject: string
    location: string
    activityStartDate: Date | string
    activityEndDate: Date | string
    isConfidential?: boolean
    status: $Enums.EntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutLogEntriesInput
    project: ProjectCreateNestedOneWithoutLogEntriesInput
    assignees?: UserCreateNestedManyWithoutAssignedToInput
    comments?: CommentCreateNestedManyWithoutLogEntryInput
    attachments?: AttachmentCreateNestedManyWithoutLogEntryInput
    signatures?: SignatureCreateNestedManyWithoutLogEntryInput
  }

  export type LogEntryUncheckedCreateWithoutHistoryInput = {
    id?: string
    folioNumber?: number
    title: string
    description: string
    type: $Enums.EntryType
    subject: string
    location: string
    activityStartDate: Date | string
    activityEndDate: Date | string
    isConfidential?: boolean
    status: $Enums.EntryStatus
    authorId: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignees?: UserUncheckedCreateNestedManyWithoutAssignedToInput
    comments?: CommentUncheckedCreateNestedManyWithoutLogEntryInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutLogEntryInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutLogEntryInput
  }

  export type LogEntryCreateOrConnectWithoutHistoryInput = {
    where: LogEntryWhereUniqueInput
    create: XOR<LogEntryCreateWithoutHistoryInput, LogEntryUncheckedCreateWithoutHistoryInput>
  }

  export type UserCreateWithoutLogEntryHistoryInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryCreateNestedManyWithoutAuthorInput
    assignedTo?: LogEntryCreateNestedManyWithoutAssigneesInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    signatures?: SignatureCreateNestedManyWithoutSignerInput
    communications?: CommunicationCreateNestedManyWithoutUploaderInput
    statusChanges?: CommunicationStatusHistoryCreateNestedManyWithoutUserInput
    photoEntries?: PhotoEntryCreateNestedManyWithoutAuthorInput
    responsibleFor?: CommitmentCreateNestedManyWithoutResponsibleInput
    observations?: ObservationCreateNestedManyWithoutAuthorInput
    reports?: ReportCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionCreateNestedManyWithoutUploaderInput
  }

  export type UserUncheckedCreateWithoutLogEntryHistoryInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryUncheckedCreateNestedManyWithoutAuthorInput
    assignedTo?: LogEntryUncheckedCreateNestedManyWithoutAssigneesInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutSignerInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUploaderInput
    statusChanges?: CommunicationStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    photoEntries?: PhotoEntryUncheckedCreateNestedManyWithoutAuthorInput
    responsibleFor?: CommitmentUncheckedCreateNestedManyWithoutResponsibleInput
    observations?: ObservationUncheckedCreateNestedManyWithoutAuthorInput
    reports?: ReportUncheckedCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionUncheckedCreateNestedManyWithoutUploaderInput
  }

  export type UserCreateOrConnectWithoutLogEntryHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogEntryHistoryInput, UserUncheckedCreateWithoutLogEntryHistoryInput>
  }

  export type LogEntryUpsertWithoutHistoryInput = {
    update: XOR<LogEntryUpdateWithoutHistoryInput, LogEntryUncheckedUpdateWithoutHistoryInput>
    create: XOR<LogEntryCreateWithoutHistoryInput, LogEntryUncheckedCreateWithoutHistoryInput>
    where?: LogEntryWhereInput
  }

  export type LogEntryUpdateToOneWithWhereWithoutHistoryInput = {
    where?: LogEntryWhereInput
    data: XOR<LogEntryUpdateWithoutHistoryInput, LogEntryUncheckedUpdateWithoutHistoryInput>
  }

  export type LogEntryUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumEntryTypeFieldUpdateOperationsInput | $Enums.EntryType
    subject?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    activityEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutLogEntriesNestedInput
    project?: ProjectUpdateOneRequiredWithoutLogEntriesNestedInput
    assignees?: UserUpdateManyWithoutAssignedToNestedInput
    comments?: CommentUpdateManyWithoutLogEntryNestedInput
    attachments?: AttachmentUpdateManyWithoutLogEntryNestedInput
    signatures?: SignatureUpdateManyWithoutLogEntryNestedInput
  }

  export type LogEntryUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    folioNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumEntryTypeFieldUpdateOperationsInput | $Enums.EntryType
    subject?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    activityEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignees?: UserUncheckedUpdateManyWithoutAssignedToNestedInput
    comments?: CommentUncheckedUpdateManyWithoutLogEntryNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutLogEntryNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutLogEntryNestedInput
  }

  export type UserUpsertWithoutLogEntryHistoryInput = {
    update: XOR<UserUpdateWithoutLogEntryHistoryInput, UserUncheckedUpdateWithoutLogEntryHistoryInput>
    create: XOR<UserCreateWithoutLogEntryHistoryInput, UserUncheckedCreateWithoutLogEntryHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogEntryHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogEntryHistoryInput, UserUncheckedUpdateWithoutLogEntryHistoryInput>
  }

  export type UserUpdateWithoutLogEntryHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUpdateManyWithoutAuthorNestedInput
    assignedTo?: LogEntryUpdateManyWithoutAssigneesNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    signatures?: SignatureUpdateManyWithoutSignerNestedInput
    communications?: CommunicationUpdateManyWithoutUploaderNestedInput
    statusChanges?: CommunicationStatusHistoryUpdateManyWithoutUserNestedInput
    photoEntries?: PhotoEntryUpdateManyWithoutAuthorNestedInput
    responsibleFor?: CommitmentUpdateManyWithoutResponsibleNestedInput
    observations?: ObservationUpdateManyWithoutAuthorNestedInput
    reports?: ReportUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUpdateManyWithoutUploaderNestedInput
  }

  export type UserUncheckedUpdateWithoutLogEntryHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTo?: LogEntryUncheckedUpdateManyWithoutAssigneesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutSignerNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUploaderNestedInput
    statusChanges?: CommunicationStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    photoEntries?: PhotoEntryUncheckedUpdateManyWithoutAuthorNestedInput
    responsibleFor?: CommitmentUncheckedUpdateManyWithoutResponsibleNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutAuthorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUncheckedUpdateManyWithoutUploaderNestedInput
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryCreateNestedManyWithoutAuthorInput
    assignedTo?: LogEntryCreateNestedManyWithoutAssigneesInput
    signatures?: SignatureCreateNestedManyWithoutSignerInput
    communications?: CommunicationCreateNestedManyWithoutUploaderInput
    statusChanges?: CommunicationStatusHistoryCreateNestedManyWithoutUserInput
    photoEntries?: PhotoEntryCreateNestedManyWithoutAuthorInput
    responsibleFor?: CommitmentCreateNestedManyWithoutResponsibleInput
    observations?: ObservationCreateNestedManyWithoutAuthorInput
    reports?: ReportCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionCreateNestedManyWithoutUploaderInput
    logEntryHistory?: LogEntryHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryUncheckedCreateNestedManyWithoutAuthorInput
    assignedTo?: LogEntryUncheckedCreateNestedManyWithoutAssigneesInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutSignerInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUploaderInput
    statusChanges?: CommunicationStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    photoEntries?: PhotoEntryUncheckedCreateNestedManyWithoutAuthorInput
    responsibleFor?: CommitmentUncheckedCreateNestedManyWithoutResponsibleInput
    observations?: ObservationUncheckedCreateNestedManyWithoutAuthorInput
    reports?: ReportUncheckedCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionUncheckedCreateNestedManyWithoutUploaderInput
    logEntryHistory?: LogEntryHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type LogEntryCreateWithoutCommentsInput = {
    id?: string
    folioNumber?: number
    title: string
    description: string
    type: $Enums.EntryType
    subject: string
    location: string
    activityStartDate: Date | string
    activityEndDate: Date | string
    isConfidential?: boolean
    status: $Enums.EntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutLogEntriesInput
    project: ProjectCreateNestedOneWithoutLogEntriesInput
    assignees?: UserCreateNestedManyWithoutAssignedToInput
    attachments?: AttachmentCreateNestedManyWithoutLogEntryInput
    signatures?: SignatureCreateNestedManyWithoutLogEntryInput
    history?: LogEntryHistoryCreateNestedManyWithoutLogEntryInput
  }

  export type LogEntryUncheckedCreateWithoutCommentsInput = {
    id?: string
    folioNumber?: number
    title: string
    description: string
    type: $Enums.EntryType
    subject: string
    location: string
    activityStartDate: Date | string
    activityEndDate: Date | string
    isConfidential?: boolean
    status: $Enums.EntryStatus
    authorId: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignees?: UserUncheckedCreateNestedManyWithoutAssignedToInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutLogEntryInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutLogEntryInput
    history?: LogEntryHistoryUncheckedCreateNestedManyWithoutLogEntryInput
  }

  export type LogEntryCreateOrConnectWithoutCommentsInput = {
    where: LogEntryWhereUniqueInput
    create: XOR<LogEntryCreateWithoutCommentsInput, LogEntryUncheckedCreateWithoutCommentsInput>
  }

  export type DrawingCreateWithoutCommentsInput = {
    id?: string
    code: string
    title: string
    discipline: $Enums.DrawingDiscipline
    status: $Enums.DrawingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: DrawingVersionCreateNestedManyWithoutDrawingInput
  }

  export type DrawingUncheckedCreateWithoutCommentsInput = {
    id?: string
    code: string
    title: string
    discipline: $Enums.DrawingDiscipline
    status: $Enums.DrawingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: DrawingVersionUncheckedCreateNestedManyWithoutDrawingInput
  }

  export type DrawingCreateOrConnectWithoutCommentsInput = {
    where: DrawingWhereUniqueInput
    create: XOR<DrawingCreateWithoutCommentsInput, DrawingUncheckedCreateWithoutCommentsInput>
  }

  export type AttachmentCreateWithoutCommentInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    createdAt?: Date | string
    logEntry?: LogEntryCreateNestedOneWithoutAttachmentsInput
    communication?: CommunicationCreateNestedOneWithoutAttachmentsInput
    acta?: ActaCreateNestedOneWithoutAttachmentsInput
    costActa?: CostActaCreateNestedOneWithoutAttachmentsInput
    report?: ReportCreateNestedOneWithoutAttachmentsInput
    contractMod?: ContractModificationCreateNestedOneWithoutAttachmentInput
    workActa?: WorkActaCreateNestedOneWithoutAttachmentsInput
    weeklyReport?: WeeklyReportCreateNestedOneWithoutAttachmentsInput
    photoEntry?: PhotoEntryCreateNestedOneWithoutAttachmentInput
  }

  export type AttachmentUncheckedCreateWithoutCommentInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    logEntryId?: string | null
    communicationId?: string | null
    actaId?: string | null
    costActaId?: string | null
    reportId?: string | null
    workActaId?: string | null
    weeklyReportId?: string | null
    createdAt?: Date | string
    contractMod?: ContractModificationUncheckedCreateNestedOneWithoutAttachmentInput
    photoEntry?: PhotoEntryUncheckedCreateNestedOneWithoutAttachmentInput
  }

  export type AttachmentCreateOrConnectWithoutCommentInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutCommentInput, AttachmentUncheckedCreateWithoutCommentInput>
  }

  export type AttachmentCreateManyCommentInputEnvelope = {
    data: AttachmentCreateManyCommentInput | AttachmentCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUpdateManyWithoutAuthorNestedInput
    assignedTo?: LogEntryUpdateManyWithoutAssigneesNestedInput
    signatures?: SignatureUpdateManyWithoutSignerNestedInput
    communications?: CommunicationUpdateManyWithoutUploaderNestedInput
    statusChanges?: CommunicationStatusHistoryUpdateManyWithoutUserNestedInput
    photoEntries?: PhotoEntryUpdateManyWithoutAuthorNestedInput
    responsibleFor?: CommitmentUpdateManyWithoutResponsibleNestedInput
    observations?: ObservationUpdateManyWithoutAuthorNestedInput
    reports?: ReportUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUpdateManyWithoutUploaderNestedInput
    logEntryHistory?: LogEntryHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTo?: LogEntryUncheckedUpdateManyWithoutAssigneesNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutSignerNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUploaderNestedInput
    statusChanges?: CommunicationStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    photoEntries?: PhotoEntryUncheckedUpdateManyWithoutAuthorNestedInput
    responsibleFor?: CommitmentUncheckedUpdateManyWithoutResponsibleNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutAuthorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUncheckedUpdateManyWithoutUploaderNestedInput
    logEntryHistory?: LogEntryHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LogEntryUpsertWithoutCommentsInput = {
    update: XOR<LogEntryUpdateWithoutCommentsInput, LogEntryUncheckedUpdateWithoutCommentsInput>
    create: XOR<LogEntryCreateWithoutCommentsInput, LogEntryUncheckedCreateWithoutCommentsInput>
    where?: LogEntryWhereInput
  }

  export type LogEntryUpdateToOneWithWhereWithoutCommentsInput = {
    where?: LogEntryWhereInput
    data: XOR<LogEntryUpdateWithoutCommentsInput, LogEntryUncheckedUpdateWithoutCommentsInput>
  }

  export type LogEntryUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumEntryTypeFieldUpdateOperationsInput | $Enums.EntryType
    subject?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    activityEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutLogEntriesNestedInput
    project?: ProjectUpdateOneRequiredWithoutLogEntriesNestedInput
    assignees?: UserUpdateManyWithoutAssignedToNestedInput
    attachments?: AttachmentUpdateManyWithoutLogEntryNestedInput
    signatures?: SignatureUpdateManyWithoutLogEntryNestedInput
    history?: LogEntryHistoryUpdateManyWithoutLogEntryNestedInput
  }

  export type LogEntryUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    folioNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumEntryTypeFieldUpdateOperationsInput | $Enums.EntryType
    subject?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    activityEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignees?: UserUncheckedUpdateManyWithoutAssignedToNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutLogEntryNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutLogEntryNestedInput
    history?: LogEntryHistoryUncheckedUpdateManyWithoutLogEntryNestedInput
  }

  export type DrawingUpsertWithoutCommentsInput = {
    update: XOR<DrawingUpdateWithoutCommentsInput, DrawingUncheckedUpdateWithoutCommentsInput>
    create: XOR<DrawingCreateWithoutCommentsInput, DrawingUncheckedCreateWithoutCommentsInput>
    where?: DrawingWhereInput
  }

  export type DrawingUpdateToOneWithWhereWithoutCommentsInput = {
    where?: DrawingWhereInput
    data: XOR<DrawingUpdateWithoutCommentsInput, DrawingUncheckedUpdateWithoutCommentsInput>
  }

  export type DrawingUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    discipline?: EnumDrawingDisciplineFieldUpdateOperationsInput | $Enums.DrawingDiscipline
    status?: EnumDrawingStatusFieldUpdateOperationsInput | $Enums.DrawingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: DrawingVersionUpdateManyWithoutDrawingNestedInput
  }

  export type DrawingUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    discipline?: EnumDrawingDisciplineFieldUpdateOperationsInput | $Enums.DrawingDiscipline
    status?: EnumDrawingStatusFieldUpdateOperationsInput | $Enums.DrawingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: DrawingVersionUncheckedUpdateManyWithoutDrawingNestedInput
  }

  export type AttachmentUpsertWithWhereUniqueWithoutCommentInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutCommentInput, AttachmentUncheckedUpdateWithoutCommentInput>
    create: XOR<AttachmentCreateWithoutCommentInput, AttachmentUncheckedCreateWithoutCommentInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutCommentInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutCommentInput, AttachmentUncheckedUpdateWithoutCommentInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutCommentInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutCommentInput>
  }

  export type UserCreateWithoutSignaturesInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryCreateNestedManyWithoutAuthorInput
    assignedTo?: LogEntryCreateNestedManyWithoutAssigneesInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    communications?: CommunicationCreateNestedManyWithoutUploaderInput
    statusChanges?: CommunicationStatusHistoryCreateNestedManyWithoutUserInput
    photoEntries?: PhotoEntryCreateNestedManyWithoutAuthorInput
    responsibleFor?: CommitmentCreateNestedManyWithoutResponsibleInput
    observations?: ObservationCreateNestedManyWithoutAuthorInput
    reports?: ReportCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionCreateNestedManyWithoutUploaderInput
    logEntryHistory?: LogEntryHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSignaturesInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryUncheckedCreateNestedManyWithoutAuthorInput
    assignedTo?: LogEntryUncheckedCreateNestedManyWithoutAssigneesInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUploaderInput
    statusChanges?: CommunicationStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    photoEntries?: PhotoEntryUncheckedCreateNestedManyWithoutAuthorInput
    responsibleFor?: CommitmentUncheckedCreateNestedManyWithoutResponsibleInput
    observations?: ObservationUncheckedCreateNestedManyWithoutAuthorInput
    reports?: ReportUncheckedCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionUncheckedCreateNestedManyWithoutUploaderInput
    logEntryHistory?: LogEntryHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSignaturesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSignaturesInput, UserUncheckedCreateWithoutSignaturesInput>
  }

  export type LogEntryCreateWithoutSignaturesInput = {
    id?: string
    folioNumber?: number
    title: string
    description: string
    type: $Enums.EntryType
    subject: string
    location: string
    activityStartDate: Date | string
    activityEndDate: Date | string
    isConfidential?: boolean
    status: $Enums.EntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutLogEntriesInput
    project: ProjectCreateNestedOneWithoutLogEntriesInput
    assignees?: UserCreateNestedManyWithoutAssignedToInput
    comments?: CommentCreateNestedManyWithoutLogEntryInput
    attachments?: AttachmentCreateNestedManyWithoutLogEntryInput
    history?: LogEntryHistoryCreateNestedManyWithoutLogEntryInput
  }

  export type LogEntryUncheckedCreateWithoutSignaturesInput = {
    id?: string
    folioNumber?: number
    title: string
    description: string
    type: $Enums.EntryType
    subject: string
    location: string
    activityStartDate: Date | string
    activityEndDate: Date | string
    isConfidential?: boolean
    status: $Enums.EntryStatus
    authorId: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignees?: UserUncheckedCreateNestedManyWithoutAssignedToInput
    comments?: CommentUncheckedCreateNestedManyWithoutLogEntryInput
    attachments?: AttachmentUncheckedCreateNestedManyWithoutLogEntryInput
    history?: LogEntryHistoryUncheckedCreateNestedManyWithoutLogEntryInput
  }

  export type LogEntryCreateOrConnectWithoutSignaturesInput = {
    where: LogEntryWhereUniqueInput
    create: XOR<LogEntryCreateWithoutSignaturesInput, LogEntryUncheckedCreateWithoutSignaturesInput>
  }

  export type ActaCreateWithoutSignaturesInput = {
    id?: string
    number: string
    title: string
    date: Date | string
    area: $Enums.ActaArea
    status: $Enums.ActaStatus
    summary: string
    requiredSignatoriesJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentCreateNestedManyWithoutActaInput
    commitments?: CommitmentCreateNestedManyWithoutActaInput
  }

  export type ActaUncheckedCreateWithoutSignaturesInput = {
    id?: string
    number: string
    title: string
    date: Date | string
    area: $Enums.ActaArea
    status: $Enums.ActaStatus
    summary: string
    requiredSignatoriesJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutActaInput
    commitments?: CommitmentUncheckedCreateNestedManyWithoutActaInput
  }

  export type ActaCreateOrConnectWithoutSignaturesInput = {
    where: ActaWhereUniqueInput
    create: XOR<ActaCreateWithoutSignaturesInput, ActaUncheckedCreateWithoutSignaturesInput>
  }

  export type ReportCreateWithoutSignaturesInput = {
    id?: string
    type: string
    reportScope: $Enums.ReportScope
    number: string
    period: string
    submissionDate: Date | string
    summary: string
    status: $Enums.ReportStatus
    requiredSignatoriesJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutReportsInput
    attachments?: AttachmentCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutSignaturesInput = {
    id?: string
    type: string
    reportScope: $Enums.ReportScope
    number: string
    period: string
    submissionDate: Date | string
    summary: string
    status: $Enums.ReportStatus
    authorId: string
    requiredSignatoriesJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutSignaturesInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutSignaturesInput, ReportUncheckedCreateWithoutSignaturesInput>
  }

  export type UserUpsertWithoutSignaturesInput = {
    update: XOR<UserUpdateWithoutSignaturesInput, UserUncheckedUpdateWithoutSignaturesInput>
    create: XOR<UserCreateWithoutSignaturesInput, UserUncheckedCreateWithoutSignaturesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSignaturesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSignaturesInput, UserUncheckedUpdateWithoutSignaturesInput>
  }

  export type UserUpdateWithoutSignaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUpdateManyWithoutAuthorNestedInput
    assignedTo?: LogEntryUpdateManyWithoutAssigneesNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    communications?: CommunicationUpdateManyWithoutUploaderNestedInput
    statusChanges?: CommunicationStatusHistoryUpdateManyWithoutUserNestedInput
    photoEntries?: PhotoEntryUpdateManyWithoutAuthorNestedInput
    responsibleFor?: CommitmentUpdateManyWithoutResponsibleNestedInput
    observations?: ObservationUpdateManyWithoutAuthorNestedInput
    reports?: ReportUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUpdateManyWithoutUploaderNestedInput
    logEntryHistory?: LogEntryHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSignaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTo?: LogEntryUncheckedUpdateManyWithoutAssigneesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUploaderNestedInput
    statusChanges?: CommunicationStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    photoEntries?: PhotoEntryUncheckedUpdateManyWithoutAuthorNestedInput
    responsibleFor?: CommitmentUncheckedUpdateManyWithoutResponsibleNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutAuthorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUncheckedUpdateManyWithoutUploaderNestedInput
    logEntryHistory?: LogEntryHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LogEntryUpsertWithoutSignaturesInput = {
    update: XOR<LogEntryUpdateWithoutSignaturesInput, LogEntryUncheckedUpdateWithoutSignaturesInput>
    create: XOR<LogEntryCreateWithoutSignaturesInput, LogEntryUncheckedCreateWithoutSignaturesInput>
    where?: LogEntryWhereInput
  }

  export type LogEntryUpdateToOneWithWhereWithoutSignaturesInput = {
    where?: LogEntryWhereInput
    data: XOR<LogEntryUpdateWithoutSignaturesInput, LogEntryUncheckedUpdateWithoutSignaturesInput>
  }

  export type LogEntryUpdateWithoutSignaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumEntryTypeFieldUpdateOperationsInput | $Enums.EntryType
    subject?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    activityEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutLogEntriesNestedInput
    project?: ProjectUpdateOneRequiredWithoutLogEntriesNestedInput
    assignees?: UserUpdateManyWithoutAssignedToNestedInput
    comments?: CommentUpdateManyWithoutLogEntryNestedInput
    attachments?: AttachmentUpdateManyWithoutLogEntryNestedInput
    history?: LogEntryHistoryUpdateManyWithoutLogEntryNestedInput
  }

  export type LogEntryUncheckedUpdateWithoutSignaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    folioNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumEntryTypeFieldUpdateOperationsInput | $Enums.EntryType
    subject?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    activityEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignees?: UserUncheckedUpdateManyWithoutAssignedToNestedInput
    comments?: CommentUncheckedUpdateManyWithoutLogEntryNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutLogEntryNestedInput
    history?: LogEntryHistoryUncheckedUpdateManyWithoutLogEntryNestedInput
  }

  export type ActaUpsertWithoutSignaturesInput = {
    update: XOR<ActaUpdateWithoutSignaturesInput, ActaUncheckedUpdateWithoutSignaturesInput>
    create: XOR<ActaCreateWithoutSignaturesInput, ActaUncheckedCreateWithoutSignaturesInput>
    where?: ActaWhereInput
  }

  export type ActaUpdateToOneWithWhereWithoutSignaturesInput = {
    where?: ActaWhereInput
    data: XOR<ActaUpdateWithoutSignaturesInput, ActaUncheckedUpdateWithoutSignaturesInput>
  }

  export type ActaUpdateWithoutSignaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: EnumActaAreaFieldUpdateOperationsInput | $Enums.ActaArea
    status?: EnumActaStatusFieldUpdateOperationsInput | $Enums.ActaStatus
    summary?: StringFieldUpdateOperationsInput | string
    requiredSignatoriesJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUpdateManyWithoutActaNestedInput
    commitments?: CommitmentUpdateManyWithoutActaNestedInput
  }

  export type ActaUncheckedUpdateWithoutSignaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: EnumActaAreaFieldUpdateOperationsInput | $Enums.ActaArea
    status?: EnumActaStatusFieldUpdateOperationsInput | $Enums.ActaStatus
    summary?: StringFieldUpdateOperationsInput | string
    requiredSignatoriesJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutActaNestedInput
    commitments?: CommitmentUncheckedUpdateManyWithoutActaNestedInput
  }

  export type ReportUpsertWithoutSignaturesInput = {
    update: XOR<ReportUpdateWithoutSignaturesInput, ReportUncheckedUpdateWithoutSignaturesInput>
    create: XOR<ReportCreateWithoutSignaturesInput, ReportUncheckedCreateWithoutSignaturesInput>
    where?: ReportWhereInput
  }

  export type ReportUpdateToOneWithWhereWithoutSignaturesInput = {
    where?: ReportWhereInput
    data: XOR<ReportUpdateWithoutSignaturesInput, ReportUncheckedUpdateWithoutSignaturesInput>
  }

  export type ReportUpdateWithoutSignaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reportScope?: EnumReportScopeFieldUpdateOperationsInput | $Enums.ReportScope
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    requiredSignatoriesJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutReportsNestedInput
    attachments?: AttachmentUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutSignaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reportScope?: EnumReportScopeFieldUpdateOperationsInput | $Enums.ReportScope
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    authorId?: StringFieldUpdateOperationsInput | string
    requiredSignatoriesJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutReportNestedInput
  }

  export type LogEntryCreateWithoutAttachmentsInput = {
    id?: string
    folioNumber?: number
    title: string
    description: string
    type: $Enums.EntryType
    subject: string
    location: string
    activityStartDate: Date | string
    activityEndDate: Date | string
    isConfidential?: boolean
    status: $Enums.EntryStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutLogEntriesInput
    project: ProjectCreateNestedOneWithoutLogEntriesInput
    assignees?: UserCreateNestedManyWithoutAssignedToInput
    comments?: CommentCreateNestedManyWithoutLogEntryInput
    signatures?: SignatureCreateNestedManyWithoutLogEntryInput
    history?: LogEntryHistoryCreateNestedManyWithoutLogEntryInput
  }

  export type LogEntryUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    folioNumber?: number
    title: string
    description: string
    type: $Enums.EntryType
    subject: string
    location: string
    activityStartDate: Date | string
    activityEndDate: Date | string
    isConfidential?: boolean
    status: $Enums.EntryStatus
    authorId: string
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignees?: UserUncheckedCreateNestedManyWithoutAssignedToInput
    comments?: CommentUncheckedCreateNestedManyWithoutLogEntryInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutLogEntryInput
    history?: LogEntryHistoryUncheckedCreateNestedManyWithoutLogEntryInput
  }

  export type LogEntryCreateOrConnectWithoutAttachmentsInput = {
    where: LogEntryWhereUniqueInput
    create: XOR<LogEntryCreateWithoutAttachmentsInput, LogEntryUncheckedCreateWithoutAttachmentsInput>
  }

  export type CommunicationCreateWithoutAttachmentsInput = {
    id?: string
    radicado: string
    subject: string
    description: string
    senderEntity: string
    senderName: string
    senderTitle: string
    recipientEntity: string
    recipientName: string
    recipientTitle: string
    signerName: string
    sentDate: Date | string
    dueDate?: Date | string | null
    deliveryMethod: $Enums.DeliveryMethod
    notes?: string | null
    status: $Enums.CommunicationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    uploader: UserCreateNestedOneWithoutCommunicationsInput
    parent?: CommunicationCreateNestedOneWithoutRepliesInput
    replies?: CommunicationCreateNestedManyWithoutParentInput
    statusHistory?: CommunicationStatusHistoryCreateNestedManyWithoutCommunicationInput
  }

  export type CommunicationUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    radicado: string
    subject: string
    description: string
    senderEntity: string
    senderName: string
    senderTitle: string
    recipientEntity: string
    recipientName: string
    recipientTitle: string
    signerName: string
    sentDate: Date | string
    dueDate?: Date | string | null
    deliveryMethod: $Enums.DeliveryMethod
    notes?: string | null
    status: $Enums.CommunicationStatus
    uploaderId: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommunicationUncheckedCreateNestedManyWithoutParentInput
    statusHistory?: CommunicationStatusHistoryUncheckedCreateNestedManyWithoutCommunicationInput
  }

  export type CommunicationCreateOrConnectWithoutAttachmentsInput = {
    where: CommunicationWhereUniqueInput
    create: XOR<CommunicationCreateWithoutAttachmentsInput, CommunicationUncheckedCreateWithoutAttachmentsInput>
  }

  export type ActaCreateWithoutAttachmentsInput = {
    id?: string
    number: string
    title: string
    date: Date | string
    area: $Enums.ActaArea
    status: $Enums.ActaStatus
    summary: string
    requiredSignatoriesJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    signatures?: SignatureCreateNestedManyWithoutActaInput
    commitments?: CommitmentCreateNestedManyWithoutActaInput
  }

  export type ActaUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    number: string
    title: string
    date: Date | string
    area: $Enums.ActaArea
    status: $Enums.ActaStatus
    summary: string
    requiredSignatoriesJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    signatures?: SignatureUncheckedCreateNestedManyWithoutActaInput
    commitments?: CommitmentUncheckedCreateNestedManyWithoutActaInput
  }

  export type ActaCreateOrConnectWithoutAttachmentsInput = {
    where: ActaWhereUniqueInput
    create: XOR<ActaCreateWithoutAttachmentsInput, ActaUncheckedCreateWithoutAttachmentsInput>
  }

  export type CostActaCreateWithoutAttachmentsInput = {
    id?: string
    number: string
    period: string
    submissionDate: Date | string
    approvalDate?: Date | string | null
    paymentDueDate?: Date | string | null
    billedAmount: number
    totalContractValue: number
    status: $Enums.CostActaStatus
    relatedProgress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    observations?: ObservationCreateNestedManyWithoutCostActaInput
  }

  export type CostActaUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    number: string
    period: string
    submissionDate: Date | string
    approvalDate?: Date | string | null
    paymentDueDate?: Date | string | null
    billedAmount: number
    totalContractValue: number
    status: $Enums.CostActaStatus
    relatedProgress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    observations?: ObservationUncheckedCreateNestedManyWithoutCostActaInput
  }

  export type CostActaCreateOrConnectWithoutAttachmentsInput = {
    where: CostActaWhereUniqueInput
    create: XOR<CostActaCreateWithoutAttachmentsInput, CostActaUncheckedCreateWithoutAttachmentsInput>
  }

  export type ReportCreateWithoutAttachmentsInput = {
    id?: string
    type: string
    reportScope: $Enums.ReportScope
    number: string
    period: string
    submissionDate: Date | string
    summary: string
    status: $Enums.ReportStatus
    requiredSignatoriesJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutReportsInput
    signatures?: SignatureCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    type: string
    reportScope: $Enums.ReportScope
    number: string
    period: string
    submissionDate: Date | string
    summary: string
    status: $Enums.ReportStatus
    authorId: string
    requiredSignatoriesJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    signatures?: SignatureUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutAttachmentsInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutAttachmentsInput, ReportUncheckedCreateWithoutAttachmentsInput>
  }

  export type CommentCreateWithoutAttachmentsInput = {
    id?: string
    content: string
    timestamp?: Date | string
    author: UserCreateNestedOneWithoutCommentsInput
    logEntry?: LogEntryCreateNestedOneWithoutCommentsInput
    drawing?: DrawingCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    content: string
    timestamp?: Date | string
    authorId: string
    logEntryId?: string | null
    drawingId?: string | null
  }

  export type CommentCreateOrConnectWithoutAttachmentsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAttachmentsInput, CommentUncheckedCreateWithoutAttachmentsInput>
  }

  export type ContractModificationCreateWithoutAttachmentInput = {
    id?: string
    number: string
    type: $Enums.ModificationType
    date: Date | string
    value?: number | null
    days?: number | null
    justification: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractModificationUncheckedCreateWithoutAttachmentInput = {
    id?: string
    number: string
    type: $Enums.ModificationType
    date: Date | string
    value?: number | null
    days?: number | null
    justification: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractModificationCreateOrConnectWithoutAttachmentInput = {
    where: ContractModificationWhereUniqueInput
    create: XOR<ContractModificationCreateWithoutAttachmentInput, ContractModificationUncheckedCreateWithoutAttachmentInput>
  }

  export type WorkActaCreateWithoutAttachmentsInput = {
    id?: string
    number: string
    period: string
    date: Date | string
    status: $Enums.WorkActaStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: WorkActaItemCreateNestedManyWithoutWorkActaInput
  }

  export type WorkActaUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    number: string
    period: string
    date: Date | string
    status: $Enums.WorkActaStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: WorkActaItemUncheckedCreateNestedManyWithoutWorkActaInput
  }

  export type WorkActaCreateOrConnectWithoutAttachmentsInput = {
    where: WorkActaWhereUniqueInput
    create: XOR<WorkActaCreateWithoutAttachmentsInput, WorkActaUncheckedCreateWithoutAttachmentsInput>
  }

  export type WeeklyReportCreateWithoutAttachmentsInput = {
    id?: string
    number: string
    startDate: Date | string
    endDate: Date | string
    summary: string
    progressSummary?: string | null
    nextWeekPlan?: string | null
    issues?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeeklyReportUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    number: string
    startDate: Date | string
    endDate: Date | string
    summary: string
    progressSummary?: string | null
    nextWeekPlan?: string | null
    issues?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WeeklyReportCreateOrConnectWithoutAttachmentsInput = {
    where: WeeklyReportWhereUniqueInput
    create: XOR<WeeklyReportCreateWithoutAttachmentsInput, WeeklyReportUncheckedCreateWithoutAttachmentsInput>
  }

  export type PhotoEntryCreateWithoutAttachmentInput = {
    id?: string
    url: string
    date?: Date | string
    notes?: string | null
    author: UserCreateNestedOneWithoutPhotoEntriesInput
    controlPoint: ControlPointCreateNestedOneWithoutPhotosInput
  }

  export type PhotoEntryUncheckedCreateWithoutAttachmentInput = {
    id?: string
    url: string
    date?: Date | string
    notes?: string | null
    authorId: string
    controlPointId: string
  }

  export type PhotoEntryCreateOrConnectWithoutAttachmentInput = {
    where: PhotoEntryWhereUniqueInput
    create: XOR<PhotoEntryCreateWithoutAttachmentInput, PhotoEntryUncheckedCreateWithoutAttachmentInput>
  }

  export type LogEntryUpsertWithoutAttachmentsInput = {
    update: XOR<LogEntryUpdateWithoutAttachmentsInput, LogEntryUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<LogEntryCreateWithoutAttachmentsInput, LogEntryUncheckedCreateWithoutAttachmentsInput>
    where?: LogEntryWhereInput
  }

  export type LogEntryUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: LogEntryWhereInput
    data: XOR<LogEntryUpdateWithoutAttachmentsInput, LogEntryUncheckedUpdateWithoutAttachmentsInput>
  }

  export type LogEntryUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumEntryTypeFieldUpdateOperationsInput | $Enums.EntryType
    subject?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    activityEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutLogEntriesNestedInput
    project?: ProjectUpdateOneRequiredWithoutLogEntriesNestedInput
    assignees?: UserUpdateManyWithoutAssignedToNestedInput
    comments?: CommentUpdateManyWithoutLogEntryNestedInput
    signatures?: SignatureUpdateManyWithoutLogEntryNestedInput
    history?: LogEntryHistoryUpdateManyWithoutLogEntryNestedInput
  }

  export type LogEntryUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    folioNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumEntryTypeFieldUpdateOperationsInput | $Enums.EntryType
    subject?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    activityEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignees?: UserUncheckedUpdateManyWithoutAssignedToNestedInput
    comments?: CommentUncheckedUpdateManyWithoutLogEntryNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutLogEntryNestedInput
    history?: LogEntryHistoryUncheckedUpdateManyWithoutLogEntryNestedInput
  }

  export type CommunicationUpsertWithoutAttachmentsInput = {
    update: XOR<CommunicationUpdateWithoutAttachmentsInput, CommunicationUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<CommunicationCreateWithoutAttachmentsInput, CommunicationUncheckedCreateWithoutAttachmentsInput>
    where?: CommunicationWhereInput
  }

  export type CommunicationUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: CommunicationWhereInput
    data: XOR<CommunicationUpdateWithoutAttachmentsInput, CommunicationUncheckedUpdateWithoutAttachmentsInput>
  }

  export type CommunicationUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    radicado?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    senderEntity?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderTitle?: StringFieldUpdateOperationsInput | string
    recipientEntity?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientTitle?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommunicationStatusFieldUpdateOperationsInput | $Enums.CommunicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneRequiredWithoutCommunicationsNestedInput
    parent?: CommunicationUpdateOneWithoutRepliesNestedInput
    replies?: CommunicationUpdateManyWithoutParentNestedInput
    statusHistory?: CommunicationStatusHistoryUpdateManyWithoutCommunicationNestedInput
  }

  export type CommunicationUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    radicado?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    senderEntity?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderTitle?: StringFieldUpdateOperationsInput | string
    recipientEntity?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientTitle?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommunicationStatusFieldUpdateOperationsInput | $Enums.CommunicationStatus
    uploaderId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommunicationUncheckedUpdateManyWithoutParentNestedInput
    statusHistory?: CommunicationStatusHistoryUncheckedUpdateManyWithoutCommunicationNestedInput
  }

  export type ActaUpsertWithoutAttachmentsInput = {
    update: XOR<ActaUpdateWithoutAttachmentsInput, ActaUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<ActaCreateWithoutAttachmentsInput, ActaUncheckedCreateWithoutAttachmentsInput>
    where?: ActaWhereInput
  }

  export type ActaUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: ActaWhereInput
    data: XOR<ActaUpdateWithoutAttachmentsInput, ActaUncheckedUpdateWithoutAttachmentsInput>
  }

  export type ActaUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: EnumActaAreaFieldUpdateOperationsInput | $Enums.ActaArea
    status?: EnumActaStatusFieldUpdateOperationsInput | $Enums.ActaStatus
    summary?: StringFieldUpdateOperationsInput | string
    requiredSignatoriesJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signatures?: SignatureUpdateManyWithoutActaNestedInput
    commitments?: CommitmentUpdateManyWithoutActaNestedInput
  }

  export type ActaUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: EnumActaAreaFieldUpdateOperationsInput | $Enums.ActaArea
    status?: EnumActaStatusFieldUpdateOperationsInput | $Enums.ActaStatus
    summary?: StringFieldUpdateOperationsInput | string
    requiredSignatoriesJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signatures?: SignatureUncheckedUpdateManyWithoutActaNestedInput
    commitments?: CommitmentUncheckedUpdateManyWithoutActaNestedInput
  }

  export type CostActaUpsertWithoutAttachmentsInput = {
    update: XOR<CostActaUpdateWithoutAttachmentsInput, CostActaUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<CostActaCreateWithoutAttachmentsInput, CostActaUncheckedCreateWithoutAttachmentsInput>
    where?: CostActaWhereInput
  }

  export type CostActaUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: CostActaWhereInput
    data: XOR<CostActaUpdateWithoutAttachmentsInput, CostActaUncheckedUpdateWithoutAttachmentsInput>
  }

  export type CostActaUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billedAmount?: FloatFieldUpdateOperationsInput | number
    totalContractValue?: FloatFieldUpdateOperationsInput | number
    status?: EnumCostActaStatusFieldUpdateOperationsInput | $Enums.CostActaStatus
    relatedProgress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    observations?: ObservationUpdateManyWithoutCostActaNestedInput
  }

  export type CostActaUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billedAmount?: FloatFieldUpdateOperationsInput | number
    totalContractValue?: FloatFieldUpdateOperationsInput | number
    status?: EnumCostActaStatusFieldUpdateOperationsInput | $Enums.CostActaStatus
    relatedProgress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    observations?: ObservationUncheckedUpdateManyWithoutCostActaNestedInput
  }

  export type ReportUpsertWithoutAttachmentsInput = {
    update: XOR<ReportUpdateWithoutAttachmentsInput, ReportUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<ReportCreateWithoutAttachmentsInput, ReportUncheckedCreateWithoutAttachmentsInput>
    where?: ReportWhereInput
  }

  export type ReportUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: ReportWhereInput
    data: XOR<ReportUpdateWithoutAttachmentsInput, ReportUncheckedUpdateWithoutAttachmentsInput>
  }

  export type ReportUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reportScope?: EnumReportScopeFieldUpdateOperationsInput | $Enums.ReportScope
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    requiredSignatoriesJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutReportsNestedInput
    signatures?: SignatureUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reportScope?: EnumReportScopeFieldUpdateOperationsInput | $Enums.ReportScope
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    authorId?: StringFieldUpdateOperationsInput | string
    requiredSignatoriesJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signatures?: SignatureUncheckedUpdateManyWithoutReportNestedInput
  }

  export type CommentUpsertWithoutAttachmentsInput = {
    update: XOR<CommentUpdateWithoutAttachmentsInput, CommentUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<CommentCreateWithoutAttachmentsInput, CommentUncheckedCreateWithoutAttachmentsInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutAttachmentsInput, CommentUncheckedUpdateWithoutAttachmentsInput>
  }

  export type CommentUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    logEntry?: LogEntryUpdateOneWithoutCommentsNestedInput
    drawing?: DrawingUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    drawingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContractModificationUpsertWithoutAttachmentInput = {
    update: XOR<ContractModificationUpdateWithoutAttachmentInput, ContractModificationUncheckedUpdateWithoutAttachmentInput>
    create: XOR<ContractModificationCreateWithoutAttachmentInput, ContractModificationUncheckedCreateWithoutAttachmentInput>
    where?: ContractModificationWhereInput
  }

  export type ContractModificationUpdateToOneWithWhereWithoutAttachmentInput = {
    where?: ContractModificationWhereInput
    data: XOR<ContractModificationUpdateWithoutAttachmentInput, ContractModificationUncheckedUpdateWithoutAttachmentInput>
  }

  export type ContractModificationUpdateWithoutAttachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumModificationTypeFieldUpdateOperationsInput | $Enums.ModificationType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    justification?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractModificationUncheckedUpdateWithoutAttachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    type?: EnumModificationTypeFieldUpdateOperationsInput | $Enums.ModificationType
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableIntFieldUpdateOperationsInput | number | null
    justification?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkActaUpsertWithoutAttachmentsInput = {
    update: XOR<WorkActaUpdateWithoutAttachmentsInput, WorkActaUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<WorkActaCreateWithoutAttachmentsInput, WorkActaUncheckedCreateWithoutAttachmentsInput>
    where?: WorkActaWhereInput
  }

  export type WorkActaUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: WorkActaWhereInput
    data: XOR<WorkActaUpdateWithoutAttachmentsInput, WorkActaUncheckedUpdateWithoutAttachmentsInput>
  }

  export type WorkActaUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWorkActaStatusFieldUpdateOperationsInput | $Enums.WorkActaStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: WorkActaItemUpdateManyWithoutWorkActaNestedInput
  }

  export type WorkActaUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWorkActaStatusFieldUpdateOperationsInput | $Enums.WorkActaStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: WorkActaItemUncheckedUpdateManyWithoutWorkActaNestedInput
  }

  export type WeeklyReportUpsertWithoutAttachmentsInput = {
    update: XOR<WeeklyReportUpdateWithoutAttachmentsInput, WeeklyReportUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<WeeklyReportCreateWithoutAttachmentsInput, WeeklyReportUncheckedCreateWithoutAttachmentsInput>
    where?: WeeklyReportWhereInput
  }

  export type WeeklyReportUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: WeeklyReportWhereInput
    data: XOR<WeeklyReportUpdateWithoutAttachmentsInput, WeeklyReportUncheckedUpdateWithoutAttachmentsInput>
  }

  export type WeeklyReportUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    progressSummary?: NullableStringFieldUpdateOperationsInput | string | null
    nextWeekPlan?: NullableStringFieldUpdateOperationsInput | string | null
    issues?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WeeklyReportUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    progressSummary?: NullableStringFieldUpdateOperationsInput | string | null
    nextWeekPlan?: NullableStringFieldUpdateOperationsInput | string | null
    issues?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoEntryUpsertWithoutAttachmentInput = {
    update: XOR<PhotoEntryUpdateWithoutAttachmentInput, PhotoEntryUncheckedUpdateWithoutAttachmentInput>
    create: XOR<PhotoEntryCreateWithoutAttachmentInput, PhotoEntryUncheckedCreateWithoutAttachmentInput>
    where?: PhotoEntryWhereInput
  }

  export type PhotoEntryUpdateToOneWithWhereWithoutAttachmentInput = {
    where?: PhotoEntryWhereInput
    data: XOR<PhotoEntryUpdateWithoutAttachmentInput, PhotoEntryUncheckedUpdateWithoutAttachmentInput>
  }

  export type PhotoEntryUpdateWithoutAttachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    author?: UserUpdateOneRequiredWithoutPhotoEntriesNestedInput
    controlPoint?: ControlPointUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type PhotoEntryUncheckedUpdateWithoutAttachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    controlPointId?: StringFieldUpdateOperationsInput | string
  }

  export type AttachmentCreateWithoutActaInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    createdAt?: Date | string
    logEntry?: LogEntryCreateNestedOneWithoutAttachmentsInput
    communication?: CommunicationCreateNestedOneWithoutAttachmentsInput
    costActa?: CostActaCreateNestedOneWithoutAttachmentsInput
    report?: ReportCreateNestedOneWithoutAttachmentsInput
    comment?: CommentCreateNestedOneWithoutAttachmentsInput
    contractMod?: ContractModificationCreateNestedOneWithoutAttachmentInput
    workActa?: WorkActaCreateNestedOneWithoutAttachmentsInput
    weeklyReport?: WeeklyReportCreateNestedOneWithoutAttachmentsInput
    photoEntry?: PhotoEntryCreateNestedOneWithoutAttachmentInput
  }

  export type AttachmentUncheckedCreateWithoutActaInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    logEntryId?: string | null
    communicationId?: string | null
    costActaId?: string | null
    reportId?: string | null
    commentId?: string | null
    workActaId?: string | null
    weeklyReportId?: string | null
    createdAt?: Date | string
    contractMod?: ContractModificationUncheckedCreateNestedOneWithoutAttachmentInput
    photoEntry?: PhotoEntryUncheckedCreateNestedOneWithoutAttachmentInput
  }

  export type AttachmentCreateOrConnectWithoutActaInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutActaInput, AttachmentUncheckedCreateWithoutActaInput>
  }

  export type AttachmentCreateManyActaInputEnvelope = {
    data: AttachmentCreateManyActaInput | AttachmentCreateManyActaInput[]
    skipDuplicates?: boolean
  }

  export type SignatureCreateWithoutActaInput = {
    id?: string
    signedAt?: Date | string
    signer: UserCreateNestedOneWithoutSignaturesInput
    logEntry?: LogEntryCreateNestedOneWithoutSignaturesInput
    report?: ReportCreateNestedOneWithoutSignaturesInput
  }

  export type SignatureUncheckedCreateWithoutActaInput = {
    id?: string
    signedAt?: Date | string
    signerId: string
    logEntryId?: string | null
    reportId?: string | null
  }

  export type SignatureCreateOrConnectWithoutActaInput = {
    where: SignatureWhereUniqueInput
    create: XOR<SignatureCreateWithoutActaInput, SignatureUncheckedCreateWithoutActaInput>
  }

  export type SignatureCreateManyActaInputEnvelope = {
    data: SignatureCreateManyActaInput | SignatureCreateManyActaInput[]
    skipDuplicates?: boolean
  }

  export type CommitmentCreateWithoutActaInput = {
    id?: string
    description: string
    dueDate: Date | string
    status: $Enums.CommitmentStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    responsible: UserCreateNestedOneWithoutResponsibleForInput
  }

  export type CommitmentUncheckedCreateWithoutActaInput = {
    id?: string
    description: string
    dueDate: Date | string
    status: $Enums.CommitmentStatus
    responsibleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommitmentCreateOrConnectWithoutActaInput = {
    where: CommitmentWhereUniqueInput
    create: XOR<CommitmentCreateWithoutActaInput, CommitmentUncheckedCreateWithoutActaInput>
  }

  export type CommitmentCreateManyActaInputEnvelope = {
    data: CommitmentCreateManyActaInput | CommitmentCreateManyActaInput[]
    skipDuplicates?: boolean
  }

  export type AttachmentUpsertWithWhereUniqueWithoutActaInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutActaInput, AttachmentUncheckedUpdateWithoutActaInput>
    create: XOR<AttachmentCreateWithoutActaInput, AttachmentUncheckedCreateWithoutActaInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutActaInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutActaInput, AttachmentUncheckedUpdateWithoutActaInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutActaInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutActaInput>
  }

  export type SignatureUpsertWithWhereUniqueWithoutActaInput = {
    where: SignatureWhereUniqueInput
    update: XOR<SignatureUpdateWithoutActaInput, SignatureUncheckedUpdateWithoutActaInput>
    create: XOR<SignatureCreateWithoutActaInput, SignatureUncheckedCreateWithoutActaInput>
  }

  export type SignatureUpdateWithWhereUniqueWithoutActaInput = {
    where: SignatureWhereUniqueInput
    data: XOR<SignatureUpdateWithoutActaInput, SignatureUncheckedUpdateWithoutActaInput>
  }

  export type SignatureUpdateManyWithWhereWithoutActaInput = {
    where: SignatureScalarWhereInput
    data: XOR<SignatureUpdateManyMutationInput, SignatureUncheckedUpdateManyWithoutActaInput>
  }

  export type CommitmentUpsertWithWhereUniqueWithoutActaInput = {
    where: CommitmentWhereUniqueInput
    update: XOR<CommitmentUpdateWithoutActaInput, CommitmentUncheckedUpdateWithoutActaInput>
    create: XOR<CommitmentCreateWithoutActaInput, CommitmentUncheckedCreateWithoutActaInput>
  }

  export type CommitmentUpdateWithWhereUniqueWithoutActaInput = {
    where: CommitmentWhereUniqueInput
    data: XOR<CommitmentUpdateWithoutActaInput, CommitmentUncheckedUpdateWithoutActaInput>
  }

  export type CommitmentUpdateManyWithWhereWithoutActaInput = {
    where: CommitmentScalarWhereInput
    data: XOR<CommitmentUpdateManyMutationInput, CommitmentUncheckedUpdateManyWithoutActaInput>
  }

  export type UserCreateWithoutResponsibleForInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryCreateNestedManyWithoutAuthorInput
    assignedTo?: LogEntryCreateNestedManyWithoutAssigneesInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    signatures?: SignatureCreateNestedManyWithoutSignerInput
    communications?: CommunicationCreateNestedManyWithoutUploaderInput
    statusChanges?: CommunicationStatusHistoryCreateNestedManyWithoutUserInput
    photoEntries?: PhotoEntryCreateNestedManyWithoutAuthorInput
    observations?: ObservationCreateNestedManyWithoutAuthorInput
    reports?: ReportCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionCreateNestedManyWithoutUploaderInput
    logEntryHistory?: LogEntryHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResponsibleForInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryUncheckedCreateNestedManyWithoutAuthorInput
    assignedTo?: LogEntryUncheckedCreateNestedManyWithoutAssigneesInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutSignerInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUploaderInput
    statusChanges?: CommunicationStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    photoEntries?: PhotoEntryUncheckedCreateNestedManyWithoutAuthorInput
    observations?: ObservationUncheckedCreateNestedManyWithoutAuthorInput
    reports?: ReportUncheckedCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionUncheckedCreateNestedManyWithoutUploaderInput
    logEntryHistory?: LogEntryHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResponsibleForInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResponsibleForInput, UserUncheckedCreateWithoutResponsibleForInput>
  }

  export type ActaCreateWithoutCommitmentsInput = {
    id?: string
    number: string
    title: string
    date: Date | string
    area: $Enums.ActaArea
    status: $Enums.ActaStatus
    summary: string
    requiredSignatoriesJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentCreateNestedManyWithoutActaInput
    signatures?: SignatureCreateNestedManyWithoutActaInput
  }

  export type ActaUncheckedCreateWithoutCommitmentsInput = {
    id?: string
    number: string
    title: string
    date: Date | string
    area: $Enums.ActaArea
    status: $Enums.ActaStatus
    summary: string
    requiredSignatoriesJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutActaInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutActaInput
  }

  export type ActaCreateOrConnectWithoutCommitmentsInput = {
    where: ActaWhereUniqueInput
    create: XOR<ActaCreateWithoutCommitmentsInput, ActaUncheckedCreateWithoutCommitmentsInput>
  }

  export type UserUpsertWithoutResponsibleForInput = {
    update: XOR<UserUpdateWithoutResponsibleForInput, UserUncheckedUpdateWithoutResponsibleForInput>
    create: XOR<UserCreateWithoutResponsibleForInput, UserUncheckedCreateWithoutResponsibleForInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResponsibleForInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResponsibleForInput, UserUncheckedUpdateWithoutResponsibleForInput>
  }

  export type UserUpdateWithoutResponsibleForInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUpdateManyWithoutAuthorNestedInput
    assignedTo?: LogEntryUpdateManyWithoutAssigneesNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    signatures?: SignatureUpdateManyWithoutSignerNestedInput
    communications?: CommunicationUpdateManyWithoutUploaderNestedInput
    statusChanges?: CommunicationStatusHistoryUpdateManyWithoutUserNestedInput
    photoEntries?: PhotoEntryUpdateManyWithoutAuthorNestedInput
    observations?: ObservationUpdateManyWithoutAuthorNestedInput
    reports?: ReportUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUpdateManyWithoutUploaderNestedInput
    logEntryHistory?: LogEntryHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResponsibleForInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTo?: LogEntryUncheckedUpdateManyWithoutAssigneesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutSignerNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUploaderNestedInput
    statusChanges?: CommunicationStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    photoEntries?: PhotoEntryUncheckedUpdateManyWithoutAuthorNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutAuthorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUncheckedUpdateManyWithoutUploaderNestedInput
    logEntryHistory?: LogEntryHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ActaUpsertWithoutCommitmentsInput = {
    update: XOR<ActaUpdateWithoutCommitmentsInput, ActaUncheckedUpdateWithoutCommitmentsInput>
    create: XOR<ActaCreateWithoutCommitmentsInput, ActaUncheckedCreateWithoutCommitmentsInput>
    where?: ActaWhereInput
  }

  export type ActaUpdateToOneWithWhereWithoutCommitmentsInput = {
    where?: ActaWhereInput
    data: XOR<ActaUpdateWithoutCommitmentsInput, ActaUncheckedUpdateWithoutCommitmentsInput>
  }

  export type ActaUpdateWithoutCommitmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: EnumActaAreaFieldUpdateOperationsInput | $Enums.ActaArea
    status?: EnumActaStatusFieldUpdateOperationsInput | $Enums.ActaStatus
    summary?: StringFieldUpdateOperationsInput | string
    requiredSignatoriesJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUpdateManyWithoutActaNestedInput
    signatures?: SignatureUpdateManyWithoutActaNestedInput
  }

  export type ActaUncheckedUpdateWithoutCommitmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    area?: EnumActaAreaFieldUpdateOperationsInput | $Enums.ActaArea
    status?: EnumActaStatusFieldUpdateOperationsInput | $Enums.ActaStatus
    summary?: StringFieldUpdateOperationsInput | string
    requiredSignatoriesJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutActaNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutActaNestedInput
  }

  export type ObservationCreateWithoutCostActaInput = {
    id?: string
    text: string
    timestamp?: Date | string
    author: UserCreateNestedOneWithoutObservationsInput
  }

  export type ObservationUncheckedCreateWithoutCostActaInput = {
    id?: string
    text: string
    timestamp?: Date | string
    authorId: string
  }

  export type ObservationCreateOrConnectWithoutCostActaInput = {
    where: ObservationWhereUniqueInput
    create: XOR<ObservationCreateWithoutCostActaInput, ObservationUncheckedCreateWithoutCostActaInput>
  }

  export type ObservationCreateManyCostActaInputEnvelope = {
    data: ObservationCreateManyCostActaInput | ObservationCreateManyCostActaInput[]
    skipDuplicates?: boolean
  }

  export type AttachmentCreateWithoutCostActaInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    createdAt?: Date | string
    logEntry?: LogEntryCreateNestedOneWithoutAttachmentsInput
    communication?: CommunicationCreateNestedOneWithoutAttachmentsInput
    acta?: ActaCreateNestedOneWithoutAttachmentsInput
    report?: ReportCreateNestedOneWithoutAttachmentsInput
    comment?: CommentCreateNestedOneWithoutAttachmentsInput
    contractMod?: ContractModificationCreateNestedOneWithoutAttachmentInput
    workActa?: WorkActaCreateNestedOneWithoutAttachmentsInput
    weeklyReport?: WeeklyReportCreateNestedOneWithoutAttachmentsInput
    photoEntry?: PhotoEntryCreateNestedOneWithoutAttachmentInput
  }

  export type AttachmentUncheckedCreateWithoutCostActaInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    logEntryId?: string | null
    communicationId?: string | null
    actaId?: string | null
    reportId?: string | null
    commentId?: string | null
    workActaId?: string | null
    weeklyReportId?: string | null
    createdAt?: Date | string
    contractMod?: ContractModificationUncheckedCreateNestedOneWithoutAttachmentInput
    photoEntry?: PhotoEntryUncheckedCreateNestedOneWithoutAttachmentInput
  }

  export type AttachmentCreateOrConnectWithoutCostActaInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutCostActaInput, AttachmentUncheckedCreateWithoutCostActaInput>
  }

  export type AttachmentCreateManyCostActaInputEnvelope = {
    data: AttachmentCreateManyCostActaInput | AttachmentCreateManyCostActaInput[]
    skipDuplicates?: boolean
  }

  export type ObservationUpsertWithWhereUniqueWithoutCostActaInput = {
    where: ObservationWhereUniqueInput
    update: XOR<ObservationUpdateWithoutCostActaInput, ObservationUncheckedUpdateWithoutCostActaInput>
    create: XOR<ObservationCreateWithoutCostActaInput, ObservationUncheckedCreateWithoutCostActaInput>
  }

  export type ObservationUpdateWithWhereUniqueWithoutCostActaInput = {
    where: ObservationWhereUniqueInput
    data: XOR<ObservationUpdateWithoutCostActaInput, ObservationUncheckedUpdateWithoutCostActaInput>
  }

  export type ObservationUpdateManyWithWhereWithoutCostActaInput = {
    where: ObservationScalarWhereInput
    data: XOR<ObservationUpdateManyMutationInput, ObservationUncheckedUpdateManyWithoutCostActaInput>
  }

  export type AttachmentUpsertWithWhereUniqueWithoutCostActaInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutCostActaInput, AttachmentUncheckedUpdateWithoutCostActaInput>
    create: XOR<AttachmentCreateWithoutCostActaInput, AttachmentUncheckedCreateWithoutCostActaInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutCostActaInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutCostActaInput, AttachmentUncheckedUpdateWithoutCostActaInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutCostActaInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutCostActaInput>
  }

  export type UserCreateWithoutObservationsInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryCreateNestedManyWithoutAuthorInput
    assignedTo?: LogEntryCreateNestedManyWithoutAssigneesInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    signatures?: SignatureCreateNestedManyWithoutSignerInput
    communications?: CommunicationCreateNestedManyWithoutUploaderInput
    statusChanges?: CommunicationStatusHistoryCreateNestedManyWithoutUserInput
    photoEntries?: PhotoEntryCreateNestedManyWithoutAuthorInput
    responsibleFor?: CommitmentCreateNestedManyWithoutResponsibleInput
    reports?: ReportCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionCreateNestedManyWithoutUploaderInput
    logEntryHistory?: LogEntryHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutObservationsInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryUncheckedCreateNestedManyWithoutAuthorInput
    assignedTo?: LogEntryUncheckedCreateNestedManyWithoutAssigneesInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutSignerInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUploaderInput
    statusChanges?: CommunicationStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    photoEntries?: PhotoEntryUncheckedCreateNestedManyWithoutAuthorInput
    responsibleFor?: CommitmentUncheckedCreateNestedManyWithoutResponsibleInput
    reports?: ReportUncheckedCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionUncheckedCreateNestedManyWithoutUploaderInput
    logEntryHistory?: LogEntryHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutObservationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutObservationsInput, UserUncheckedCreateWithoutObservationsInput>
  }

  export type CostActaCreateWithoutObservationsInput = {
    id?: string
    number: string
    period: string
    submissionDate: Date | string
    approvalDate?: Date | string | null
    paymentDueDate?: Date | string | null
    billedAmount: number
    totalContractValue: number
    status: $Enums.CostActaStatus
    relatedProgress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentCreateNestedManyWithoutCostActaInput
  }

  export type CostActaUncheckedCreateWithoutObservationsInput = {
    id?: string
    number: string
    period: string
    submissionDate: Date | string
    approvalDate?: Date | string | null
    paymentDueDate?: Date | string | null
    billedAmount: number
    totalContractValue: number
    status: $Enums.CostActaStatus
    relatedProgress?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutCostActaInput
  }

  export type CostActaCreateOrConnectWithoutObservationsInput = {
    where: CostActaWhereUniqueInput
    create: XOR<CostActaCreateWithoutObservationsInput, CostActaUncheckedCreateWithoutObservationsInput>
  }

  export type UserUpsertWithoutObservationsInput = {
    update: XOR<UserUpdateWithoutObservationsInput, UserUncheckedUpdateWithoutObservationsInput>
    create: XOR<UserCreateWithoutObservationsInput, UserUncheckedCreateWithoutObservationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutObservationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutObservationsInput, UserUncheckedUpdateWithoutObservationsInput>
  }

  export type UserUpdateWithoutObservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUpdateManyWithoutAuthorNestedInput
    assignedTo?: LogEntryUpdateManyWithoutAssigneesNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    signatures?: SignatureUpdateManyWithoutSignerNestedInput
    communications?: CommunicationUpdateManyWithoutUploaderNestedInput
    statusChanges?: CommunicationStatusHistoryUpdateManyWithoutUserNestedInput
    photoEntries?: PhotoEntryUpdateManyWithoutAuthorNestedInput
    responsibleFor?: CommitmentUpdateManyWithoutResponsibleNestedInput
    reports?: ReportUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUpdateManyWithoutUploaderNestedInput
    logEntryHistory?: LogEntryHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutObservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTo?: LogEntryUncheckedUpdateManyWithoutAssigneesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutSignerNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUploaderNestedInput
    statusChanges?: CommunicationStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    photoEntries?: PhotoEntryUncheckedUpdateManyWithoutAuthorNestedInput
    responsibleFor?: CommitmentUncheckedUpdateManyWithoutResponsibleNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUncheckedUpdateManyWithoutUploaderNestedInput
    logEntryHistory?: LogEntryHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CostActaUpsertWithoutObservationsInput = {
    update: XOR<CostActaUpdateWithoutObservationsInput, CostActaUncheckedUpdateWithoutObservationsInput>
    create: XOR<CostActaCreateWithoutObservationsInput, CostActaUncheckedCreateWithoutObservationsInput>
    where?: CostActaWhereInput
  }

  export type CostActaUpdateToOneWithWhereWithoutObservationsInput = {
    where?: CostActaWhereInput
    data: XOR<CostActaUpdateWithoutObservationsInput, CostActaUncheckedUpdateWithoutObservationsInput>
  }

  export type CostActaUpdateWithoutObservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billedAmount?: FloatFieldUpdateOperationsInput | number
    totalContractValue?: FloatFieldUpdateOperationsInput | number
    status?: EnumCostActaStatusFieldUpdateOperationsInput | $Enums.CostActaStatus
    relatedProgress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUpdateManyWithoutCostActaNestedInput
  }

  export type CostActaUncheckedUpdateWithoutObservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    approvalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    billedAmount?: FloatFieldUpdateOperationsInput | number
    totalContractValue?: FloatFieldUpdateOperationsInput | number
    status?: EnumCostActaStatusFieldUpdateOperationsInput | $Enums.CostActaStatus
    relatedProgress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutCostActaNestedInput
  }

  export type UserCreateWithoutReportsInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryCreateNestedManyWithoutAuthorInput
    assignedTo?: LogEntryCreateNestedManyWithoutAssigneesInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    signatures?: SignatureCreateNestedManyWithoutSignerInput
    communications?: CommunicationCreateNestedManyWithoutUploaderInput
    statusChanges?: CommunicationStatusHistoryCreateNestedManyWithoutUserInput
    photoEntries?: PhotoEntryCreateNestedManyWithoutAuthorInput
    responsibleFor?: CommitmentCreateNestedManyWithoutResponsibleInput
    observations?: ObservationCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionCreateNestedManyWithoutUploaderInput
    logEntryHistory?: LogEntryHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportsInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryUncheckedCreateNestedManyWithoutAuthorInput
    assignedTo?: LogEntryUncheckedCreateNestedManyWithoutAssigneesInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutSignerInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUploaderInput
    statusChanges?: CommunicationStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    photoEntries?: PhotoEntryUncheckedCreateNestedManyWithoutAuthorInput
    responsibleFor?: CommitmentUncheckedCreateNestedManyWithoutResponsibleInput
    observations?: ObservationUncheckedCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionUncheckedCreateNestedManyWithoutUploaderInput
    logEntryHistory?: LogEntryHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
  }

  export type AttachmentCreateWithoutReportInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    createdAt?: Date | string
    logEntry?: LogEntryCreateNestedOneWithoutAttachmentsInput
    communication?: CommunicationCreateNestedOneWithoutAttachmentsInput
    acta?: ActaCreateNestedOneWithoutAttachmentsInput
    costActa?: CostActaCreateNestedOneWithoutAttachmentsInput
    comment?: CommentCreateNestedOneWithoutAttachmentsInput
    contractMod?: ContractModificationCreateNestedOneWithoutAttachmentInput
    workActa?: WorkActaCreateNestedOneWithoutAttachmentsInput
    weeklyReport?: WeeklyReportCreateNestedOneWithoutAttachmentsInput
    photoEntry?: PhotoEntryCreateNestedOneWithoutAttachmentInput
  }

  export type AttachmentUncheckedCreateWithoutReportInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    logEntryId?: string | null
    communicationId?: string | null
    actaId?: string | null
    costActaId?: string | null
    commentId?: string | null
    workActaId?: string | null
    weeklyReportId?: string | null
    createdAt?: Date | string
    contractMod?: ContractModificationUncheckedCreateNestedOneWithoutAttachmentInput
    photoEntry?: PhotoEntryUncheckedCreateNestedOneWithoutAttachmentInput
  }

  export type AttachmentCreateOrConnectWithoutReportInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutReportInput, AttachmentUncheckedCreateWithoutReportInput>
  }

  export type AttachmentCreateManyReportInputEnvelope = {
    data: AttachmentCreateManyReportInput | AttachmentCreateManyReportInput[]
    skipDuplicates?: boolean
  }

  export type SignatureCreateWithoutReportInput = {
    id?: string
    signedAt?: Date | string
    signer: UserCreateNestedOneWithoutSignaturesInput
    logEntry?: LogEntryCreateNestedOneWithoutSignaturesInput
    acta?: ActaCreateNestedOneWithoutSignaturesInput
  }

  export type SignatureUncheckedCreateWithoutReportInput = {
    id?: string
    signedAt?: Date | string
    signerId: string
    logEntryId?: string | null
    actaId?: string | null
  }

  export type SignatureCreateOrConnectWithoutReportInput = {
    where: SignatureWhereUniqueInput
    create: XOR<SignatureCreateWithoutReportInput, SignatureUncheckedCreateWithoutReportInput>
  }

  export type SignatureCreateManyReportInputEnvelope = {
    data: SignatureCreateManyReportInput | SignatureCreateManyReportInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutReportsInput = {
    update: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUpdateManyWithoutAuthorNestedInput
    assignedTo?: LogEntryUpdateManyWithoutAssigneesNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    signatures?: SignatureUpdateManyWithoutSignerNestedInput
    communications?: CommunicationUpdateManyWithoutUploaderNestedInput
    statusChanges?: CommunicationStatusHistoryUpdateManyWithoutUserNestedInput
    photoEntries?: PhotoEntryUpdateManyWithoutAuthorNestedInput
    responsibleFor?: CommitmentUpdateManyWithoutResponsibleNestedInput
    observations?: ObservationUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUpdateManyWithoutUploaderNestedInput
    logEntryHistory?: LogEntryHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTo?: LogEntryUncheckedUpdateManyWithoutAssigneesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutSignerNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUploaderNestedInput
    statusChanges?: CommunicationStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    photoEntries?: PhotoEntryUncheckedUpdateManyWithoutAuthorNestedInput
    responsibleFor?: CommitmentUncheckedUpdateManyWithoutResponsibleNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUncheckedUpdateManyWithoutUploaderNestedInput
    logEntryHistory?: LogEntryHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AttachmentUpsertWithWhereUniqueWithoutReportInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutReportInput, AttachmentUncheckedUpdateWithoutReportInput>
    create: XOR<AttachmentCreateWithoutReportInput, AttachmentUncheckedCreateWithoutReportInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutReportInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutReportInput, AttachmentUncheckedUpdateWithoutReportInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutReportInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutReportInput>
  }

  export type SignatureUpsertWithWhereUniqueWithoutReportInput = {
    where: SignatureWhereUniqueInput
    update: XOR<SignatureUpdateWithoutReportInput, SignatureUncheckedUpdateWithoutReportInput>
    create: XOR<SignatureCreateWithoutReportInput, SignatureUncheckedCreateWithoutReportInput>
  }

  export type SignatureUpdateWithWhereUniqueWithoutReportInput = {
    where: SignatureWhereUniqueInput
    data: XOR<SignatureUpdateWithoutReportInput, SignatureUncheckedUpdateWithoutReportInput>
  }

  export type SignatureUpdateManyWithWhereWithoutReportInput = {
    where: SignatureScalarWhereInput
    data: XOR<SignatureUpdateManyMutationInput, SignatureUncheckedUpdateManyWithoutReportInput>
  }

  export type DrawingVersionCreateWithoutDrawingInput = {
    id?: string
    versionNumber: number
    fileName: string
    url: string
    size: number
    uploadDate?: Date | string
    uploader: UserCreateNestedOneWithoutDrawingVersionsInput
  }

  export type DrawingVersionUncheckedCreateWithoutDrawingInput = {
    id?: string
    versionNumber: number
    fileName: string
    url: string
    size: number
    uploadDate?: Date | string
    uploaderId: string
  }

  export type DrawingVersionCreateOrConnectWithoutDrawingInput = {
    where: DrawingVersionWhereUniqueInput
    create: XOR<DrawingVersionCreateWithoutDrawingInput, DrawingVersionUncheckedCreateWithoutDrawingInput>
  }

  export type DrawingVersionCreateManyDrawingInputEnvelope = {
    data: DrawingVersionCreateManyDrawingInput | DrawingVersionCreateManyDrawingInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutDrawingInput = {
    id?: string
    content: string
    timestamp?: Date | string
    author: UserCreateNestedOneWithoutCommentsInput
    logEntry?: LogEntryCreateNestedOneWithoutCommentsInput
    attachments?: AttachmentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutDrawingInput = {
    id?: string
    content: string
    timestamp?: Date | string
    authorId: string
    logEntryId?: string | null
    attachments?: AttachmentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutDrawingInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutDrawingInput, CommentUncheckedCreateWithoutDrawingInput>
  }

  export type CommentCreateManyDrawingInputEnvelope = {
    data: CommentCreateManyDrawingInput | CommentCreateManyDrawingInput[]
    skipDuplicates?: boolean
  }

  export type DrawingVersionUpsertWithWhereUniqueWithoutDrawingInput = {
    where: DrawingVersionWhereUniqueInput
    update: XOR<DrawingVersionUpdateWithoutDrawingInput, DrawingVersionUncheckedUpdateWithoutDrawingInput>
    create: XOR<DrawingVersionCreateWithoutDrawingInput, DrawingVersionUncheckedCreateWithoutDrawingInput>
  }

  export type DrawingVersionUpdateWithWhereUniqueWithoutDrawingInput = {
    where: DrawingVersionWhereUniqueInput
    data: XOR<DrawingVersionUpdateWithoutDrawingInput, DrawingVersionUncheckedUpdateWithoutDrawingInput>
  }

  export type DrawingVersionUpdateManyWithWhereWithoutDrawingInput = {
    where: DrawingVersionScalarWhereInput
    data: XOR<DrawingVersionUpdateManyMutationInput, DrawingVersionUncheckedUpdateManyWithoutDrawingInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutDrawingInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutDrawingInput, CommentUncheckedUpdateWithoutDrawingInput>
    create: XOR<CommentCreateWithoutDrawingInput, CommentUncheckedCreateWithoutDrawingInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutDrawingInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutDrawingInput, CommentUncheckedUpdateWithoutDrawingInput>
  }

  export type CommentUpdateManyWithWhereWithoutDrawingInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutDrawingInput>
  }

  export type UserCreateWithoutDrawingVersionsInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryCreateNestedManyWithoutAuthorInput
    assignedTo?: LogEntryCreateNestedManyWithoutAssigneesInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    signatures?: SignatureCreateNestedManyWithoutSignerInput
    communications?: CommunicationCreateNestedManyWithoutUploaderInput
    statusChanges?: CommunicationStatusHistoryCreateNestedManyWithoutUserInput
    photoEntries?: PhotoEntryCreateNestedManyWithoutAuthorInput
    responsibleFor?: CommitmentCreateNestedManyWithoutResponsibleInput
    observations?: ObservationCreateNestedManyWithoutAuthorInput
    reports?: ReportCreateNestedManyWithoutAuthorInput
    logEntryHistory?: LogEntryHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDrawingVersionsInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryUncheckedCreateNestedManyWithoutAuthorInput
    assignedTo?: LogEntryUncheckedCreateNestedManyWithoutAssigneesInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutSignerInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUploaderInput
    statusChanges?: CommunicationStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    photoEntries?: PhotoEntryUncheckedCreateNestedManyWithoutAuthorInput
    responsibleFor?: CommitmentUncheckedCreateNestedManyWithoutResponsibleInput
    observations?: ObservationUncheckedCreateNestedManyWithoutAuthorInput
    reports?: ReportUncheckedCreateNestedManyWithoutAuthorInput
    logEntryHistory?: LogEntryHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDrawingVersionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDrawingVersionsInput, UserUncheckedCreateWithoutDrawingVersionsInput>
  }

  export type DrawingCreateWithoutVersionsInput = {
    id?: string
    code: string
    title: string
    discipline: $Enums.DrawingDiscipline
    status: $Enums.DrawingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutDrawingInput
  }

  export type DrawingUncheckedCreateWithoutVersionsInput = {
    id?: string
    code: string
    title: string
    discipline: $Enums.DrawingDiscipline
    status: $Enums.DrawingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutDrawingInput
  }

  export type DrawingCreateOrConnectWithoutVersionsInput = {
    where: DrawingWhereUniqueInput
    create: XOR<DrawingCreateWithoutVersionsInput, DrawingUncheckedCreateWithoutVersionsInput>
  }

  export type UserUpsertWithoutDrawingVersionsInput = {
    update: XOR<UserUpdateWithoutDrawingVersionsInput, UserUncheckedUpdateWithoutDrawingVersionsInput>
    create: XOR<UserCreateWithoutDrawingVersionsInput, UserUncheckedCreateWithoutDrawingVersionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDrawingVersionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDrawingVersionsInput, UserUncheckedUpdateWithoutDrawingVersionsInput>
  }

  export type UserUpdateWithoutDrawingVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUpdateManyWithoutAuthorNestedInput
    assignedTo?: LogEntryUpdateManyWithoutAssigneesNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    signatures?: SignatureUpdateManyWithoutSignerNestedInput
    communications?: CommunicationUpdateManyWithoutUploaderNestedInput
    statusChanges?: CommunicationStatusHistoryUpdateManyWithoutUserNestedInput
    photoEntries?: PhotoEntryUpdateManyWithoutAuthorNestedInput
    responsibleFor?: CommitmentUpdateManyWithoutResponsibleNestedInput
    observations?: ObservationUpdateManyWithoutAuthorNestedInput
    reports?: ReportUpdateManyWithoutAuthorNestedInput
    logEntryHistory?: LogEntryHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDrawingVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTo?: LogEntryUncheckedUpdateManyWithoutAssigneesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutSignerNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUploaderNestedInput
    statusChanges?: CommunicationStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    photoEntries?: PhotoEntryUncheckedUpdateManyWithoutAuthorNestedInput
    responsibleFor?: CommitmentUncheckedUpdateManyWithoutResponsibleNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutAuthorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAuthorNestedInput
    logEntryHistory?: LogEntryHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DrawingUpsertWithoutVersionsInput = {
    update: XOR<DrawingUpdateWithoutVersionsInput, DrawingUncheckedUpdateWithoutVersionsInput>
    create: XOR<DrawingCreateWithoutVersionsInput, DrawingUncheckedCreateWithoutVersionsInput>
    where?: DrawingWhereInput
  }

  export type DrawingUpdateToOneWithWhereWithoutVersionsInput = {
    where?: DrawingWhereInput
    data: XOR<DrawingUpdateWithoutVersionsInput, DrawingUncheckedUpdateWithoutVersionsInput>
  }

  export type DrawingUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    discipline?: EnumDrawingDisciplineFieldUpdateOperationsInput | $Enums.DrawingDiscipline
    status?: EnumDrawingStatusFieldUpdateOperationsInput | $Enums.DrawingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutDrawingNestedInput
  }

  export type DrawingUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    discipline?: EnumDrawingDisciplineFieldUpdateOperationsInput | $Enums.DrawingDiscipline
    status?: EnumDrawingStatusFieldUpdateOperationsInput | $Enums.DrawingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutDrawingNestedInput
  }

  export type UserCreateWithoutPhotoEntriesInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryCreateNestedManyWithoutAuthorInput
    assignedTo?: LogEntryCreateNestedManyWithoutAssigneesInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    signatures?: SignatureCreateNestedManyWithoutSignerInput
    communications?: CommunicationCreateNestedManyWithoutUploaderInput
    statusChanges?: CommunicationStatusHistoryCreateNestedManyWithoutUserInput
    responsibleFor?: CommitmentCreateNestedManyWithoutResponsibleInput
    observations?: ObservationCreateNestedManyWithoutAuthorInput
    reports?: ReportCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionCreateNestedManyWithoutUploaderInput
    logEntryHistory?: LogEntryHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPhotoEntriesInput = {
    id?: string
    email: string
    password: string
    fullName: string
    projectRole: $Enums.UserRole
    appRole: $Enums.AppRole
    avatarUrl?: string | null
    status: string
    lastLoginAt?: Date | string | null
    tokenVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    logEntries?: LogEntryUncheckedCreateNestedManyWithoutAuthorInput
    assignedTo?: LogEntryUncheckedCreateNestedManyWithoutAssigneesInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    signatures?: SignatureUncheckedCreateNestedManyWithoutSignerInput
    communications?: CommunicationUncheckedCreateNestedManyWithoutUploaderInput
    statusChanges?: CommunicationStatusHistoryUncheckedCreateNestedManyWithoutUserInput
    responsibleFor?: CommitmentUncheckedCreateNestedManyWithoutResponsibleInput
    observations?: ObservationUncheckedCreateNestedManyWithoutAuthorInput
    reports?: ReportUncheckedCreateNestedManyWithoutAuthorInput
    drawingVersions?: DrawingVersionUncheckedCreateNestedManyWithoutUploaderInput
    logEntryHistory?: LogEntryHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPhotoEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPhotoEntriesInput, UserUncheckedCreateWithoutPhotoEntriesInput>
  }

  export type ControlPointCreateWithoutPhotosInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ControlPointUncheckedCreateWithoutPhotosInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ControlPointCreateOrConnectWithoutPhotosInput = {
    where: ControlPointWhereUniqueInput
    create: XOR<ControlPointCreateWithoutPhotosInput, ControlPointUncheckedCreateWithoutPhotosInput>
  }

  export type AttachmentCreateWithoutPhotoEntryInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    createdAt?: Date | string
    logEntry?: LogEntryCreateNestedOneWithoutAttachmentsInput
    communication?: CommunicationCreateNestedOneWithoutAttachmentsInput
    acta?: ActaCreateNestedOneWithoutAttachmentsInput
    costActa?: CostActaCreateNestedOneWithoutAttachmentsInput
    report?: ReportCreateNestedOneWithoutAttachmentsInput
    comment?: CommentCreateNestedOneWithoutAttachmentsInput
    contractMod?: ContractModificationCreateNestedOneWithoutAttachmentInput
    workActa?: WorkActaCreateNestedOneWithoutAttachmentsInput
    weeklyReport?: WeeklyReportCreateNestedOneWithoutAttachmentsInput
  }

  export type AttachmentUncheckedCreateWithoutPhotoEntryInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    logEntryId?: string | null
    communicationId?: string | null
    actaId?: string | null
    costActaId?: string | null
    reportId?: string | null
    commentId?: string | null
    workActaId?: string | null
    weeklyReportId?: string | null
    createdAt?: Date | string
    contractMod?: ContractModificationUncheckedCreateNestedOneWithoutAttachmentInput
  }

  export type AttachmentCreateOrConnectWithoutPhotoEntryInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutPhotoEntryInput, AttachmentUncheckedCreateWithoutPhotoEntryInput>
  }

  export type UserUpsertWithoutPhotoEntriesInput = {
    update: XOR<UserUpdateWithoutPhotoEntriesInput, UserUncheckedUpdateWithoutPhotoEntriesInput>
    create: XOR<UserCreateWithoutPhotoEntriesInput, UserUncheckedCreateWithoutPhotoEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPhotoEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPhotoEntriesInput, UserUncheckedUpdateWithoutPhotoEntriesInput>
  }

  export type UserUpdateWithoutPhotoEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUpdateManyWithoutAuthorNestedInput
    assignedTo?: LogEntryUpdateManyWithoutAssigneesNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    signatures?: SignatureUpdateManyWithoutSignerNestedInput
    communications?: CommunicationUpdateManyWithoutUploaderNestedInput
    statusChanges?: CommunicationStatusHistoryUpdateManyWithoutUserNestedInput
    responsibleFor?: CommitmentUpdateManyWithoutResponsibleNestedInput
    observations?: ObservationUpdateManyWithoutAuthorNestedInput
    reports?: ReportUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUpdateManyWithoutUploaderNestedInput
    logEntryHistory?: LogEntryHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPhotoEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUncheckedUpdateManyWithoutAuthorNestedInput
    assignedTo?: LogEntryUncheckedUpdateManyWithoutAssigneesNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutSignerNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUploaderNestedInput
    statusChanges?: CommunicationStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    responsibleFor?: CommitmentUncheckedUpdateManyWithoutResponsibleNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutAuthorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUncheckedUpdateManyWithoutUploaderNestedInput
    logEntryHistory?: LogEntryHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ControlPointUpsertWithoutPhotosInput = {
    update: XOR<ControlPointUpdateWithoutPhotosInput, ControlPointUncheckedUpdateWithoutPhotosInput>
    create: XOR<ControlPointCreateWithoutPhotosInput, ControlPointUncheckedCreateWithoutPhotosInput>
    where?: ControlPointWhereInput
  }

  export type ControlPointUpdateToOneWithWhereWithoutPhotosInput = {
    where?: ControlPointWhereInput
    data: XOR<ControlPointUpdateWithoutPhotosInput, ControlPointUncheckedUpdateWithoutPhotosInput>
  }

  export type ControlPointUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ControlPointUncheckedUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUpsertWithoutPhotoEntryInput = {
    update: XOR<AttachmentUpdateWithoutPhotoEntryInput, AttachmentUncheckedUpdateWithoutPhotoEntryInput>
    create: XOR<AttachmentCreateWithoutPhotoEntryInput, AttachmentUncheckedCreateWithoutPhotoEntryInput>
    where?: AttachmentWhereInput
  }

  export type AttachmentUpdateToOneWithWhereWithoutPhotoEntryInput = {
    where?: AttachmentWhereInput
    data: XOR<AttachmentUpdateWithoutPhotoEntryInput, AttachmentUncheckedUpdateWithoutPhotoEntryInput>
  }

  export type AttachmentUpdateWithoutPhotoEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntry?: LogEntryUpdateOneWithoutAttachmentsNestedInput
    communication?: CommunicationUpdateOneWithoutAttachmentsNestedInput
    acta?: ActaUpdateOneWithoutAttachmentsNestedInput
    costActa?: CostActaUpdateOneWithoutAttachmentsNestedInput
    report?: ReportUpdateOneWithoutAttachmentsNestedInput
    comment?: CommentUpdateOneWithoutAttachmentsNestedInput
    contractMod?: ContractModificationUpdateOneWithoutAttachmentNestedInput
    workActa?: WorkActaUpdateOneWithoutAttachmentsNestedInput
    weeklyReport?: WeeklyReportUpdateOneWithoutAttachmentsNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutPhotoEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    communicationId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    costActaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    workActaId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyReportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractMod?: ContractModificationUncheckedUpdateOneWithoutAttachmentNestedInput
  }

  export type PhotoEntryCreateWithoutControlPointInput = {
    id?: string
    url: string
    date?: Date | string
    notes?: string | null
    author: UserCreateNestedOneWithoutPhotoEntriesInput
    attachment?: AttachmentCreateNestedOneWithoutPhotoEntryInput
  }

  export type PhotoEntryUncheckedCreateWithoutControlPointInput = {
    id?: string
    url: string
    date?: Date | string
    notes?: string | null
    authorId: string
    attachmentId?: string | null
  }

  export type PhotoEntryCreateOrConnectWithoutControlPointInput = {
    where: PhotoEntryWhereUniqueInput
    create: XOR<PhotoEntryCreateWithoutControlPointInput, PhotoEntryUncheckedCreateWithoutControlPointInput>
  }

  export type PhotoEntryCreateManyControlPointInputEnvelope = {
    data: PhotoEntryCreateManyControlPointInput | PhotoEntryCreateManyControlPointInput[]
    skipDuplicates?: boolean
  }

  export type PhotoEntryUpsertWithWhereUniqueWithoutControlPointInput = {
    where: PhotoEntryWhereUniqueInput
    update: XOR<PhotoEntryUpdateWithoutControlPointInput, PhotoEntryUncheckedUpdateWithoutControlPointInput>
    create: XOR<PhotoEntryCreateWithoutControlPointInput, PhotoEntryUncheckedCreateWithoutControlPointInput>
  }

  export type PhotoEntryUpdateWithWhereUniqueWithoutControlPointInput = {
    where: PhotoEntryWhereUniqueInput
    data: XOR<PhotoEntryUpdateWithoutControlPointInput, PhotoEntryUncheckedUpdateWithoutControlPointInput>
  }

  export type PhotoEntryUpdateManyWithWhereWithoutControlPointInput = {
    where: PhotoEntryScalarWhereInput
    data: XOR<PhotoEntryUpdateManyMutationInput, PhotoEntryUncheckedUpdateManyWithoutControlPointInput>
  }

  export type WorkActaItemCreateWithoutContractItemInput = {
    id?: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workActa: WorkActaCreateNestedOneWithoutItemsInput
  }

  export type WorkActaItemUncheckedCreateWithoutContractItemInput = {
    id?: string
    quantity: number
    workActaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkActaItemCreateOrConnectWithoutContractItemInput = {
    where: WorkActaItemWhereUniqueInput
    create: XOR<WorkActaItemCreateWithoutContractItemInput, WorkActaItemUncheckedCreateWithoutContractItemInput>
  }

  export type WorkActaItemCreateManyContractItemInputEnvelope = {
    data: WorkActaItemCreateManyContractItemInput | WorkActaItemCreateManyContractItemInput[]
    skipDuplicates?: boolean
  }

  export type WorkActaItemUpsertWithWhereUniqueWithoutContractItemInput = {
    where: WorkActaItemWhereUniqueInput
    update: XOR<WorkActaItemUpdateWithoutContractItemInput, WorkActaItemUncheckedUpdateWithoutContractItemInput>
    create: XOR<WorkActaItemCreateWithoutContractItemInput, WorkActaItemUncheckedCreateWithoutContractItemInput>
  }

  export type WorkActaItemUpdateWithWhereUniqueWithoutContractItemInput = {
    where: WorkActaItemWhereUniqueInput
    data: XOR<WorkActaItemUpdateWithoutContractItemInput, WorkActaItemUncheckedUpdateWithoutContractItemInput>
  }

  export type WorkActaItemUpdateManyWithWhereWithoutContractItemInput = {
    where: WorkActaItemScalarWhereInput
    data: XOR<WorkActaItemUpdateManyMutationInput, WorkActaItemUncheckedUpdateManyWithoutContractItemInput>
  }

  export type WorkActaItemScalarWhereInput = {
    AND?: WorkActaItemScalarWhereInput | WorkActaItemScalarWhereInput[]
    OR?: WorkActaItemScalarWhereInput[]
    NOT?: WorkActaItemScalarWhereInput | WorkActaItemScalarWhereInput[]
    id?: StringFilter<"WorkActaItem"> | string
    quantity?: FloatFilter<"WorkActaItem"> | number
    workActaId?: StringFilter<"WorkActaItem"> | string
    contractItemId?: StringFilter<"WorkActaItem"> | string
    createdAt?: DateTimeFilter<"WorkActaItem"> | Date | string
    updatedAt?: DateTimeFilter<"WorkActaItem"> | Date | string
  }

  export type WorkActaItemCreateWithoutWorkActaInput = {
    id?: string
    quantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    contractItem: ContractItemCreateNestedOneWithoutWorkActaItemsInput
  }

  export type WorkActaItemUncheckedCreateWithoutWorkActaInput = {
    id?: string
    quantity: number
    contractItemId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkActaItemCreateOrConnectWithoutWorkActaInput = {
    where: WorkActaItemWhereUniqueInput
    create: XOR<WorkActaItemCreateWithoutWorkActaInput, WorkActaItemUncheckedCreateWithoutWorkActaInput>
  }

  export type WorkActaItemCreateManyWorkActaInputEnvelope = {
    data: WorkActaItemCreateManyWorkActaInput | WorkActaItemCreateManyWorkActaInput[]
    skipDuplicates?: boolean
  }

  export type AttachmentCreateWithoutWorkActaInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    createdAt?: Date | string
    logEntry?: LogEntryCreateNestedOneWithoutAttachmentsInput
    communication?: CommunicationCreateNestedOneWithoutAttachmentsInput
    acta?: ActaCreateNestedOneWithoutAttachmentsInput
    costActa?: CostActaCreateNestedOneWithoutAttachmentsInput
    report?: ReportCreateNestedOneWithoutAttachmentsInput
    comment?: CommentCreateNestedOneWithoutAttachmentsInput
    contractMod?: ContractModificationCreateNestedOneWithoutAttachmentInput
    weeklyReport?: WeeklyReportCreateNestedOneWithoutAttachmentsInput
    photoEntry?: PhotoEntryCreateNestedOneWithoutAttachmentInput
  }

  export type AttachmentUncheckedCreateWithoutWorkActaInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    logEntryId?: string | null
    communicationId?: string | null
    actaId?: string | null
    costActaId?: string | null
    reportId?: string | null
    commentId?: string | null
    weeklyReportId?: string | null
    createdAt?: Date | string
    contractMod?: ContractModificationUncheckedCreateNestedOneWithoutAttachmentInput
    photoEntry?: PhotoEntryUncheckedCreateNestedOneWithoutAttachmentInput
  }

  export type AttachmentCreateOrConnectWithoutWorkActaInput = {
    where: AttachmentWhereUniqueInput
    create: XOR<AttachmentCreateWithoutWorkActaInput, AttachmentUncheckedCreateWithoutWorkActaInput>
  }

  export type AttachmentCreateManyWorkActaInputEnvelope = {
    data: AttachmentCreateManyWorkActaInput | AttachmentCreateManyWorkActaInput[]
    skipDuplicates?: boolean
  }

  export type WorkActaItemUpsertWithWhereUniqueWithoutWorkActaInput = {
    where: WorkActaItemWhereUniqueInput
    update: XOR<WorkActaItemUpdateWithoutWorkActaInput, WorkActaItemUncheckedUpdateWithoutWorkActaInput>
    create: XOR<WorkActaItemCreateWithoutWorkActaInput, WorkActaItemUncheckedCreateWithoutWorkActaInput>
  }

  export type WorkActaItemUpdateWithWhereUniqueWithoutWorkActaInput = {
    where: WorkActaItemWhereUniqueInput
    data: XOR<WorkActaItemUpdateWithoutWorkActaInput, WorkActaItemUncheckedUpdateWithoutWorkActaInput>
  }

  export type WorkActaItemUpdateManyWithWhereWithoutWorkActaInput = {
    where: WorkActaItemScalarWhereInput
    data: XOR<WorkActaItemUpdateManyMutationInput, WorkActaItemUncheckedUpdateManyWithoutWorkActaInput>
  }

  export type AttachmentUpsertWithWhereUniqueWithoutWorkActaInput = {
    where: AttachmentWhereUniqueInput
    update: XOR<AttachmentUpdateWithoutWorkActaInput, AttachmentUncheckedUpdateWithoutWorkActaInput>
    create: XOR<AttachmentCreateWithoutWorkActaInput, AttachmentUncheckedCreateWithoutWorkActaInput>
  }

  export type AttachmentUpdateWithWhereUniqueWithoutWorkActaInput = {
    where: AttachmentWhereUniqueInput
    data: XOR<AttachmentUpdateWithoutWorkActaInput, AttachmentUncheckedUpdateWithoutWorkActaInput>
  }

  export type AttachmentUpdateManyWithWhereWithoutWorkActaInput = {
    where: AttachmentScalarWhereInput
    data: XOR<AttachmentUpdateManyMutationInput, AttachmentUncheckedUpdateManyWithoutWorkActaInput>
  }

  export type WorkActaCreateWithoutItemsInput = {
    id?: string
    number: string
    period: string
    date: Date | string
    status: $Enums.WorkActaStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentCreateNestedManyWithoutWorkActaInput
  }

  export type WorkActaUncheckedCreateWithoutItemsInput = {
    id?: string
    number: string
    period: string
    date: Date | string
    status: $Enums.WorkActaStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: AttachmentUncheckedCreateNestedManyWithoutWorkActaInput
  }

  export type WorkActaCreateOrConnectWithoutItemsInput = {
    where: WorkActaWhereUniqueInput
    create: XOR<WorkActaCreateWithoutItemsInput, WorkActaUncheckedCreateWithoutItemsInput>
  }

  export type ContractItemCreateWithoutWorkActaItemsInput = {
    id?: string
    itemCode: string
    description: string
    unit: string
    unitPrice: number
    contractQuantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractItemUncheckedCreateWithoutWorkActaItemsInput = {
    id?: string
    itemCode: string
    description: string
    unit: string
    unitPrice: number
    contractQuantity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractItemCreateOrConnectWithoutWorkActaItemsInput = {
    where: ContractItemWhereUniqueInput
    create: XOR<ContractItemCreateWithoutWorkActaItemsInput, ContractItemUncheckedCreateWithoutWorkActaItemsInput>
  }

  export type WorkActaUpsertWithoutItemsInput = {
    update: XOR<WorkActaUpdateWithoutItemsInput, WorkActaUncheckedUpdateWithoutItemsInput>
    create: XOR<WorkActaCreateWithoutItemsInput, WorkActaUncheckedCreateWithoutItemsInput>
    where?: WorkActaWhereInput
  }

  export type WorkActaUpdateToOneWithWhereWithoutItemsInput = {
    where?: WorkActaWhereInput
    data: XOR<WorkActaUpdateWithoutItemsInput, WorkActaUncheckedUpdateWithoutItemsInput>
  }

  export type WorkActaUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWorkActaStatusFieldUpdateOperationsInput | $Enums.WorkActaStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUpdateManyWithoutWorkActaNestedInput
  }

  export type WorkActaUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumWorkActaStatusFieldUpdateOperationsInput | $Enums.WorkActaStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutWorkActaNestedInput
  }

  export type ContractItemUpsertWithoutWorkActaItemsInput = {
    update: XOR<ContractItemUpdateWithoutWorkActaItemsInput, ContractItemUncheckedUpdateWithoutWorkActaItemsInput>
    create: XOR<ContractItemCreateWithoutWorkActaItemsInput, ContractItemUncheckedCreateWithoutWorkActaItemsInput>
    where?: ContractItemWhereInput
  }

  export type ContractItemUpdateToOneWithWhereWithoutWorkActaItemsInput = {
    where?: ContractItemWhereInput
    data: XOR<ContractItemUpdateWithoutWorkActaItemsInput, ContractItemUncheckedUpdateWithoutWorkActaItemsInput>
  }

  export type ContractItemUpdateWithoutWorkActaItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    contractQuantity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractItemUncheckedUpdateWithoutWorkActaItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemCode?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    unitPrice?: FloatFieldUpdateOperationsInput | number
    contractQuantity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogEntryCreateManyAuthorInput = {
    id?: string
    folioNumber?: number
    title: string
    description: string
    type: $Enums.EntryType
    subject: string
    location: string
    activityStartDate: Date | string
    activityEndDate: Date | string
    isConfidential?: boolean
    status: $Enums.EntryStatus
    projectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyAuthorInput = {
    id?: string
    content: string
    timestamp?: Date | string
    logEntryId?: string | null
    drawingId?: string | null
  }

  export type SignatureCreateManySignerInput = {
    id?: string
    signedAt?: Date | string
    logEntryId?: string | null
    actaId?: string | null
    reportId?: string | null
  }

  export type CommunicationCreateManyUploaderInput = {
    id?: string
    radicado: string
    subject: string
    description: string
    senderEntity: string
    senderName: string
    senderTitle: string
    recipientEntity: string
    recipientName: string
    recipientTitle: string
    signerName: string
    sentDate: Date | string
    dueDate?: Date | string | null
    deliveryMethod: $Enums.DeliveryMethod
    notes?: string | null
    status: $Enums.CommunicationStatus
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunicationStatusHistoryCreateManyUserInput = {
    id?: string
    status: string
    timestamp?: Date | string
    communicationId: string
  }

  export type PhotoEntryCreateManyAuthorInput = {
    id?: string
    url: string
    date?: Date | string
    notes?: string | null
    controlPointId: string
    attachmentId?: string | null
  }

  export type CommitmentCreateManyResponsibleInput = {
    id?: string
    description: string
    dueDate: Date | string
    status: $Enums.CommitmentStatus
    actaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ObservationCreateManyAuthorInput = {
    id?: string
    text: string
    timestamp?: Date | string
    costActaId: string
  }

  export type ReportCreateManyAuthorInput = {
    id?: string
    type: string
    reportScope: $Enums.ReportScope
    number: string
    period: string
    submissionDate: Date | string
    summary: string
    status: $Enums.ReportStatus
    requiredSignatoriesJson?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DrawingVersionCreateManyUploaderInput = {
    id?: string
    versionNumber: number
    fileName: string
    url: string
    size: number
    uploadDate?: Date | string
    drawingId: string
  }

  export type LogEntryHistoryCreateManyUserInput = {
    id?: string
    fieldName: string
    oldValue?: string | null
    newValue?: string | null
    timestamp?: Date | string
    logEntryId: string
  }

  export type LogEntryUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumEntryTypeFieldUpdateOperationsInput | $Enums.EntryType
    subject?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    activityEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutLogEntriesNestedInput
    assignees?: UserUpdateManyWithoutAssignedToNestedInput
    comments?: CommentUpdateManyWithoutLogEntryNestedInput
    attachments?: AttachmentUpdateManyWithoutLogEntryNestedInput
    signatures?: SignatureUpdateManyWithoutLogEntryNestedInput
    history?: LogEntryHistoryUpdateManyWithoutLogEntryNestedInput
  }

  export type LogEntryUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    folioNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumEntryTypeFieldUpdateOperationsInput | $Enums.EntryType
    subject?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    activityEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignees?: UserUncheckedUpdateManyWithoutAssignedToNestedInput
    comments?: CommentUncheckedUpdateManyWithoutLogEntryNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutLogEntryNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutLogEntryNestedInput
    history?: LogEntryHistoryUncheckedUpdateManyWithoutLogEntryNestedInput
  }

  export type LogEntryUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    folioNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumEntryTypeFieldUpdateOperationsInput | $Enums.EntryType
    subject?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    activityEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogEntryUpdateWithoutAssigneesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumEntryTypeFieldUpdateOperationsInput | $Enums.EntryType
    subject?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    activityEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutLogEntriesNestedInput
    project?: ProjectUpdateOneRequiredWithoutLogEntriesNestedInput
    comments?: CommentUpdateManyWithoutLogEntryNestedInput
    attachments?: AttachmentUpdateManyWithoutLogEntryNestedInput
    signatures?: SignatureUpdateManyWithoutLogEntryNestedInput
    history?: LogEntryHistoryUpdateManyWithoutLogEntryNestedInput
  }

  export type LogEntryUncheckedUpdateWithoutAssigneesInput = {
    id?: StringFieldUpdateOperationsInput | string
    folioNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumEntryTypeFieldUpdateOperationsInput | $Enums.EntryType
    subject?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    activityEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutLogEntryNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutLogEntryNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutLogEntryNestedInput
    history?: LogEntryHistoryUncheckedUpdateManyWithoutLogEntryNestedInput
  }

  export type LogEntryUncheckedUpdateManyWithoutAssigneesInput = {
    id?: StringFieldUpdateOperationsInput | string
    folioNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumEntryTypeFieldUpdateOperationsInput | $Enums.EntryType
    subject?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    activityEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    authorId?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntry?: LogEntryUpdateOneWithoutCommentsNestedInput
    drawing?: DrawingUpdateOneWithoutCommentsNestedInput
    attachments?: AttachmentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    drawingId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    drawingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SignatureUpdateWithoutSignerInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntry?: LogEntryUpdateOneWithoutSignaturesNestedInput
    acta?: ActaUpdateOneWithoutSignaturesNestedInput
    report?: ReportUpdateOneWithoutSignaturesNestedInput
  }

  export type SignatureUncheckedUpdateWithoutSignerInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SignatureUncheckedUpdateManyWithoutSignerInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommunicationUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    radicado?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    senderEntity?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderTitle?: StringFieldUpdateOperationsInput | string
    recipientEntity?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientTitle?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommunicationStatusFieldUpdateOperationsInput | $Enums.CommunicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CommunicationUpdateOneWithoutRepliesNestedInput
    replies?: CommunicationUpdateManyWithoutParentNestedInput
    statusHistory?: CommunicationStatusHistoryUpdateManyWithoutCommunicationNestedInput
    attachments?: AttachmentUpdateManyWithoutCommunicationNestedInput
  }

  export type CommunicationUncheckedUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    radicado?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    senderEntity?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderTitle?: StringFieldUpdateOperationsInput | string
    recipientEntity?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientTitle?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommunicationStatusFieldUpdateOperationsInput | $Enums.CommunicationStatus
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommunicationUncheckedUpdateManyWithoutParentNestedInput
    statusHistory?: CommunicationStatusHistoryUncheckedUpdateManyWithoutCommunicationNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutCommunicationNestedInput
  }

  export type CommunicationUncheckedUpdateManyWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    radicado?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    senderEntity?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderTitle?: StringFieldUpdateOperationsInput | string
    recipientEntity?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientTitle?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommunicationStatusFieldUpdateOperationsInput | $Enums.CommunicationStatus
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationStatusHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    communication?: CommunicationUpdateOneRequiredWithoutStatusHistoryNestedInput
  }

  export type CommunicationStatusHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    communicationId?: StringFieldUpdateOperationsInput | string
  }

  export type CommunicationStatusHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    communicationId?: StringFieldUpdateOperationsInput | string
  }

  export type PhotoEntryUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    controlPoint?: ControlPointUpdateOneRequiredWithoutPhotosNestedInput
    attachment?: AttachmentUpdateOneWithoutPhotoEntryNestedInput
  }

  export type PhotoEntryUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    controlPointId?: StringFieldUpdateOperationsInput | string
    attachmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhotoEntryUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    controlPointId?: StringFieldUpdateOperationsInput | string
    attachmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommitmentUpdateWithoutResponsibleInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCommitmentStatusFieldUpdateOperationsInput | $Enums.CommitmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acta?: ActaUpdateOneRequiredWithoutCommitmentsNestedInput
  }

  export type CommitmentUncheckedUpdateWithoutResponsibleInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCommitmentStatusFieldUpdateOperationsInput | $Enums.CommitmentStatus
    actaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommitmentUncheckedUpdateManyWithoutResponsibleInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCommitmentStatusFieldUpdateOperationsInput | $Enums.CommitmentStatus
    actaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObservationUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    costActa?: CostActaUpdateOneRequiredWithoutObservationsNestedInput
  }

  export type ObservationUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    costActaId?: StringFieldUpdateOperationsInput | string
  }

  export type ObservationUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    costActaId?: StringFieldUpdateOperationsInput | string
  }

  export type ReportUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reportScope?: EnumReportScopeFieldUpdateOperationsInput | $Enums.ReportScope
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    requiredSignatoriesJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUpdateManyWithoutReportNestedInput
    signatures?: SignatureUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reportScope?: EnumReportScopeFieldUpdateOperationsInput | $Enums.ReportScope
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    requiredSignatoriesJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: AttachmentUncheckedUpdateManyWithoutReportNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reportScope?: EnumReportScopeFieldUpdateOperationsInput | $Enums.ReportScope
    number?: StringFieldUpdateOperationsInput | string
    period?: StringFieldUpdateOperationsInput | string
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    requiredSignatoriesJson?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DrawingVersionUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    drawing?: DrawingUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type DrawingVersionUncheckedUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    drawingId?: StringFieldUpdateOperationsInput | string
  }

  export type DrawingVersionUncheckedUpdateManyWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    drawingId?: StringFieldUpdateOperationsInput | string
  }

  export type LogEntryHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntry?: LogEntryUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type LogEntryHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntryId?: StringFieldUpdateOperationsInput | string
  }

  export type LogEntryHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntryId?: StringFieldUpdateOperationsInput | string
  }

  export type KeyPersonnelCreateManyProjectInput = {
    id?: string
    name: string
    role: string
    company: string
    email: string
    phone: string
  }

  export type LogEntryCreateManyProjectInput = {
    id?: string
    folioNumber?: number
    title: string
    description: string
    type: $Enums.EntryType
    subject: string
    location: string
    activityStartDate: Date | string
    activityEndDate: Date | string
    isConfidential?: boolean
    status: $Enums.EntryStatus
    authorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeyPersonnelUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type KeyPersonnelUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type KeyPersonnelUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type LogEntryUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumEntryTypeFieldUpdateOperationsInput | $Enums.EntryType
    subject?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    activityEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutLogEntriesNestedInput
    assignees?: UserUpdateManyWithoutAssignedToNestedInput
    comments?: CommentUpdateManyWithoutLogEntryNestedInput
    attachments?: AttachmentUpdateManyWithoutLogEntryNestedInput
    signatures?: SignatureUpdateManyWithoutLogEntryNestedInput
    history?: LogEntryHistoryUpdateManyWithoutLogEntryNestedInput
  }

  export type LogEntryUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    folioNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumEntryTypeFieldUpdateOperationsInput | $Enums.EntryType
    subject?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    activityEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignees?: UserUncheckedUpdateManyWithoutAssignedToNestedInput
    comments?: CommentUncheckedUpdateManyWithoutLogEntryNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutLogEntryNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutLogEntryNestedInput
    history?: LogEntryHistoryUncheckedUpdateManyWithoutLogEntryNestedInput
  }

  export type LogEntryUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    folioNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumEntryTypeFieldUpdateOperationsInput | $Enums.EntryType
    subject?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    activityStartDate?: DateTimeFieldUpdateOperationsInput | Date | string
    activityEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isConfidential?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumEntryStatusFieldUpdateOperationsInput | $Enums.EntryStatus
    authorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationCreateManyParentInput = {
    id?: string
    radicado: string
    subject: string
    description: string
    senderEntity: string
    senderName: string
    senderTitle: string
    recipientEntity: string
    recipientName: string
    recipientTitle: string
    signerName: string
    sentDate: Date | string
    dueDate?: Date | string | null
    deliveryMethod: $Enums.DeliveryMethod
    notes?: string | null
    status: $Enums.CommunicationStatus
    uploaderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunicationStatusHistoryCreateManyCommunicationInput = {
    id?: string
    status: string
    timestamp?: Date | string
    userId: string
  }

  export type AttachmentCreateManyCommunicationInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    logEntryId?: string | null
    actaId?: string | null
    costActaId?: string | null
    reportId?: string | null
    commentId?: string | null
    workActaId?: string | null
    weeklyReportId?: string | null
    createdAt?: Date | string
  }

  export type CommunicationUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    radicado?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    senderEntity?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderTitle?: StringFieldUpdateOperationsInput | string
    recipientEntity?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientTitle?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommunicationStatusFieldUpdateOperationsInput | $Enums.CommunicationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneRequiredWithoutCommunicationsNestedInput
    replies?: CommunicationUpdateManyWithoutParentNestedInput
    statusHistory?: CommunicationStatusHistoryUpdateManyWithoutCommunicationNestedInput
    attachments?: AttachmentUpdateManyWithoutCommunicationNestedInput
  }

  export type CommunicationUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    radicado?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    senderEntity?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderTitle?: StringFieldUpdateOperationsInput | string
    recipientEntity?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientTitle?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommunicationStatusFieldUpdateOperationsInput | $Enums.CommunicationStatus
    uploaderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommunicationUncheckedUpdateManyWithoutParentNestedInput
    statusHistory?: CommunicationStatusHistoryUncheckedUpdateManyWithoutCommunicationNestedInput
    attachments?: AttachmentUncheckedUpdateManyWithoutCommunicationNestedInput
  }

  export type CommunicationUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    radicado?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    senderEntity?: StringFieldUpdateOperationsInput | string
    senderName?: StringFieldUpdateOperationsInput | string
    senderTitle?: StringFieldUpdateOperationsInput | string
    recipientEntity?: StringFieldUpdateOperationsInput | string
    recipientName?: StringFieldUpdateOperationsInput | string
    recipientTitle?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    sentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveryMethod?: EnumDeliveryMethodFieldUpdateOperationsInput | $Enums.DeliveryMethod
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCommunicationStatusFieldUpdateOperationsInput | $Enums.CommunicationStatus
    uploaderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunicationStatusHistoryUpdateWithoutCommunicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStatusChangesNestedInput
  }

  export type CommunicationStatusHistoryUncheckedUpdateWithoutCommunicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CommunicationStatusHistoryUncheckedUpdateManyWithoutCommunicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AttachmentUpdateWithoutCommunicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntry?: LogEntryUpdateOneWithoutAttachmentsNestedInput
    acta?: ActaUpdateOneWithoutAttachmentsNestedInput
    costActa?: CostActaUpdateOneWithoutAttachmentsNestedInput
    report?: ReportUpdateOneWithoutAttachmentsNestedInput
    comment?: CommentUpdateOneWithoutAttachmentsNestedInput
    contractMod?: ContractModificationUpdateOneWithoutAttachmentNestedInput
    workActa?: WorkActaUpdateOneWithoutAttachmentsNestedInput
    weeklyReport?: WeeklyReportUpdateOneWithoutAttachmentsNestedInput
    photoEntry?: PhotoEntryUpdateOneWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutCommunicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    costActaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    workActaId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyReportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractMod?: ContractModificationUncheckedUpdateOneWithoutAttachmentNestedInput
    photoEntry?: PhotoEntryUncheckedUpdateOneWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateManyWithoutCommunicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    costActaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    workActaId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyReportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateManyWeeklyReportInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    logEntryId?: string | null
    communicationId?: string | null
    actaId?: string | null
    costActaId?: string | null
    reportId?: string | null
    commentId?: string | null
    workActaId?: string | null
    createdAt?: Date | string
  }

  export type AttachmentUpdateWithoutWeeklyReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntry?: LogEntryUpdateOneWithoutAttachmentsNestedInput
    communication?: CommunicationUpdateOneWithoutAttachmentsNestedInput
    acta?: ActaUpdateOneWithoutAttachmentsNestedInput
    costActa?: CostActaUpdateOneWithoutAttachmentsNestedInput
    report?: ReportUpdateOneWithoutAttachmentsNestedInput
    comment?: CommentUpdateOneWithoutAttachmentsNestedInput
    contractMod?: ContractModificationUpdateOneWithoutAttachmentNestedInput
    workActa?: WorkActaUpdateOneWithoutAttachmentsNestedInput
    photoEntry?: PhotoEntryUpdateOneWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutWeeklyReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    communicationId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    costActaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    workActaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractMod?: ContractModificationUncheckedUpdateOneWithoutAttachmentNestedInput
    photoEntry?: PhotoEntryUncheckedUpdateOneWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateManyWithoutWeeklyReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    communicationId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    costActaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    workActaId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyLogEntryInput = {
    id?: string
    content: string
    timestamp?: Date | string
    authorId: string
    drawingId?: string | null
  }

  export type AttachmentCreateManyLogEntryInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    communicationId?: string | null
    actaId?: string | null
    costActaId?: string | null
    reportId?: string | null
    commentId?: string | null
    workActaId?: string | null
    weeklyReportId?: string | null
    createdAt?: Date | string
  }

  export type SignatureCreateManyLogEntryInput = {
    id?: string
    signedAt?: Date | string
    signerId: string
    actaId?: string | null
    reportId?: string | null
  }

  export type LogEntryHistoryCreateManyLogEntryInput = {
    id?: string
    fieldName: string
    oldValue?: string | null
    newValue?: string | null
    timestamp?: Date | string
    userId?: string | null
  }

  export type UserUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    signatures?: SignatureUpdateManyWithoutSignerNestedInput
    communications?: CommunicationUpdateManyWithoutUploaderNestedInput
    statusChanges?: CommunicationStatusHistoryUpdateManyWithoutUserNestedInput
    photoEntries?: PhotoEntryUpdateManyWithoutAuthorNestedInput
    responsibleFor?: CommitmentUpdateManyWithoutResponsibleNestedInput
    observations?: ObservationUpdateManyWithoutAuthorNestedInput
    reports?: ReportUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUpdateManyWithoutUploaderNestedInput
    logEntryHistory?: LogEntryHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntries?: LogEntryUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    signatures?: SignatureUncheckedUpdateManyWithoutSignerNestedInput
    communications?: CommunicationUncheckedUpdateManyWithoutUploaderNestedInput
    statusChanges?: CommunicationStatusHistoryUncheckedUpdateManyWithoutUserNestedInput
    photoEntries?: PhotoEntryUncheckedUpdateManyWithoutAuthorNestedInput
    responsibleFor?: CommitmentUncheckedUpdateManyWithoutResponsibleNestedInput
    observations?: ObservationUncheckedUpdateManyWithoutAuthorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutAuthorNestedInput
    drawingVersions?: DrawingVersionUncheckedUpdateManyWithoutUploaderNestedInput
    logEntryHistory?: LogEntryHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    projectRole?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    appRole?: EnumAppRoleFieldUpdateOperationsInput | $Enums.AppRole
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tokenVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutLogEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    drawing?: DrawingUpdateOneWithoutCommentsNestedInput
    attachments?: AttachmentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutLogEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    drawingId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutLogEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    drawingId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttachmentUpdateWithoutLogEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    communication?: CommunicationUpdateOneWithoutAttachmentsNestedInput
    acta?: ActaUpdateOneWithoutAttachmentsNestedInput
    costActa?: CostActaUpdateOneWithoutAttachmentsNestedInput
    report?: ReportUpdateOneWithoutAttachmentsNestedInput
    comment?: CommentUpdateOneWithoutAttachmentsNestedInput
    contractMod?: ContractModificationUpdateOneWithoutAttachmentNestedInput
    workActa?: WorkActaUpdateOneWithoutAttachmentsNestedInput
    weeklyReport?: WeeklyReportUpdateOneWithoutAttachmentsNestedInput
    photoEntry?: PhotoEntryUpdateOneWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutLogEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    communicationId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    costActaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    workActaId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyReportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractMod?: ContractModificationUncheckedUpdateOneWithoutAttachmentNestedInput
    photoEntry?: PhotoEntryUncheckedUpdateOneWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateManyWithoutLogEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    communicationId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    costActaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    workActaId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyReportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignatureUpdateWithoutLogEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signer?: UserUpdateOneRequiredWithoutSignaturesNestedInput
    acta?: ActaUpdateOneWithoutSignaturesNestedInput
    report?: ReportUpdateOneWithoutSignaturesNestedInput
  }

  export type SignatureUncheckedUpdateWithoutLogEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signerId?: StringFieldUpdateOperationsInput | string
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SignatureUncheckedUpdateManyWithoutLogEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signerId?: StringFieldUpdateOperationsInput | string
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogEntryHistoryUpdateWithoutLogEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutLogEntryHistoryNestedInput
  }

  export type LogEntryHistoryUncheckedUpdateWithoutLogEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogEntryHistoryUncheckedUpdateManyWithoutLogEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttachmentCreateManyCommentInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    logEntryId?: string | null
    communicationId?: string | null
    actaId?: string | null
    costActaId?: string | null
    reportId?: string | null
    workActaId?: string | null
    weeklyReportId?: string | null
    createdAt?: Date | string
  }

  export type AttachmentUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntry?: LogEntryUpdateOneWithoutAttachmentsNestedInput
    communication?: CommunicationUpdateOneWithoutAttachmentsNestedInput
    acta?: ActaUpdateOneWithoutAttachmentsNestedInput
    costActa?: CostActaUpdateOneWithoutAttachmentsNestedInput
    report?: ReportUpdateOneWithoutAttachmentsNestedInput
    contractMod?: ContractModificationUpdateOneWithoutAttachmentNestedInput
    workActa?: WorkActaUpdateOneWithoutAttachmentsNestedInput
    weeklyReport?: WeeklyReportUpdateOneWithoutAttachmentsNestedInput
    photoEntry?: PhotoEntryUpdateOneWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    communicationId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    costActaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    workActaId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyReportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractMod?: ContractModificationUncheckedUpdateOneWithoutAttachmentNestedInput
    photoEntry?: PhotoEntryUncheckedUpdateOneWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    communicationId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    costActaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    workActaId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyReportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateManyActaInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    logEntryId?: string | null
    communicationId?: string | null
    costActaId?: string | null
    reportId?: string | null
    commentId?: string | null
    workActaId?: string | null
    weeklyReportId?: string | null
    createdAt?: Date | string
  }

  export type SignatureCreateManyActaInput = {
    id?: string
    signedAt?: Date | string
    signerId: string
    logEntryId?: string | null
    reportId?: string | null
  }

  export type CommitmentCreateManyActaInput = {
    id?: string
    description: string
    dueDate: Date | string
    status: $Enums.CommitmentStatus
    responsibleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttachmentUpdateWithoutActaInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntry?: LogEntryUpdateOneWithoutAttachmentsNestedInput
    communication?: CommunicationUpdateOneWithoutAttachmentsNestedInput
    costActa?: CostActaUpdateOneWithoutAttachmentsNestedInput
    report?: ReportUpdateOneWithoutAttachmentsNestedInput
    comment?: CommentUpdateOneWithoutAttachmentsNestedInput
    contractMod?: ContractModificationUpdateOneWithoutAttachmentNestedInput
    workActa?: WorkActaUpdateOneWithoutAttachmentsNestedInput
    weeklyReport?: WeeklyReportUpdateOneWithoutAttachmentsNestedInput
    photoEntry?: PhotoEntryUpdateOneWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutActaInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    communicationId?: NullableStringFieldUpdateOperationsInput | string | null
    costActaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    workActaId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyReportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractMod?: ContractModificationUncheckedUpdateOneWithoutAttachmentNestedInput
    photoEntry?: PhotoEntryUncheckedUpdateOneWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateManyWithoutActaInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    communicationId?: NullableStringFieldUpdateOperationsInput | string | null
    costActaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    workActaId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyReportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignatureUpdateWithoutActaInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signer?: UserUpdateOneRequiredWithoutSignaturesNestedInput
    logEntry?: LogEntryUpdateOneWithoutSignaturesNestedInput
    report?: ReportUpdateOneWithoutSignaturesNestedInput
  }

  export type SignatureUncheckedUpdateWithoutActaInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signerId?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SignatureUncheckedUpdateManyWithoutActaInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signerId?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommitmentUpdateWithoutActaInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCommitmentStatusFieldUpdateOperationsInput | $Enums.CommitmentStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsible?: UserUpdateOneRequiredWithoutResponsibleForNestedInput
  }

  export type CommitmentUncheckedUpdateWithoutActaInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCommitmentStatusFieldUpdateOperationsInput | $Enums.CommitmentStatus
    responsibleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommitmentUncheckedUpdateManyWithoutActaInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumCommitmentStatusFieldUpdateOperationsInput | $Enums.CommitmentStatus
    responsibleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObservationCreateManyCostActaInput = {
    id?: string
    text: string
    timestamp?: Date | string
    authorId: string
  }

  export type AttachmentCreateManyCostActaInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    logEntryId?: string | null
    communicationId?: string | null
    actaId?: string | null
    reportId?: string | null
    commentId?: string | null
    workActaId?: string | null
    weeklyReportId?: string | null
    createdAt?: Date | string
  }

  export type ObservationUpdateWithoutCostActaInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutObservationsNestedInput
  }

  export type ObservationUncheckedUpdateWithoutCostActaInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type ObservationUncheckedUpdateManyWithoutCostActaInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
  }

  export type AttachmentUpdateWithoutCostActaInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntry?: LogEntryUpdateOneWithoutAttachmentsNestedInput
    communication?: CommunicationUpdateOneWithoutAttachmentsNestedInput
    acta?: ActaUpdateOneWithoutAttachmentsNestedInput
    report?: ReportUpdateOneWithoutAttachmentsNestedInput
    comment?: CommentUpdateOneWithoutAttachmentsNestedInput
    contractMod?: ContractModificationUpdateOneWithoutAttachmentNestedInput
    workActa?: WorkActaUpdateOneWithoutAttachmentsNestedInput
    weeklyReport?: WeeklyReportUpdateOneWithoutAttachmentsNestedInput
    photoEntry?: PhotoEntryUpdateOneWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutCostActaInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    communicationId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    workActaId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyReportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractMod?: ContractModificationUncheckedUpdateOneWithoutAttachmentNestedInput
    photoEntry?: PhotoEntryUncheckedUpdateOneWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateManyWithoutCostActaInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    communicationId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    workActaId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyReportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentCreateManyReportInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    logEntryId?: string | null
    communicationId?: string | null
    actaId?: string | null
    costActaId?: string | null
    commentId?: string | null
    workActaId?: string | null
    weeklyReportId?: string | null
    createdAt?: Date | string
  }

  export type SignatureCreateManyReportInput = {
    id?: string
    signedAt?: Date | string
    signerId: string
    logEntryId?: string | null
    actaId?: string | null
  }

  export type AttachmentUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntry?: LogEntryUpdateOneWithoutAttachmentsNestedInput
    communication?: CommunicationUpdateOneWithoutAttachmentsNestedInput
    acta?: ActaUpdateOneWithoutAttachmentsNestedInput
    costActa?: CostActaUpdateOneWithoutAttachmentsNestedInput
    comment?: CommentUpdateOneWithoutAttachmentsNestedInput
    contractMod?: ContractModificationUpdateOneWithoutAttachmentNestedInput
    workActa?: WorkActaUpdateOneWithoutAttachmentsNestedInput
    weeklyReport?: WeeklyReportUpdateOneWithoutAttachmentsNestedInput
    photoEntry?: PhotoEntryUpdateOneWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    communicationId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    costActaId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    workActaId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyReportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractMod?: ContractModificationUncheckedUpdateOneWithoutAttachmentNestedInput
    photoEntry?: PhotoEntryUncheckedUpdateOneWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateManyWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    communicationId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    costActaId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    workActaId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyReportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SignatureUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signer?: UserUpdateOneRequiredWithoutSignaturesNestedInput
    logEntry?: LogEntryUpdateOneWithoutSignaturesNestedInput
    acta?: ActaUpdateOneWithoutSignaturesNestedInput
  }

  export type SignatureUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signerId?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SignatureUncheckedUpdateManyWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signerId?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DrawingVersionCreateManyDrawingInput = {
    id?: string
    versionNumber: number
    fileName: string
    url: string
    size: number
    uploadDate?: Date | string
    uploaderId: string
  }

  export type CommentCreateManyDrawingInput = {
    id?: string
    content: string
    timestamp?: Date | string
    authorId: string
    logEntryId?: string | null
  }

  export type DrawingVersionUpdateWithoutDrawingInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneRequiredWithoutDrawingVersionsNestedInput
  }

  export type DrawingVersionUncheckedUpdateWithoutDrawingInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    uploaderId?: StringFieldUpdateOperationsInput | string
  }

  export type DrawingVersionUncheckedUpdateManyWithoutDrawingInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    uploaderId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUpdateWithoutDrawingInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    logEntry?: LogEntryUpdateOneWithoutCommentsNestedInput
    attachments?: AttachmentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutDrawingInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: AttachmentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutDrawingInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    authorId?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhotoEntryCreateManyControlPointInput = {
    id?: string
    url: string
    date?: Date | string
    notes?: string | null
    authorId: string
    attachmentId?: string | null
  }

  export type PhotoEntryUpdateWithoutControlPointInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    author?: UserUpdateOneRequiredWithoutPhotoEntriesNestedInput
    attachment?: AttachmentUpdateOneWithoutPhotoEntryNestedInput
  }

  export type PhotoEntryUncheckedUpdateWithoutControlPointInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    attachmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhotoEntryUncheckedUpdateManyWithoutControlPointInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    attachmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkActaItemCreateManyContractItemInput = {
    id?: string
    quantity: number
    workActaId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkActaItemUpdateWithoutContractItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workActa?: WorkActaUpdateOneRequiredWithoutItemsNestedInput
  }

  export type WorkActaItemUncheckedUpdateWithoutContractItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    workActaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkActaItemUncheckedUpdateManyWithoutContractItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    workActaId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkActaItemCreateManyWorkActaInput = {
    id?: string
    quantity: number
    contractItemId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttachmentCreateManyWorkActaInput = {
    id?: string
    fileName: string
    url: string
    size: number
    type: string
    logEntryId?: string | null
    communicationId?: string | null
    actaId?: string | null
    costActaId?: string | null
    reportId?: string | null
    commentId?: string | null
    weeklyReportId?: string | null
    createdAt?: Date | string
  }

  export type WorkActaItemUpdateWithoutWorkActaInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractItem?: ContractItemUpdateOneRequiredWithoutWorkActaItemsNestedInput
  }

  export type WorkActaItemUncheckedUpdateWithoutWorkActaInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    contractItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkActaItemUncheckedUpdateManyWithoutWorkActaInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    contractItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttachmentUpdateWithoutWorkActaInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logEntry?: LogEntryUpdateOneWithoutAttachmentsNestedInput
    communication?: CommunicationUpdateOneWithoutAttachmentsNestedInput
    acta?: ActaUpdateOneWithoutAttachmentsNestedInput
    costActa?: CostActaUpdateOneWithoutAttachmentsNestedInput
    report?: ReportUpdateOneWithoutAttachmentsNestedInput
    comment?: CommentUpdateOneWithoutAttachmentsNestedInput
    contractMod?: ContractModificationUpdateOneWithoutAttachmentNestedInput
    weeklyReport?: WeeklyReportUpdateOneWithoutAttachmentsNestedInput
    photoEntry?: PhotoEntryUpdateOneWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateWithoutWorkActaInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    communicationId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    costActaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyReportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractMod?: ContractModificationUncheckedUpdateOneWithoutAttachmentNestedInput
    photoEntry?: PhotoEntryUncheckedUpdateOneWithoutAttachmentNestedInput
  }

  export type AttachmentUncheckedUpdateManyWithoutWorkActaInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    logEntryId?: NullableStringFieldUpdateOperationsInput | string | null
    communicationId?: NullableStringFieldUpdateOperationsInput | string | null
    actaId?: NullableStringFieldUpdateOperationsInput | string | null
    costActaId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    weeklyReportId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectCountOutputTypeDefaultArgs instead
     */
    export type ProjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunicationCountOutputTypeDefaultArgs instead
     */
    export type CommunicationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunicationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WeeklyReportCountOutputTypeDefaultArgs instead
     */
    export type WeeklyReportCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WeeklyReportCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogEntryCountOutputTypeDefaultArgs instead
     */
    export type LogEntryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogEntryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentCountOutputTypeDefaultArgs instead
     */
    export type CommentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActaCountOutputTypeDefaultArgs instead
     */
    export type ActaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CostActaCountOutputTypeDefaultArgs instead
     */
    export type CostActaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CostActaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportCountOutputTypeDefaultArgs instead
     */
    export type ReportCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DrawingCountOutputTypeDefaultArgs instead
     */
    export type DrawingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DrawingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ControlPointCountOutputTypeDefaultArgs instead
     */
    export type ControlPointCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ControlPointCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractItemCountOutputTypeDefaultArgs instead
     */
    export type ContractItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkActaCountOutputTypeDefaultArgs instead
     */
    export type WorkActaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkActaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectDefaultArgs instead
     */
    export type ProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KeyPersonnelDefaultArgs instead
     */
    export type KeyPersonnelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KeyPersonnelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunicationDefaultArgs instead
     */
    export type CommunicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommunicationStatusHistoryDefaultArgs instead
     */
    export type CommunicationStatusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommunicationStatusHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractModificationDefaultArgs instead
     */
    export type ContractModificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractModificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WeeklyReportDefaultArgs instead
     */
    export type WeeklyReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WeeklyReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogEntryDefaultArgs instead
     */
    export type LogEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogEntryHistoryDefaultArgs instead
     */
    export type LogEntryHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogEntryHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SignatureDefaultArgs instead
     */
    export type SignatureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SignatureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AttachmentDefaultArgs instead
     */
    export type AttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AttachmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActaDefaultArgs instead
     */
    export type ActaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommitmentDefaultArgs instead
     */
    export type CommitmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommitmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CostActaDefaultArgs instead
     */
    export type CostActaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CostActaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObservationDefaultArgs instead
     */
    export type ObservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObservationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDefaultArgs instead
     */
    export type ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DrawingDefaultArgs instead
     */
    export type DrawingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DrawingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DrawingVersionDefaultArgs instead
     */
    export type DrawingVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DrawingVersionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PhotoEntryDefaultArgs instead
     */
    export type PhotoEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PhotoEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ControlPointDefaultArgs instead
     */
    export type ControlPointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ControlPointDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjectTaskDefaultArgs instead
     */
    export type ProjectTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjectTaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractItemDefaultArgs instead
     */
    export type ContractItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkActaDefaultArgs instead
     */
    export type WorkActaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkActaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkActaItemDefaultArgs instead
     */
    export type WorkActaItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkActaItemDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}